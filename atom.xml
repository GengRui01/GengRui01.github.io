<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>耿锐的博客</title>
  
  <subtitle>欢迎的来到耿锐的技术小栈</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.gengruiblog.cn/"/>
  <updated>2021-10-05T07:27:15.101Z</updated>
  <id>https://www.gengruiblog.cn/</id>
  
  <author>
    <name>耿锐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言数据类型转换</title>
    <link href="https://www.gengruiblog.cn/article/20210925.html"/>
    <id>https://www.gengruiblog.cn/article/20210925.html</id>
    <published>2021-09-24T16:00:00.000Z</published>
    <updated>2021-10-05T07:27:15.101Z</updated>
    
    <content type="html"><![CDATA[<p>C语言规定，不同类型的数据进行运算时要先转换成相同类型的数据才能进行运算</p><p>数据类型转换就是将数据（变量、数值、表达式的结果等）从一种类型转换为另一种类型</p><p>数据类型的各种转换只影响表达式的运算结果，并不改变原变量的定义类型，并且其数据值也不会发生任何改变</p><a id="more"></a><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>自动类型转换就是编译器默默地、隐式地、偷偷地进行的数据类型转换</p><p>这种转换不需要程序员干预，会由C语言编译系统自动完成</p><p>转换规则是：</p><p>把占用内存空间少的（低级）类型向占用空间多的（高级）类型转换，以保证运算的精度</p><p><img src="https://gengrui01.github.io/picture/c-datatype-conversion/1.png" alt=""></p><ul><li>图中的纵向箭头表示必定的转换</li><li>图中的横向箭头表示当经过纵向的转换后，进行运算的数据类型仍然不同时进行的转换方式</li></ul><blockquote><p>例：若有定义“double d=153;int i=10;float f=3.8;”，则表达式d+’a’+i*d/f的值的类型是<strong>___</strong>。</p></blockquote><p>分析：</p><ol><li>将int型变量i和float型变量f转换为double型后，进行i*d/f的运算，结果为double型。</li><li>将char型常量’a’转换为int型，进行d+’a’的计算，此时“+”左右两边数据的类型不同，则再将int型转换为double型，进行加法运算，结果为double型。</li><li>将（1）的结果和（2）的结果进行加法计算，最终结果为double型</li></ol><blockquote><p>自动类型转换示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="keyword">int</span> s1, r = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">double</span> s2;</span><br><span class="line">    s1 = r * r * PI;</span><br><span class="line">    s2 = r * r * PI;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s1=%d, s2=%f\n"</span>, s1, s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：s1=78, s2=78.539749</p><p>分析：</p><ul><li>在计算表达式r<em>r</em>PI时，r 和 PI 都被转换成 double 类型，表达式的结果也是 double 类型</li><li>但由于 s1 为整型，所以赋值运算的结果仍为整型，舍去了小数部分，导致数据失真</li></ul><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>采用强制类型转换运算符将某种数据类型强制转换成指定的数据类型</p><p>其一般形式为：</p><p><code>(类型说明符)(表达式)</code></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">float</span>) a;  <span class="comment">/* 将变量 a 转换为 float 类型 */</span></span><br><span class="line">(<span class="keyword">int</span>)(x+y);  <span class="comment">/* 把表达式 x+y 的结果转换为 int 整型 */</span></span><br><span class="line">(<span class="keyword">float</span>) <span class="number">100</span>;  <span class="comment">/* 将数值 100（默认为int类型）转换为 float 类型 */</span></span><br></pre></td></tr></table></figure><blockquote><p>例：强制类型转换示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">    c=(<span class="keyword">float</span>)(a+b)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%f\n"</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：c=3.500000</p><p><strong><em>TIPS:</em></strong> </p><blockquote><p>需强制类型转换中的表达式一定要括起来，否则只对紧随括号后的量进行类型转换<br>强制类型转换是一种不安全的转换，如果是从高级类型转换成低级类型，则会损失数据的精度</p></blockquote><h2 id="类型转换只是临时性的"><a href="#类型转换只是临时性的" class="headerlink" title="类型转换只是临时性的"></a>类型转换只是临时性的</h2><p>无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换</p><p>转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值</p><blockquote><p>例如：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">400.8</span>;  <span class="comment">/* 总价 */</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">5</span>;  <span class="comment">/* 数目 */</span></span><br><span class="line">    <span class="keyword">double</span> unit;  <span class="comment">/* 单价 */</span></span><br><span class="line">    <span class="keyword">int</span> total_int = (<span class="keyword">int</span>)total;</span><br><span class="line">    unit = total / count;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total=%lf, total_int=%d, unit=%lf\n"</span>, total, total_int, unit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>total=400.800000, total_int=400, unit=80.160000</p><p>分析：</p><ul><li>第 6 行代码，total 变量被转换成了 int 类型才赋值给 total_int 变量</li><li>而这种转换并未影响 total 变量本身的类型和值</li><li>如果 total 的值变了，那么 total 的输出结果将变为 400.000000</li><li>如果 total 的类型变了，那么 unit 的输出结果将变为 80.000000</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言规定，不同类型的数据进行运算时要先转换成相同类型的数据才能进行运算&lt;/p&gt;
&lt;p&gt;数据类型转换就是将数据（变量、数值、表达式的结果等）从一种类型转换为另一种类型&lt;/p&gt;
&lt;p&gt;数据类型的各种转换只影响表达式的运算结果，并不改变原变量的定义类型，并且其数据值也不会发生任何改变&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.gengruiblog.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言运算符和表达式</title>
    <link href="https://www.gengruiblog.cn/article/20210924.html"/>
    <id>https://www.gengruiblog.cn/article/20210924.html</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-26T07:18:08.985Z</updated>
    
    <content type="html"><![CDATA[<p>C语言中，运算符和表达式数量之多，在其他高级语言中是很少见的</p><p>正是丰富的运算符和表达式使C语言功能十分完善，这也是C语言的特点之一</p><p>本文介绍其中的一部分运算符，其他的运算符将陆续在后续各文中讲述</p><a id="more"></a><h2 id="赋值运算符和赋值表达式"><a href="#赋值运算符和赋值表达式" class="headerlink" title="赋值运算符和赋值表达式"></a>赋值运算符和赋值表达式</h2><p>赋值运算符有“=”、“+=”、“-=”、“*=”、“/=”和“%=”等</p><p>用赋值运算符将运算对象连接而成的表达式称为赋值表达式</p><h3 id="简单赋值运算符"><a href="#简单赋值运算符" class="headerlink" title="简单赋值运算符"></a>简单赋值运算符</h3><p>将“=”右边表达式的值赋给左边的变量</p><p>例如： <code>a=8;</code>、 <code>s=a*2+b;</code></p><p>先计算出右边表达式的值，再赋给左边的变量。如果“=”左右两边类型不同，系统会按照赋值类型转换的原则将右边的类型转换成左边的类型</p><h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p>在简单赋值运算符前面加上算术运算符就构成复合算术赋值运算符，如下表所示：</p><table><thead><tr><th>运算符</th><th>应用举例</th><th>等价形式</th></tr></thead><tbody><tr><td>+=</td><td>a+=x</td><td>a=a+(x)</td></tr><tr><td>-=</td><td>a-=x</td><td>a=a-(x)</td></tr><tr><td>*=</td><td>a*=x</td><td>a=a*(x)</td></tr><tr><td>/=</td><td>a/=x</td><td>a=a/(x)</td></tr><tr><td>%=</td><td>a%=x</td><td>a=a%(x)</td></tr></tbody></table><h3 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h3><p>由赋值运算符将一个变量和一个表达式连接起来的式子所组成。一般形式为：<code>变量 = 表达式</code></p><p>下面是赋值表达式的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v=<span class="number">4.0</span>*PI*r*r*r/<span class="number">3.0</span></span><br><span class="line">a=<span class="number">15</span>+(i=<span class="number">6</span>)</span><br><span class="line">b=(x=<span class="number">3</span>)+(y=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>而 <code>3=x</code> 和 <code>a+b=4</code> 都是错误的赋值表达式</p><p>赋值表达式的执行过程是：</p><ol><li>计算赋值运算符右侧表达式的值；</li><li>将所计算出的值赋给赋值运算符左侧的变量</li></ol><p><strong><em>TIPS:</em></strong></p><blockquote><p>赋值运算符的左边只能是变量，不能是常量或表达式<br>赋值表达式的值就是赋值运算符左边变量的值<br>赋值表达式的右边也可以是一个赋值表达式</p></blockquote><p>如下例题：</p><blockquote><p>例：若有定义“int x=15,a,b;”，则表达式“x%=(a=3)+(b=4)”的值是 ?</p></blockquote><p>答案：</p><ul><li>x%=(a=3)+(b=4)</li><li>x%=3+4</li><li>x%=7</li><li>x=x%7</li><li>x=15代入得：</li><li>x=15%7=1</li></ul><blockquote><p>例：已有声明“int x=15, y; float z=12;”，下列表达式中语法正确的是        。<br>A．y=x%z<br>B．y=x+=z*=4<br>C．y=x/2=z<br>D．(y=x+3)=z/2</p></blockquote><p>答案：B</p><h2 id="算数运算符和算数表达式"><a href="#算数运算符和算数表达式" class="headerlink" title="算数运算符和算数表达式"></a>算数运算符和算数表达式</h2><h3 id="基本的算术运算符"><a href="#基本的算术运算符" class="headerlink" title="基本的算术运算符"></a>基本的算术运算符</h3><table><thead><tr><th>运算符</th><th>+</th><th>-</th><th>*</th><th>/</th><th>%</th></tr></thead><tbody><tr><td>名称</td><td>加</td><td>减</td><td>乘</td><td>除</td><td>取余</td></tr></tbody></table><p><strong><em>TIPS:</em></strong></p><blockquote><p>两个整型数据做除法运算时，结果一定是整数<br>求余运算的结果是两个整型数据相除的余数。求余运算只能用于整型数据的运算<br>算数运算符两边的数据类型应相同，若不同时，编译系统会先转换为同一数据类型，然后再进行运算</p></blockquote><h3 id="单目运算符"><a href="#单目运算符" class="headerlink" title="单目运算符"></a>单目运算符</h3><ul><li><code>-</code> 负号：负数</li><li><code>++</code> 自增运算符：使变量的值自加1</li><li><code>--</code> 自减运算符：使变量的值自减1</li></ul><p>有两种使用形式：</p><ul><li>前缀方式：用于变量前面，它是 <strong>“先计算，后使用”</strong> </li><li>后缀方式：用于变量后面，它是 <strong>“先使用，后计算”</strong> </li></ul><blockquote><p>例：设有定义如下：<br>#define d 2<br>int x=5;<br>float y=3.83;<br>char c=’d’;<br>分析以下各表达式使用正确与否：<br>A．(-x)++<br>B．y++<br>C．c++<br>D．d++</p></blockquote><p>答案：A错  B对  C对  D错</p><h3 id="算术运算符的优先级和结合性"><a href="#算术运算符的优先级和结合性" class="headerlink" title="算术运算符的优先级和结合性"></a>算术运算符的优先级和结合性</h3><ol><li>单目运算符的优先级高于双目运算符</li><li>双目算术运算符中*、/、%的优先级高于+、-</li><li>在优先级相同的情况下，按规定的“结合方向”进行处理</li></ol><h3 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h3><ul><li>算术表达式是由算术运算符、运算对象和括号连接起来的式子</li><li>所有的数学表达式均可写成C语言的算术表达式，但是有些数学表达式无法直接用C语言的算术表达式写出，此时需要调用C语言中的数学函数来实现</li></ul><p><strong><em>TIPS:</em></strong></p><blockquote><p>表达式中的乘号不能省略，且表达式中的所有字符均应写在同一行上<br>在表达式中还可以使用多层圆括号（不能使用中括号[]和花括号{}），但是要注意括号的配对<br>在数学中，5×6÷4的运算结果与6÷4×5的结果相同，都是 7.5，但是C语言中表达式5<em>6/4的结果却与6/4</em>5的结果不一样<br>还需注意 8/(8/10)之类的表达式，因为(8/10)的结果为 0，用0做除数将会出现运算溢出的错误，为了不使 8/10 的结果为 0，应将整型常量改为实型常量8.0/10</p></blockquote><p>举个例子：</p><blockquote><p>例：输入一个三位正整数，输出其反序数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">456</span>;</span><br><span class="line">    <span class="keyword">int</span> a = number / <span class="number">100</span>; <span class="comment">/* 计算百位数 */</span></span><br><span class="line">    <span class="keyword">int</span> b = (number - a * <span class="number">100</span>) / <span class="number">10</span>;<span class="comment">/* 计算十位数 */</span></span><br><span class="line">    <span class="keyword">int</span> c = number % <span class="number">10</span>;<span class="comment">/* 计算个位数 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"反序数是:%d%d%d\n"</span>, c, b, a); <span class="comment">/* 输出*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：反序数是:321</p><h2 id="逗号运算符和逗号表达式"><a href="#逗号运算符和逗号表达式" class="headerlink" title="逗号运算符和逗号表达式"></a>逗号运算符和逗号表达式</h2><p>逗号运算符（,）：功能是把多个表达式连接起来组成一个表达式，称为逗号表达式</p><p>逗号表达式的一般形式为： </p><p>表达式1，表达式2，…，表达式n</p><ol><li>逗号表达式的执行顺序：从左到右依次执行每个表达式</li><li>逗号表达式的值为“表达式n”的值</li><li>逗号运算符是双目运算符，其优先级最低，是左结合的</li><li>并非所有出现逗号的地方都可以作为逗号表达式，如<code>printf(&quot;%d%d&quot;,&amp;a,&amp;b)</code>，其中的 <code>&quot;%d%d&quot;,&amp;a,&amp;b</code> 并不是一个逗号表达式，而是<code>printf</code>函数的参数</li></ol><blockquote><p>例：逗号表达式应用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">float</span> k=<span class="number">5</span>;</span><br><span class="line">i=(j=j+<span class="number">2</span>,j/k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i=%d\n"</span>,i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：i=1</p><h2 id="求字节数运算符"><a href="#求字节数运算符" class="headerlink" title="求字节数运算符"></a>求字节数运算符</h2><p>sizeof(…)：是一个单目运算符，用于计算数据类型所占的字节数，其一般格式为：</p><ol><li>sizeof(表达式)或sizeof 表达式</li><li>sizeof(数据类型名)</li></ol><blockquote><p>例：不同数据类型字节数示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char类型占%d字节\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"short int类型占%d字节\n"</span>,<span class="keyword">sizeof</span>(short <span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"int类型占%d字节\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float类型占%d字节\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"double类型占%d字节\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><ul><li>char类型占1字节</li><li>short int类型占2字节</li><li>int类型占4字节</li><li>float类型占4字节</li><li>double类型占8字节</li></ul><blockquote><p>例：求字节数运算符示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a=<span class="keyword">sizeof</span>(<span class="number">3</span>+<span class="number">5.0</span>);</span><br><span class="line">b=<span class="keyword">sizeof</span> <span class="number">3</span>+<span class="number">5.0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d,%d\n"</span>,a,b,<span class="keyword">sizeof</span>(<span class="string">"china"</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：8,9,6</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言中，运算符和表达式数量之多，在其他高级语言中是很少见的&lt;/p&gt;
&lt;p&gt;正是丰富的运算符和表达式使C语言功能十分完善，这也是C语言的特点之一&lt;/p&gt;
&lt;p&gt;本文介绍其中的一部分运算符，其他的运算符将陆续在后续各文中讲述&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.gengruiblog.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言数据类型、变量和常量</title>
    <link href="https://www.gengruiblog.cn/article/20210923.html"/>
    <id>https://www.gengruiblog.cn/article/20210923.html</id>
    <published>2021-09-22T16:00:00.000Z</published>
    <updated>2021-09-24T00:48:59.138Z</updated>
    
    <content type="html"><![CDATA[<p>通常在学习程序设计语言的初期，要从基本要素入手，逐步掌握语言的各种语法规则</p><p>就好比造一座大厦，基础没有打好基于往上盖，其后果可想而知</p><p>所以要想熟练的使用C语言进行程序设计是一个循序渐进的过程</p><p>这篇文章开始我们会写一些C语言代码，循序渐进的掌握C语言的语法规则</p><a id="more"></a><h2 id="简单代码运行"><a href="#简单代码运行" class="headerlink" title="简单代码运行"></a>简单代码运行</h2><blockquote><p>代码1：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                     </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"HelloWorld!"</span>);   </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>#include &lt;stdio.h&gt;</code>：stdio.h为系统文件，内部定义了printf()等方法，在程序最开始可以使用include将头文件引入进来</li><li><code>int main(void)</code>：在一个C程序中有且仅有一个main()函数，他是程序运行的入口，main函数前面表示的是程序的返回值类型，后面表示的是传入参数，这里传入参数为void，也就是为空（可省略），返回参数是int类型</li><li><code>printf(&quot;HelloWorld!&quot;);</code>：此处调用了标准输出函数，会将引号中的内容输出到屏幕上，语句后的分号表示该语句的结束</li><li><code>return()</code> 语句可以就结束程序，一般返回0表示程序运行正常，返回其他值则表示不同的错误情况</li></ul><blockquote><p>代码2：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Programming is fun.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"And Programming in C is even more fun!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>\n</code>：换行符，表示在输出“Programming is fun.”后换行，<code>\n</code>是转义字符，在本章节会介绍</li></ul><blockquote><p>代码3：输入半径，分别计算球体积和球表面积</p></blockquote><p>设球半径为r、球体积为v、球表面积为f，球体积和球表面积的计算公式如下：</p><p><img src="https://gengrui01.github.io/picture/c-datatype-constant-varibles/1.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">float</span> v,f;</span><br><span class="line">    r=<span class="number">2</span>;</span><br><span class="line">    v=<span class="number">4.0</span>*PI*r*r*r/<span class="number">3.0</span>;</span><br><span class="line">    f=<span class="number">4.0</span>*PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"体积为：%f，表面积为：%f\n"</span>,v,f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>#define PI 3.14159</code>：定义一个符号常量PI，这样程序中凡是需要使用3.14159的地方都可以用PI代替</li><li><code>void main()</code>：main函数前面表示的是程序的返回值类型，后面表示的是传入参数，这里传入参数为空被省略了，返回参数也是空，也可以被省略</li><li><code>%f</code>：会将printf引号内除了<code>%f</code>之外的内容原样输出，并在第一个<code>%f</code>上输出v的值，在第二个<code>%f</code>上输出f的值</li></ul><h2 id="C语言的数据类型"><a href="#C语言的数据类型" class="headerlink" title="C语言的数据类型"></a>C语言的数据类型</h2><p><img src="https://gengrui01.github.io/picture/c-datatype-constant-varibles/2.png" alt=""></p><h2 id="C语言的常量"><a href="#C语言的常量" class="headerlink" title="C语言的常量"></a>C语言的常量</h2><p>常量是指在程序运行的过程中值不能被改变的量</p><h3 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h3><p><strong>1. 整数常量</strong></p><ul><li>十进制表示：由数字0～9，正、负号组成</li><li>八进制表示：以0（数字0）为前缀，其后由数字0～7组成；八进制数一般是无符号数</li><li>十六进制表示：以0x或0X为前缀，其后由数字0～9和字母A～F（字母大小写均可）组成，十六进制数一般是无符号数</li></ul><p><strong>2. 实型常量</strong></p><p>实型常量即实数，又称为浮点数。</p><p>C语言中，实数只能用十进制形式表示，实数的表示方法有两种：小数形式和指数形式。</p><ul><li>小数形式：如12.345，3.，-.123。</li><li>指数形式：由尾数部分、字母E或e和指数部分组成，格式为：±尾数E指数</li></ul><p><strong><em>TIPS:</em></strong></p><blockquote><p>(1) 以小数形式表示实数时，必须有小数点，并且小数点的前、后至少一边要有数字。<br>(2) 以指数形式表示实数时，字母E (或e)的前后必须有数字，并且指数部分只能是整数。如12.-E3、1.5E、E6都是不正确的实数。</p></blockquote><p><strong>3. 字符型常量</strong></p><ul><li>(1) 字符常量只能用单引号括起来，不能用双引号或其它括号。</li><li>(2) 字符常量只能是单个字符，不能是多个字符组成的字符串。</li><li>(3) 字符可以是ASCII字符集中的任意字符。按ASCII码的大小，不同的字符之间存在着次序，以字符的ASCII码值按升序连续排列。</li><li>(4) 对于控制符（如回车、换行等）与不可见字符，在C语言中通过转义字符来表示。</li></ul><p><strong><em>常见转义字符:</em></strong></p><table><thead><tr><th>转义字符</th><th>转义功能</th><th>ASCII码值</th></tr></thead><tbody><tr><td>\0</td><td>空字符</td><td>0</td></tr><tr><td>\a</td><td>响铃</td><td>7</td></tr><tr><td>\b</td><td>退格（Backspace）</td><td>8</td></tr><tr><td>\t</td><td>水平制表符（横向跳格）</td><td>9</td></tr><tr><td>\n</td><td>回车换行（Enter）</td><td>10</td></tr><tr><td>\v</td><td>竖向跳格</td><td>11</td></tr><tr><td>\f</td><td>换页</td><td>12</td></tr><tr><td>\r</td><td>回车</td><td>13</td></tr><tr><td>&quot;</td><td>双引号（”）</td><td>34</td></tr><tr><td>&#39;</td><td>单引号（’）</td><td>39</td></tr><tr><td>?</td><td>问号（?）</td><td>63</td></tr><tr><td>\</td><td>反斜线字符（\）</td><td>92</td></tr><tr><td>\ddd</td><td>1~3位八进制所代表的字符</td><td></td></tr><tr><td>\xhh</td><td>1~2位十六进制所代表的字符</td><td></td></tr></tbody></table><blockquote><p>转义字符的使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> b,c,d,e;</span><br><span class="line">    b='\43';</span><br><span class="line">    c=<span class="string">'\103'</span>;</span><br><span class="line">    d=<span class="string">'\x2a'</span>;</span><br><span class="line">    e=<span class="string">'\x41'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b=%c,c=%c,d=%c,e=%c\n"</span>,b,c,d,e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\"good\0morning!\b\"!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\123456"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>b=#,c=C,d=*,e=A<br>“good morning”!<br>S456</p><p><strong>4. 字符串常量</strong></p><p>字符串常量是由一对双引号””括起来的零个或多个字符序列，如：”HelloWorld”</p><p>字符串中可以使用空格字符、转义字符和其他字符，也可以使用汉字等文字符号</p><p>字符串中还可以使用空字符，如：”” 表示空串，即不包含任何字符</p><p>注意：</p><ul><li>系统自动在每个字符串的尾部加上’\0’作为字符串的结束标志<ul><li>n个字符组成的字符串，在内存中要占用n+1个字节空间</li><li>可以使用sizeof运算符来计算字符串占用的内存空间大小</li></ul></li><li>字符串的长度等于该字符串中所包含的有效字符的个数<ul><li>在字符串中如遇到’\0’则认为该字符串结束</li><li>如果字符串中有转义字符，则一个转义字符作为一个字符</li><li>可以使用strlen()函数计算字符串的长度</li></ul></li><li>字符常量和字符串常量在内存中的存储情况是不同的<ul><li>如’6’在内存中占1个字节，存储的是其ASCII码</li><li>“6”在内存中占2个字节，一个字节存储’6’，一个字节存储’\0’</li></ul></li></ul><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p>在C语言中，可以用一个标识符来表示一个常量，称之为符号常量</p><p>符号常量在使用之前必须先定义，其一般形式为：</p><p><strong>#define 标识符 常量值</strong></p><p>一个#define命令只能定义一个符号常量，若要定义多个符号常量，需使用多个#define命令</p><blockquote><p>例：某程序需要使用一个代表常数3.145的符号常量名xp，则以下定义中正确的是          。<br>A．#define xp 3.145;<br>B．#define xp(3.145)<br>C．#define xp=3.145<br>D．#define xp 3.145</p></blockquote><p>答案：D</p><blockquote><p>例：已知某程序如下：<br>#define P 2.5<br>void main( )<br>{<br>    printf(“%f”, P);<br>}<br>则main函数中标识符P代表的操作数是<strong>____</strong>。</p></blockquote><p>答案：2.5</p><blockquote><p>例：利用符号常量计算价格</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRICE 20</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num,total;</span><br><span class="line">    num=<span class="number">10</span>;</span><br><span class="line">    total=num* PRICE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"总价格为：%d\n"</span>,total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>总价格为：200</p><p><strong>符号常量的使用，可以为编写程序提供很多好处：</strong></p><ul><li>增加程序的可读性</li><li>提高程序的可维护性</li><li>简化程序代码</li><li>方便数组的定义</li></ul><h2 id="C语言的变量"><a href="#C语言的变量" class="headerlink" title="C语言的变量"></a>C语言的变量</h2><p>在程序的运行过程中，其值可以被改变的量称为变量</p><p>变量用于从外部接收数据、保存一些不断变化的值、保存中间结果及最终结果，而这些都无法用常量来实现</p><h3 id="变量的定义与使用"><a href="#变量的定义与使用" class="headerlink" title="变量的定义与使用"></a>变量的定义与使用</h3><p><strong>1. 变量的定义</strong></p><p><code>[存储类型] 类型说明符 变量名；</code></p><ul><li>定义四个静态的整型变量a,b,c,d：<code>static int a,b,c,d;</code></li><li>定义两个字符型变量ch1,ch2：<code>char ch1,ch2;</code></li><li>定义一个单精度浮点数变量f：<code>float f;</code></li></ul><p><strong><em>TIPS:</em></strong></p><ol><li>类型说明符必须是C语言中的有效数据类型，如int、float、double、char等，用于指定变量的类型，该类型决定了编译时分配给变量的内存单元的多少</li><li>变量名表可以由一个或多个变量名组成，各变量名之间用“，”分隔。变量名必须是合法的C语言标识符，变量名一般使用小写字母</li><li>变量的定义必须放在变量的使用之前，一般在函数体的开头部分进行定义</li></ol><p><strong>2. 变量的初始化</strong></p><p>C语言允许在定义变量的同时对变量赋值，这个过程称为变量的初始化</p><ul><li>定义一个整型变量x并赋初值为2：<code>int x=2;</code></li><li>定义两个整型变量s和t，分别赋初值为1：<code>int s=1,t=1;</code></li><li>定义一个单精度型变量f并赋初值为3.68：<code>float f =3.68;</code></li><li>定义一个字符型变量ch并赋初值为字符x：<code>char ch=&#39;x&#39;;</code></li></ul><p><strong><em>TIPS:</em></strong></p><ul><li>对一个变量赋初值之后，该值被存储在分配给该变量的内存空间中</li><li>不允许对多个未定义的同类型变量连续初始化</li><li>初始化时，“=”右边表达式的数据类型和“=”左边的变量的类型如果不一致，系统会进行自动赋值转换</li><li>没有进行初始化的变量，其值是由定义时所使用的存储类型决定的</li></ul><ol start="3"><li>变量的使用</li></ol><p>变量应该先赋值，后引用</p><blockquote><p>例：变量使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="string">'A'</span>;</span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    b=a+ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d,%c\n"</span>,a,b,c,ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>若程序运行时输入：<br>10↙<br>则程序的运行结果如下：<br>10,75,10,A</p><h3 id="整形变量"><a href="#整形变量" class="headerlink" title="整形变量"></a>整形变量</h3><p>Visual C++ 2010环境下，各种整型的关键字及占用内存字节数和取值范围如下表：</p><table><thead><tr><th>关键字</th><th>类型</th><th>占用字节数</th><th>取值范围</th></tr></thead><tbody><tr><td>short int</td><td>短整型</td><td>2</td><td>-32768~32767</td></tr><tr><td>int</td><td>整型</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>long int</td><td>长整型</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>unsigned short</td><td>无符号短整型</td><td>2</td><td>0~65535</td></tr><tr><td>unsigned int</td><td>无符号整型</td><td>4</td><td>0~4294964295</td></tr><tr><td>unsigned long</td><td>无符号长整型</td><td>4</td><td>0~4294964295</td></tr></tbody></table><p><strong><em>TIPS:</em></strong></p><ul><li>各种无符号整数所占的字节数与相应的有符号整数相同。但由于省去了符号位，故不能表示负数。</li><li>有符号整数以二进制补码形式存储。最左边第1位表示符号，该位为0，表示正数，该位为1，表示负数。</li><li>无符号整数以二进制原码形式存储。</li></ul><blockquote><p>例：不同类型整型变量的定义与使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> e;</span><br><span class="line">    a=<span class="number">5</span>;b=<span class="number">6</span>;e=<span class="number">10</span>;</span><br><span class="line">    c=a+e;</span><br><span class="line">    d=b+e;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%d,d=%d\n"</span>,c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>c=15,d=16</p><blockquote><p>例：短整型变量的溢出</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short <span class="keyword">int</span> a, b;</span><br><span class="line">    a = <span class="number">32767</span>;</span><br><span class="line">    b = a + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d, b=%d\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>a=32767,b=-32768</p><h3 id="实型变量"><a href="#实型变量" class="headerlink" title="实型变量"></a>实型变量</h3><p>实型的关键字及占用内存字节数和取值范围如表所示：</p><table><thead><tr><th>关键字</th><th>类型</th><th>占用字节数</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>单精度型</td><td>4</td><td>3.4E-38~3.4E+38</td></tr><tr><td>double</td><td>双精度型</td><td>8</td><td>1.7E-308~1.7E+308</td></tr></tbody></table><ul><li>单精度型数据能保留7位有效数字</li><li>双精度型数据能保留16位有效数字</li></ul><blockquote><p>例：实型变量的使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a=<span class="number">1234.56789</span>;</span><br><span class="line">    <span class="keyword">double</span> b=<span class="number">1234.567895678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%f,b=%f\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>a=1234.567871,b=1234.567896</p><h3 id="字符型变量"><a href="#字符型变量" class="headerlink" title="字符型变量"></a>字符型变量</h3><ul><li>字符型变量的值是字符常量，即用单引号引起来的单个字符</li><li>字符型变量的类型说明符是char，其类型说明的格式和命名规则与整型变量相同</li></ul><p><strong><em>TIPS:</em></strong></p><blockquote><p>由于字符常量在内存中占用一个字节，用于存储它的ASCII码值<br>所以C语言中的字符具有数值特征，可以像整数一样参加运算<br>允许对整型变量赋以字符值，也允许对字符变量赋以整型值。</p></blockquote><p>举个例子：</p><blockquote><p>例：字符变量的使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c1,c2;</span><br><span class="line">    c1=<span class="string">'A'</span>;</span><br><span class="line">    c2=<span class="number">65</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c,%c\n"</span>,c1,c2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,c1,c2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>A,A<br>65,65</p><blockquote><p>例：字符变量的使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c1,c2;</span><br><span class="line">    c1=<span class="string">'A'</span>;</span><br><span class="line">    c2=<span class="string">'B'</span>;</span><br><span class="line">    c1=c1+<span class="number">32</span>;</span><br><span class="line">    c2=c2+<span class="number">32</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c,%c\n"</span>,c1,c2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,c1,c2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>a,b<br>97,98</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常在学习程序设计语言的初期，要从基本要素入手，逐步掌握语言的各种语法规则&lt;/p&gt;
&lt;p&gt;就好比造一座大厦，基础没有打好基于往上盖，其后果可想而知&lt;/p&gt;
&lt;p&gt;所以要想熟练的使用C语言进行程序设计是一个循序渐进的过程&lt;/p&gt;
&lt;p&gt;这篇文章开始我们会写一些C语言代码，循序渐进的掌握C语言的语法规则&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.gengruiblog.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言程序设计的特点及运行方式</title>
    <link href="https://www.gengruiblog.cn/article/20210922.html"/>
    <id>https://www.gengruiblog.cn/article/20210922.html</id>
    <published>2021-09-21T16:00:00.000Z</published>
    <updated>2021-09-17T00:46:35.407Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章有讲到C语言是一门结构化语言，还讲了我们写代码需要先用文字描述算法、再用流程图、之后伪代码、最后再写代码</p><p>这篇文章C语言的发展历史、特点、语法，以及如何将代码一步步运行出结果</p><a id="more"></a><h2 id="C语言的发展历史"><a href="#C语言的发展历史" class="headerlink" title="C语言的发展历史"></a>C语言的发展历史</h2><ul><li>1963年英国剑桥大学推出了CPL（Combined Programming Language）语言。 </li><li>1967年剑桥大学的Martin Richards对CPL语言进行了简化，推出了BCPL（Basic Combined Programming Language）语言。 </li><li>1970年美国贝尔实验室的Ken Thompson对BCPL语言又做了进一步简化，设计出了更接近硬件的B语言。</li><li>1972年工作于美国贝尔实验室的Dennis Ritchie在B语言的基础上设计出C语言。  </li><li>1973年，Dennis Ritchie和Ken Thompson对UNIX操作系统进行了重写，其中90%以上的代码采用的是C语言，很大程度上提高了UNIX操作系统的可移植性和可读性。 </li><li>1983年，美国国家标准协会（American National Standards Institute，简称ANSI）制定了一套C语言标准，称为ANSI C。 </li><li>目前使用的如Microsoft C、Turbo C等版本均以ANSI C为标准，同时各自分别进行了一些扩充。本书使用的主要是Turbo C编译系统。</li></ul><h2 id="C语言的特点"><a href="#C语言的特点" class="headerlink" title="C语言的特点"></a>C语言的特点</h2><p><strong>优点：</strong></p><ol><li>C语言语句简洁紧凑，使用方便灵活</li><li>运算符丰富，表达能力强</li><li>C语言程序可移植性好</li><li>生成的目标代码质量高，运行效率高</li><li>语言处理能力强</li><li>C语言是一种结构化语言</li></ol><p><strong>缺点：</strong></p><p>C语言对语法检查不严格，许多时候需要程序员自己保证程序的正确，而这对初学者是很难做到的。</p><p>例如，数据类型检查不严格，表达式运算会出现二义性；对数组下标越界不检查，导致程序出错。</p><p>除此之外，由于C语言运算符较多，初学者很难掌握其运算的优先级与结合性。 </p><h2 id="C语言的语法"><a href="#C语言的语法" class="headerlink" title="C语言的语法"></a>C语言的语法</h2><h3 id="C语言中的约定"><a href="#C语言中的约定" class="headerlink" title="C语言中的约定"></a>C语言中的约定</h3><ol><li>标识符</li></ol><ul><li>由字母、数字和下划线组成，其中第一个字符必须是字母或下划线<ul><li>例如，_00、print、FOR均是合法的标识符，而&amp;a、-123、a b均是不合法的标识符。</li></ul></li><li>英文字母的大小写是有区别的</li><li>命名最好做到“见名知义”，增加程序的可读性</li><li>标识符的有效长度为1~255个字符</li></ul><ol start="2"><li>关键字</li></ol><table><thead><tr><th>类别</th><th>关键字</th></tr></thead><tbody><tr><td>数据类型关键字（12个）</td><td>char，double，enum，float，int，long，short，signed，struct，union，unsigned，void</td></tr><tr><td>控制语句关键字（12个）</td><td>break，continue，case，do，default，else，for，goto，if，return，switch，while</td></tr><tr><td>存储类型关键字（4个）</td><td>auto，extern，register，static</td></tr><tr><td>其它关键字（4个）</td><td>const，sizeof，typedef，volatile</td></tr></tbody></table><ol start="3"><li>用户自定义标识符:</li></ol><p>程序中定义的变量名、数据类型名、函数名和符号常量名</p><ol start="4"><li>预定义标识符</li></ol><p>头文件和库函数中定义的一些标识符（例如scanf、printf等）</p><ol start="5"><li>分隔符：</li></ol><ul><li>逗号：分隔变量名</li><li>空格：分隔各单词</li></ul><h3 id="C语言的语法成分"><a href="#C语言的语法成分" class="headerlink" title="C语言的语法成分"></a>C语言的语法成分</h3><ol><li>常量</li></ol><p>常量是有数据类型的，例如，整型常量2、实型常量2.0、字符型常量’2’ 、字符串常量”C Programming.”等。</p><ol start="2"><li>变量</li></ol><p>变量定义的一般形式是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 变量名;</span><br></pre></td></tr></table></figure><p>例如，例1.1中的 <code>int a,b,c;</code> 定义了三个整型变量。</p><ol start="3"><li>运算符</li></ol><ul><li>算术运算符：+（加）、-（减）、*（乘）、/（除）、%（求余）；</li><li>关系运算符：&gt;（大于）、&gt;=（大于等于）、==（等于）、&lt;（小于）、&lt;=（小于等于）等等。</li></ul><p>参与运算时只要求有一个数据对象的称为单目运算符，有两个数据对象的称为双目运算符，有三个数据对象的称为三目运算符。</p><ol start="4"><li>表达式</li></ol><p>运算符有优先级，例如，表达式 <code>b*b-4*a*c&gt;0</code> 中，由于算术运算优先于关系运算，所以先计算 <code>b*b-4*a*c</code> ，再做关系比较运算 <code>&gt;</code> 。</p><ol start="5"><li>语句</li></ol><p>在C语言中，语句是程序最基本的执行单位，以分号结尾。</p><ol start="6"><li>函数定义与调用</li></ol><p>函数十完成特定功能的小模块，是C语言中唯一的种子程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>    <span class="comment">/* 求最大值的函数*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;              <span class="comment">/* 定义临时变量z */</span></span><br><span class="line"><span class="keyword">if</span>(x&gt;y)</span><br><span class="line">z=x;            <span class="comment">/* x&gt;y时，z的值等于x */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">z=y;            <span class="comment">/* 否则，z的值等于y */</span></span><br><span class="line"><span class="keyword">return</span> z;           <span class="comment">/* 结束函数，返回z */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>输入与输出</li></ol><p>C语言没有提供用于数据输入及输出的语句，所有的输入与输出都是通过系统提供的有关函数（如scanf()和printf()函数）来实现的。</p><h2 id="C程序的编辑、编译、链接、运行"><a href="#C程序的编辑、编译、链接、运行" class="headerlink" title="C程序的编辑、编译、链接、运行"></a>C程序的编辑、编译、链接、运行</h2><p><img src="https://gengrui01.github.io/picture/c-features-operation/1.png" alt=""></p><ol><li>编辑：将编写的C语言代码以文件的形式存储在计算机中，其拓展名为 <strong><em>.c</em></strong></li><li>编译：通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成二进制目标程序文件，其拓展名为 <strong><em>.obj</em></strong></li></ol><ul><li>编译过程中的错误多为词法和语法错误，如果原文件存在这些错误，则编译系统会给出错误提示信息，应根据错误提示信息查找错误并改正源程序，再次重新编译，直到没有错误</li></ul><ol start="3"><li>链接：将目标程序与系统提供的库函数或是其他目标程序进行链接，得到最终的二进制可执行文件，其拓展名为 <strong><em>.exe</em></strong></li><li>运行：双击 <strong><em>.exe</em></strong> 可执行文件运行后结果会显示在屏幕上</li></ol><ul><li>可执行文件运行后要验证程序的运行结果，如果发现运行结果与设计目的不相符（通常称为逻辑错误），说明程序在设计思路或算法上出现了问题，需要重新检查源程序找出问题并且修改，然后重新编译、链接、运行，直到得到正确结果</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章有讲到C语言是一门结构化语言，还讲了我们写代码需要先用文字描述算法、再用流程图、之后伪代码、最后再写代码&lt;/p&gt;
&lt;p&gt;这篇文章C语言的发展历史、特点、语法，以及如何将代码一步步运行出结果&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.gengruiblog.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>程序与程序设计语言</title>
    <link href="https://www.gengruiblog.cn/article/20210921.html"/>
    <id>https://www.gengruiblog.cn/article/20210921.html</id>
    <published>2021-09-20T16:00:00.000Z</published>
    <updated>2021-09-16T05:13:33.307Z</updated>
    
    <content type="html"><![CDATA[<p>程序（program）是为<strong>实现特定目标</strong>或<strong>解决特定问题</strong>而用计算机语言（程序设计语言）编写的一系列语句和指令，计算机能严格按照这些指令去做。</p><p>程序具有以下特点：</p><ol><li>完成某一特定的任务；</li><li>使用某种程序设计语言描述如何完成该任务；  </li><li>存储在计算机中，并且被运行后才能起作用。 </li></ol><a id="more"></a><h2 id="程序设计语言的发展"><a href="#程序设计语言的发展" class="headerlink" title="程序设计语言的发展"></a>程序设计语言的发展</h2><p>程序设计语言经过多年的发展，其技术和方法日臻成熟。其发展经历了几个阶段：</p><h3 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h3><ul><li>采用二进制指令代码</li><li>特点：难学、难写、难记、难修改  </li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul><li>采用助记符代替机器指令 </li><li>特点：依赖于机器硬件，可移植性不好 </li></ul><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ul><li>运算符和运算表达式与人们日常所用的数学式子差不多，很容易理解</li><li>高级语言又经历了不同的发展阶段：<ol><li>非结构化的语言 <ul><li>编程风格比较随意，没有编程规范可以遵循，程序中的流程可以随意跳转。 </li></ul></li><li>结构化的语言 <ul><li>结构化程序设计方法规定：程序由具有良好特性的基本结构（顺序结构、分支结构、循环结构）构成</li><li>程序中的流程不允许随意跳转，程序总是由上而下顺序执行各个基本结构。 </li></ul></li><li>面向对象的语言<ul><li>对象是由数据以及对数据所进行的操作的封装体</li><li>采用面向对象的程序设计方法开发应用程序变得更容易，耗时更少，效率更高。  </li></ul></li></ol></li></ul><h2 id="程序设计语言的功能"><a href="#程序设计语言的功能" class="headerlink" title="程序设计语言的功能"></a>程序设计语言的功能</h2><h3 id="数据表达"><a href="#数据表达" class="headerlink" title="数据表达"></a>数据表达</h3><p>对程序中用到的数据进行声明。</p><p>数据是计算机处理的对象，在解决实际问题时，通常需要申明各种类型的数据，数据类型就是对某些具有相同性质的数据集的总称</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>对不同类型的数据进行处理。</p><p>按照结构化程序设计的观点，任何程序的基本结构都可以通过三种基本的控制结构进行组合来实现，分别是顺序结构、分支结构、循环结构</p><p>这三种结构的共同特点是：</p><ol><li>只有单一的入口和单一的出口；</li><li>结构中的每个部分都有被执行的可能；</li><li>结构内不应出现永不终止的死循环。</li></ol><h2 id="程序的算法表示"><a href="#程序的算法表示" class="headerlink" title="程序的算法表示"></a>程序的算法表示</h2><h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p>“软件的主体是程序，程序的核心是算法”。瑞士计算机科学家尼·沃思（N·Wirth）有一句名言：“计算机科学就是研究算法的学问”。     </p><p>通俗地讲，算法就是解决问题的方法与步骤。</p><blockquote><p>例如要交换两个变量a和b的值，按照下面的步骤就可以完成交换：</p></blockquote><ol><li>输入变量a和b的值；</li><li>将变量a的值赋给变量t；</li><li>将变量b的值赋给变量a；</li><li>将变量t的值赋给变量b；</li><li>输出变量a与b的值。</li></ol><h3 id="算法的特征"><a href="#算法的特征" class="headerlink" title="算法的特征"></a>算法的特征</h3><ol><li>确定性：</li></ol><p>算法的每条指令必须有明确的含义，不能有二义性</p><p>对于相同的输入必须得出相同的执行结果</p><ol start="2"><li>有穷性：</li></ol><p>一个算法应包含有限个操作步骤</p><p>也就是说，在执行若干个操作步骤之后，算法将结束</p><p>而且每一步都在有限的时间内完成</p><ol start="3"><li>可行性：</li></ol><p>算法中指定的操作都可以通过已经实现的基本运算执行有限次后实现</p><ol start="4"><li><p>有零个或多个输入</p></li><li><p>有一个或多个输出</p></li></ol><p>算法的目的是为了求“解”，“解”只有通过输出才能得到</p><h3 id="算法的描述"><a href="#算法的描述" class="headerlink" title="算法的描述"></a>算法的描述</h3><p><strong>1. 用文字描述算法</strong></p><blockquote><p>例：有10个两位的正整数，找出其中最大的数，写出其算法。</p></blockquote><ol><li>输入第一个数，放入max中；</li><li>用i统计比较的次数，其初值置为1；</li><li>若i≤9，转第4步，否则转第8步；</li><li>再输入一个数，放在x中；</li><li>比较x和max中的数，若x&gt;max，则将x的值赋给max；否则max的值不变；</li><li>i增加1；</li><li>返回到第3步；</li><li>输出max中的数，此时max中的数即为10个数中最大的数。</li></ol><blockquote><p>例：写出求两个自然数的最大公约数的算法</p></blockquote><p>采用古希腊数学家欧几里得提出的“欧几里得算法”描述如下：</p><ol><li>输入两个自然数a、b；</li><li>求a除以b的余数r；</li><li>使a = b，即用b代替a；</li><li>使b = r，即用r代替b；</li><li>若r≠0，则重复执行步骤2、3、4，否则转第6步；</li><li>输出a，a即为a和b的最大公约数。</li></ol><p>用文字描述算法的缺点：</p><p>很难“系统”并“精确”地表达算法，且有时叙述冗长，别人不容易理解。</p><p><strong>2. 用流程图描述算法</strong></p><p>常用到的流程图框：</p><p><img src="https://gengrui01.github.io/picture/c-program-language/1.png" alt=""></p><p>三种基本的控制结构图示例：</p><p><img src="https://gengrui01.github.io/picture/c-program-language/2.png" alt=""></p><blockquote><p>例：有10个两位的正整数，找出其中最大的数，画出其流程图。</p></blockquote><p><img src="https://gengrui01.github.io/picture/c-program-language/3.png" alt=""></p><blockquote><p>例：画出求两个自然数的最大公约数的流程图</p></blockquote><p><img src="https://gengrui01.github.io/picture/c-program-language/4.png" alt=""></p><p>画流程图网站推荐：<a href="https://www.processon.com/i/5aff91c9e4b0ad4428891336" target="_blank" rel="noopener">ProcessOn免费在线作图</a></p><p><strong>3. 伪代码表示</strong></p><p>伪代码是一种近似高级语言但又不受语法约束的语言描述方式，它不能在计算机中运行，但可以用来描述算法。</p><blockquote><p>例：有10个两位的正整数，找出其中最大的数，用伪代码写出其算法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    输入第1个数赋给max；</span><br><span class="line">    for(i&#x3D;1;i&lt;&#x3D;9;i++)</span><br><span class="line">    &#123;输入第i+1个数赋给x；</span><br><span class="line">        if(x&gt;max)</span><br><span class="line">            max&#x3D;x;</span><br><span class="line">    &#125;</span><br><span class="line">    输出max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 程序设计语言表示</strong></p><blockquote><p>例：写代码交换两个变量a和b的值</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,t;<span class="comment">/* 定义所用的变量 */</span></span><br><span class="line">    a=<span class="number">3</span>;b=<span class="number">5</span>;<span class="comment">/* 给变量赋值 */</span></span><br><span class="line">    t=a; <span class="comment">/* 变量a的值存入变量t中 */</span></span><br><span class="line">    a=b; <span class="comment">/* 变量b的值赋予变量a */</span></span><br><span class="line">    b=t; <span class="comment">/* 变量t的值赋予变量b */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,a,b);<span class="comment">/* 输出交换后的变量的值 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序（program）是为&lt;strong&gt;实现特定目标&lt;/strong&gt;或&lt;strong&gt;解决特定问题&lt;/strong&gt;而用计算机语言（程序设计语言）编写的一系列语句和指令，计算机能严格按照这些指令去做。&lt;/p&gt;
&lt;p&gt;程序具有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成某一特定的任务；&lt;/li&gt;
&lt;li&gt;使用某种程序设计语言描述如何完成该任务；  &lt;/li&gt;
&lt;li&gt;存储在计算机中，并且被运行后才能起作用。 &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.gengruiblog.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Visual Studio 2019 安装 并 运行第一个C语言项目文件</title>
    <link href="https://www.gengruiblog.cn/article/20210920.html"/>
    <id>https://www.gengruiblog.cn/article/20210920.html</id>
    <published>2021-09-19T16:00:00.000Z</published>
    <updated>2021-09-15T05:36:53.732Z</updated>
    
    <content type="html"><![CDATA[<p>本教程包含：</p><ol><li>介绍如何在官网下载并安装 Visual Studio 2019</li><li>创建并运行第一个C语言项目文件</li></ol><p>下面就是详细步骤：</p><a id="more"></a><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><h3 id="方式1-百度网盘链接"><a href="#方式1-百度网盘链接" class="headerlink" title="方式1 百度网盘链接"></a>方式1 百度网盘链接</h3><p>链接：<a href="https://pan.baidu.com/s/1Zpa_dx3t7qdNX2WyID3BTA" target="_blank" rel="noopener">单击此处百度网盘下载Visual Studio 2019安装包</a></p><p>提取码：sfid</p><h3 id="方式2-官网下载"><a href="#方式2-官网下载" class="headerlink" title="方式2 官网下载"></a>方式2 官网下载</h3><p><a href="https://visualstudio.microsoft.com/zh-hans/vs/" target="_blank" rel="noopener">Visual Studio IDE: 面向开发人员的一体式编程工具</a></p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/1.png" alt=""></p><h2 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h2><ol><li>右键 -&gt; 以管理员身份运行安装包</li></ol><p>如果收到用户帐户控制通知，请选择“是”</p><p>会出现如下界面等待进度条满</p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/2.png" alt=""></p><ol start="2"><li>要求确认 Microsoft 许可条款和 Microsoft 隐私声明，点击“继续”即可</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/3.png" alt=""></p><ol start="3"><li>自动下载安装，等待两行进度条满</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/4.png" alt=""></p><ol start="4"><li>选择工作负载</li></ol><p>安装完成后进入下图界面选择工作负载，不同应用不同语言勾选不同的工作负荷</p><p>例如C语言/C++语言开发需要向下拉 在 <strong>桌面应用和移动应用</strong> 下 找到 <strong>使用C++的桌面开发</strong> ，勾选</p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/5.png" alt=""></p><ol start="5"><li>点击“安装位置” 可以更换安装路径，也可以不做调整使用默认位置点击 “安装”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/6.png" alt=""></p><ol start="6"><li>接下来，会出现多个显示 Visual Studio 安装进度的状态屏幕，等待进度条满即可</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/7.png" alt=""></p><ol start="7"><li>重启电脑</li></ol><p>按转换完成后会提示需要重启，按要求点击“重启”即可</p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/8.png" alt=""></p><ol start="8"><li>在开始菜单栏找到 <strong>Visual Studio 2019</strong> 右键 -&gt; 更多 -&gt; 打开文件所在位置</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/9.png" alt=""></p><ol start="9"><li>找到 <strong>Visual Studio 2019</strong> 的快捷方式 右键 -&gt; 发送到 -&gt; 桌面快捷方式</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/10.png" alt=""></p><h2 id="程序设置"><a href="#程序设置" class="headerlink" title="程序设置"></a>程序设置</h2><ol><li>双击桌面的快捷方式打开，第一次会提示注册登录，也可以直接选择“下次再说”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/11.png" alt=""></p><ol start="2"><li>根据个人喜好选择喜欢的主题颜色，之后点击“启动Visual Studio”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/12.png" alt=""></p><ol start="3"><li>第一次启动需要准备时间，耐心等待</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/13.png" alt=""></p><h2 id="Visual-Studio-创建的第一个C语言项目"><a href="#Visual-Studio-创建的第一个C语言项目" class="headerlink" title="Visual Studio 创建的第一个C语言项目"></a>Visual Studio 创建的第一个C语言项目</h2><ol><li>设置完成后进来如下界面，点击“创建新项目”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/14.png" alt=""></p><ol start="2"><li>进到下图所示界面，选择“空项目”，点击“下一步”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/15.png" alt=""></p><ol start="3"><li>使用默认位置及名称点击“创建”创建项目</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/16.png" alt=""></p><h2 id="Visual-Studio-运行的第一个项目文件"><a href="#Visual-Studio-运行的第一个项目文件" class="headerlink" title="Visual Studio 运行的第一个项目文件"></a>Visual Studio 运行的第一个项目文件</h2><ol><li>创建好的项目界面如下图所示，找到“解决方案资源管理器”下的“源文件”，右键 -&gt; 添加 -&gt; 新建项</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/17.png" alt=""></p><ol start="2"><li>选择C++文件，修改文件名称及后缀名（注意C语言文件的后缀名是.c），点击“添加”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/18.png" alt=""></p><ol start="3"><li>在文件中写入如下代码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击 调试 -&gt; 开始调试</p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/19.png" alt=""></p><p>弹出如下框并输出 “HelloWorld!” 表示我们已经使用 Visual Studio 运行成功了第一个C语言项目</p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/20.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本教程包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;介绍如何在官网下载并安装 Visual Studio 2019&lt;/li&gt;
&lt;li&gt;创建并运行第一个C语言项目文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面就是详细步骤：&lt;/p&gt;
    
    </summary>
    
    
      <category term="安装与配置" scheme="https://www.gengruiblog.cn/categories/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="https://www.gengruiblog.cn/article/20210909.html"/>
    <id>https://www.gengruiblog.cn/article/20210909.html</id>
    <published>2021-09-08T16:00:00.000Z</published>
    <updated>2021-11-08T01:18:05.501Z</updated>
    
    <content type="html"><![CDATA[<p>为了保证程序有效地执行，需要对发生的异常进行相应的处理。</p><p>在Java中，如果某个方法有异常有两种处理方式：</p><ul><li>既可以在当前方法中进行捕捉，然后处理该异常</li><li>也可以将异常向上抛出，由调用者来处理。</li></ul><a id="more"></a><h2 id="在方法中抛出异常"><a href="#在方法中抛出异常" class="headerlink" title="在方法中抛出异常"></a>在方法中抛出异常</h2><p>若某个方法可能会发生异常，但不想在当前方法中处理这个异常</p><p>可以使用throws、throw关键字在方法中抛出异常</p><h3 id="使用throws关键字抛出异常"><a href="#使用throws关键字抛出异常" class="headerlink" title="使用throws关键字抛出异常"></a>使用throws关键字抛出异常</h3><p>throws关键字通常被应用在声明方法中，用来指定方法可能抛出的异常，多个异常可使用逗号分割</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shoot</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> NegativeArraySizeException</span>&#123;</span><br><span class="line"><span class="comment">//定义方法并抛出异常</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[-<span class="number">3</span>];<span class="comment">//创建数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">pop();</span><br><span class="line">&#125;<span class="keyword">catch</span> (NegativeArraySizeException e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(<span class="string">"pop()方法抛出的异常"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用throws关键字将异常抛给上一级后，如果不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的代码</p><h3 id="使用throw关键字抛出异常"><a href="#使用throw关键字抛出异常" class="headerlink" title="使用throw关键字抛出异常"></a>使用throw关键字抛出异常</h3><p>throw关键字通常用于方法体中，并且抛出一个异常对象</p><p>程序在执行到throw语句时立即终止，它后面的语句都不执行</p><p>通过throw抛出异常后，如果想在上一级代码中来捕获并处理异常</p><p>则需要在抛出异常的方法中使用throw关键字在方法的声明中指明要抛出的异常</p><p>如果要捕捉throw抛出的异常，则必须使用try-catch语句块</p><p>通过下面的示例来说明throw的使用：</p><ol><li>创建自定义异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;<span class="comment">//创建自定义异常，继承Exception</span></span><br><span class="line">String message;<span class="comment">//定义String类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String ErrorMessage)</span> </span>&#123;<span class="comment">//构造方法</span></span><br><span class="line">message = ErrorMessage;<span class="comment">//父类构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>抛出异常并捕捉异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Captor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">quotient</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y&lt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"除数不能为负数！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x/y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> result = quotient(<span class="number">3</span>,-<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(MyException e) &#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArithmeticException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"除数不能为0"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">"程序发生了其它异常"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h2><p>RuntimeException异常时程序运行过程中产生的异常。</p><p>Java类库的每个包中都定义了异常类，所有这些类都是Throwable类的子类。</p><p>Throwable类派生了两个子类，分别是Exception和Error类。</p><p>Java中提供了常见的RuntimeException异常，这些异常可以通过try-catch语句捕获，如下表所示：</p><table><thead><tr><th>种类</th><th>说明</th></tr></thead><tbody><tr><td>NullPointerException</td><td>空指针异常</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>数组下标越界异常</td></tr><tr><td>ArithmeticException</td><td>算术异常</td></tr><tr><td>ArrayStoreException</td><td>数组中包含不兼容的值抛出的异常</td></tr><tr><td>IllegalArgumentException</td><td>非法参数异常</td></tr><tr><td>SecurityException</td><td>安全性异常</td></tr><tr><td>NegativeArraySizeException</td><td>数组长度为负异常</td></tr></tbody></table><h2 id="异常的使用原则"><a href="#异常的使用原则" class="headerlink" title="异常的使用原则"></a>异常的使用原则</h2><p>Java异常强制用户去考虑程序的强健性和安全性</p><p>异常处理不应用来控制程序的正常流程，其主要作用是捕获程序在运行时发生的异常并进行相应处理</p><p>编写代码处理某个方法可能出现的异常时，可遵循以下几条原则：</p><ol><li>在当前方法声明中使用try-catch语句捕获异常</li><li>一个方法被覆盖时，覆盖它的方法必须抛出相同的异常或异常的子类</li><li>如果父类抛出多个异常，则覆盖方法必须抛出那些异常的一个子集，不能抛出新异常</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了保证程序有效地执行，需要对发生的异常进行相应的处理。&lt;/p&gt;
&lt;p&gt;在Java中，如果某个方法有异常有两种处理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;既可以在当前方法中进行捕捉，然后处理该异常&lt;/li&gt;
&lt;li&gt;也可以将异常向上抛出，由调用者来处理。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java程序异常</title>
    <link href="https://www.gengruiblog.cn/article/20210908.html"/>
    <id>https://www.gengruiblog.cn/article/20210908.html</id>
    <published>2021-09-07T16:00:00.000Z</published>
    <updated>2021-11-08T02:20:39.343Z</updated>
    
    <content type="html"><![CDATA[<p>在程序中，程序员没有预料到的各种情况、或者超出了程序员可控范围的环境因素</p><p>例如：用户的坏数据、打开一个不存在的文件、连接一个不存在的数据库等</p><p>在程序执行期间有可能会出现一些错误，这些错误会中断正在执行的程序正常的指令流</p><p>这些错误统称为异常</p><a id="more"></a><h2 id="处理程序异常错误"><a href="#处理程序异常错误" class="headerlink" title="处理程序异常错误"></a>处理程序异常错误</h2><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>异常产生后，如果不做任何处理，程序就会被终止，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thundering</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"lili"</span>;</span><br><span class="line">System.out.println(str+<span class="string">"年龄是:"</span>);</span><br><span class="line"><span class="keyword">int</span> age = Integer.parseInt(<span class="string">"20L"</span>);</span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述例子可以看出，报出了NumberFormatException异常</p><p>提示信息“lili年龄是：”已经输出，而变量age没有输出，所以是在 执行类型转换代码时出差错了</p><h3 id="捕捉异常"><a href="#捕捉异常" class="headerlink" title="捕捉异常"></a>捕捉异常</h3><p>Java语言的异常捕获结构由try、catch和finally三部分构成</p><ul><li>try语句块存放的是可能发生异常的Java语句</li><li>catch程序块在try语句块之后，用来激发捕获异常</li><li>finally语句块是异常处理结构的最后执行部分，无论try语句块如何退出，都将执行finally块</li></ul><p>语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//程序代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exceptiontype1 e)&#123;</span><br><span class="line">    <span class="comment">//对Exceptiontype1的处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exceptiontype2 e)&#123;</span><br><span class="line">    <span class="comment">//对Exceptiontype2的处理</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//程序块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上段代码主函数内容修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 主体代码</span></span><br><span class="line">    String str = <span class="string">"lily"</span>;</span><br><span class="line">    System.out.println(str+<span class="string">"年龄是:"</span>);</span><br><span class="line">    <span class="keyword">int</span> age = Integer.parseInt(<span class="string">"20L"</span>);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">    <span class="comment">// 捕捉到异常后会执行的语句</span></span><br><span class="line">    System.out.println(<span class="string">"catch-NumberFormatException"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 无论是否有异常都会执行的语句</span></span><br><span class="line">    System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，程序仍然输出最后的提示信息，没有因为异常而终止</p><p>说明当try语句块中的代码出现错误时，就会跳转到catch代码块中的执行，执行完后继续执行catch语句块后的代码。</p><h3 id="catch语句块"><a href="#catch语句块" class="headerlink" title="catch语句块"></a>catch语句块</h3><p>通常，异常处理常用以下3个函数来获取异常相关的信息：</p><ul><li>getMessage()函数：输出错误性质</li><li>toString()函数：给出异常的性质和类型</li><li>printStackTrace()函数：输出异常的类型、性质、战层次及出现在程序中的位置</li></ul><h3 id="finally语句块"><a href="#finally语句块" class="headerlink" title="finally语句块"></a>finally语句块</h3><p>完整的异常处理语句一定要包含finally语句，无论程序中有无异常发生，并且无论直接的try-catch是否顺利执行完毕，都会执行finally语句</p><p>在以下几种特殊情况下，finally语句不会执行：</p><ul><li>在finally语句块中发生异常</li><li>在前面的代码中使用了System.exit()退出程序</li><li>程序所在的线程死亡</li><li>关闭CPU</li></ul><h2 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h2><p>Java中提供了一些异常用来描述经常发生的错误</p><p>其中，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理的</p><p>常见异常类如下表所示：</p><table><thead><tr><th>异常类</th><th>说明</th></tr></thead><tbody><tr><td>ClassCastException</td><td>类型转换异常</td></tr><tr><td>ClassNotFoundException</td><td>未找到相应类异常</td></tr><tr><td>ArithmeticException</td><td>算术异常</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>数组下标越界异常</td></tr><tr><td>ArrayStoreException</td><td>数组中包含不兼容的值抛出的异常</td></tr><tr><td>SQLException</td><td>操作数据库异常类</td></tr><tr><td>NullPointerException</td><td>空指针异常</td></tr><tr><td>NoSuchFieldException</td><td>字段未找到异常</td></tr><tr><td>NoSuchMethodException</td><td>方法未找到抛出的异常</td></tr><tr><td>NumberFormatException</td><td>字符串转换为数字抛出的异常</td></tr><tr><td>NegativeArraySizeException</td><td>数组元素个数为负数抛出的异常</td></tr><tr><td>StringIndexOutOfBoundsException</td><td>字符串索引超出范围抛出的异常</td></tr><tr><td>IOException</td><td>输入输出异常</td></tr><tr><td>IllegalAccessException</td><td>不允许访问其类异常</td></tr><tr><td>InstantiationException</td><td>当应用程序试图使用Class类中的NewInstance()方法创建一个类的实例，而指定的类对象无法被实例化，抛出该异常</td></tr><tr><td>EOFException</td><td>文件已结束异常</td></tr><tr><td>FileNotFoundException</td><td>文件未找到异常</td></tr></tbody></table><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>使用Java内置的异常类可以描述在编程时出现的大部分异常情况</p><p>除此之外，用户只需继承Exception类即可自定义异常类</p><p>在程序中使用自定义异常类，大致分为以下几个步骤：</p><ol><li>创建自定义异常类</li><li>在方法中通过throw关键字抛出异常对象</li><li>如果在当前抛出异常的方法中处理异常，可以使用try-catvh语句块捕获并处理，否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作</li><li>在出现异常方法的调用者中捕获并处理异常</li></ol><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;<span class="comment">//创建自定义异常，继承Exception</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String ErrorMessage)</span> </span>&#123;<span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">super</span>(ErrorMessage);<span class="comment">//父类构造方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串ErrorMessage是要输出的错误信息，若想抛出用户自定义的异常对象，要使用throw关键字</p><p>在下列示例中创建了Tran类，该类中创建一个带有int型参数的方法avg()，该方法用来检查参数是否小于0或大于100</p><p>如果参数小于0或大于100，则通过throw关键字抛出一个MyException异常对象，并在main()方法中捕捉该异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tran</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义方法，抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">avg</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2)</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(number1&lt;<span class="number">0</span>||number2&lt;<span class="number">0</span>) &#123;<span class="comment">//判断方法中参数是否满足指定条件</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"不可以使用负数"</span>);<span class="comment">//错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(number1&gt;<span class="number">100</span>||number2&gt;<span class="number">100</span>) &#123;<span class="comment">//判断方法中参数是否满足指定条件</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"数值太大了"</span>);<span class="comment">//错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (number1+number2)/<span class="number">2</span>;<span class="comment">//将参数的平均值返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">//try代码块处理肯出现异常的代码</span></span><br><span class="line"><span class="keyword">int</span> result = avg(<span class="number">102</span>,<span class="number">89</span>);<span class="comment">//调用avg()方法</span></span><br><span class="line">System.out.println(result);<span class="comment">//将avg()方法的返回值输出</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(MyException e) &#123;</span><br><span class="line">System.out.println(e);<span class="comment">//输出异常信息</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在程序中，程序员没有预料到的各种情况、或者超出了程序员可控范围的环境因素&lt;/p&gt;
&lt;p&gt;例如：用户的坏数据、打开一个不存在的文件、连接一个不存在的数据库等&lt;/p&gt;
&lt;p&gt;在程序执行期间有可能会出现一些错误，这些错误会中断正在执行的程序正常的指令流&lt;/p&gt;
&lt;p&gt;这些错误统称为异常&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java使用POI操作Excel文件</title>
    <link href="https://www.gengruiblog.cn/article/20210906.html"/>
    <id>https://www.gengruiblog.cn/article/20210906.html</id>
    <published>2021-09-05T16:00:00.000Z</published>
    <updated>2021-11-01T10:39:52.706Z</updated>
    
    <content type="html"><![CDATA[<p>java操作excel的组件除了apache的poi，还有jexcelapi(jxl)，其中poi组件的获取地址为poi.apache.org。</p><a id="more"></a><h2 id="1-Jar包"><a href="#1-Jar包" class="headerlink" title="1. Jar包"></a>1. Jar包</h2><p>官网下载地址：</p><ul><li>POI组件Jar包： <a href="https://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-4.1.1-20191023.zip" target="_blank" rel="noopener">Apache Download Mirrors - POI</a></li><li>Apache常用包： <a href="http://commons.apache.org/proper/commons-math/download_math" target="_blank" rel="noopener">Math – Download Apache Commons Math</a></li></ul><h2 id="2-poi组件中常用的类"><a href="#2-poi组件中常用的类" class="headerlink" title="2. poi组件中常用的类"></a>2. poi组件中常用的类</h2><ul><li>HSSFWorkbook表示一个完整的excel表格</li><li>HSSFSheet表示excel中的一个工作薄</li><li>HSSFRow表示工作薄中的一行</li><li>HSSFCell表示一个单元格</li></ul><h2 id="3-Demo"><a href="#3-Demo" class="headerlink" title="3. Demo"></a>3. Demo</h2><p>下面是一个简单的写入的demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HSSFWorkbook workbook= <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">HSSFSheet sheet= workbook.createSheet(<span class="string">"test"</span>);</span><br><span class="line">HSSFRow row = sheet.createRow(<span class="number">1</span>);</span><br><span class="line">HSSFCell cell= row.createCell(<span class="number">2</span>);</span><br><span class="line">cell.setCellValue(<span class="string">"test"</span>);</span><br><span class="line">FileOutputStream os= <span class="keyword">null</span>;</span><br><span class="line">os = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:/firstExcel.xls"</span>);</span><br><span class="line">workbook.write(os);</span><br><span class="line">os.flush();</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure><p>下面是几个常用的api：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置列宽</span></span><br><span class="line">sheet.setColumnWidth(columnIndex, width);</span><br><span class="line"><span class="comment">//设置行高</span></span><br><span class="line">row.setHeight(height);</span><br><span class="line"><span class="comment">//合并单元格</span></span><br><span class="line">sheet.addMergedRegion(region);</span><br><span class="line"><span class="comment">//设置样式：</span></span><br><span class="line">HSSFFont font= workbook.createFont();</span><br><span class="line">font.setFontHeightInPoints(height);</span><br><span class="line">font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD);</span><br><span class="line">font.setFontName(<span class="string">"黑体"</span>);</span><br><span class="line">HSSFCellStyle style= workbook.createCellStyle();</span><br><span class="line">style.setFont(font);</span><br><span class="line"><span class="comment">//style可以设置对齐样式，边框，和格式化日期。</span></span><br><span class="line">cell.setCellStyle(style);</span><br></pre></td></tr></table></figure><p>总结一下：</p><ul><li>poi的使用比较简单，主要是写入和读取的时候计算好读取的位置</li><li>现在项目中已经封装了一个现成的类，几乎几行代码就可以把结果输出到一个excel中并提供下载</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java操作excel的组件除了apache的poi，还有jexcelapi(jxl)，其中poi组件的获取地址为poi.apache.org。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的ZIP压缩输入/输出流</title>
    <link href="https://www.gengruiblog.cn/article/20210905.html"/>
    <id>https://www.gengruiblog.cn/article/20210905.html</id>
    <published>2021-09-04T16:00:00.000Z</published>
    <updated>2021-10-31T23:20:42.710Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中通过使用java.util.zip包中的ZipOutputStream与ZipInputStream类来室性文件的压缩/解压缩操作。</p><ul><li>ZipEntry类产生的对象，是用来代表一个ZIP压缩文件内的进入点；</li><li>ZipInputStream类用来读取ZIP压缩格式的文件，所支持的包括已压缩及未压缩的进入点；</li><li>ZipOutputStream类用来写出ZIP压缩格式的文件，而且所支持的包括已压缩及未压缩的进入点。</li></ul><a id="more"></a><h2 id="1-压缩文件"><a href="#1-压缩文件" class="headerlink" title="1. 压缩文件"></a>1. 压缩文件</h2><p>利用ZipOutputStream类对象，可将文件压缩为.zip文件，构造方法如下：</p><p><code>ZipOutputStream(OutputStream out)</code></p><p>该类的常用方法如下：</p><p><img src="https://gengrui01.github.io/picture/java-io-zip/1.png" alt=""></p><p>通过以下示例来进行说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyZip</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zip</span><span class="params">(String zipFileName,File InputFile)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">ZipOutputStream out = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> FileOutputStream(zipFileName));</span><br><span class="line">zip(out,InputFile,<span class="string">""</span>);</span><br><span class="line">System.out.println(<span class="string">"压缩中...."</span>);</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">zip</span><span class="params">(ZipOutputStream out,File f,String base)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f.isDirectory()) &#123;</span><br><span class="line">File[] fl = f.listFiles();</span><br><span class="line">out.putNextEntry(<span class="keyword">new</span> ZipEntry(base+<span class="string">"/"</span>));</span><br><span class="line">base = base.length() == <span class="number">0</span>?<span class="string">""</span>:base+<span class="string">"/"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;fl.length;i++) &#123;</span><br><span class="line">zip(out,fl[i],base+fl[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">out.putNextEntry(<span class="keyword">new</span> ZipEntry(base));</span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">System.out.println(base);</span><br><span class="line"><span class="keyword">while</span>((b =in.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">out.write(b);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String agrs[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyZip book = <span class="keyword">new</span> MyZip();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">book.zip(<span class="string">"F:/image.zip"</span>, <span class="keyword">new</span> File(<span class="string">"F:/images"</span>));</span><br><span class="line">System.out.println(<span class="string">"压缩完成"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在F盘中能够找到 <code>image.zip</code> 压缩包</p><h2 id="2-解压ZIP文件"><a href="#2-解压ZIP文件" class="headerlink" title="2. 解压ZIP文件"></a>2. 解压ZIP文件</h2><p>ZipInputStream类可以读取ZIP压缩格式的文件，包括已压缩和未压缩的条目，常用构造方法如下：</p><p><code>ZipInputStream(InputStream in)</code></p><p>常用方法如下：</p><p><img src="https://gengrui01.github.io/picture/java-io-zip/2.png" alt=""></p><p>通过以下示例来说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decompressing</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">ZipInputStream zin;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">zin = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"F:/image.zip"</span>));</span><br><span class="line">ZipEntry entry = zin.getNextEntry();</span><br><span class="line"><span class="keyword">while</span>(((entry=zin.getNextEntry())!=<span class="keyword">null</span>)&amp;&amp;!entry.isDirectory()) &#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(entry.getName());</span><br><span class="line">System.out.println(file);</span><br><span class="line"><span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">file.mkdir();</span><br><span class="line">file.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line">zin.closeEntry();</span><br><span class="line">System.out.println(entry.getName()+<span class="string">"解压成功"</span>);</span><br><span class="line">&#125;</span><br><span class="line">zin.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中通过使用java.util.zip包中的ZipOutputStream与ZipInputStream类来室性文件的压缩/解压缩操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ZipEntry类产生的对象，是用来代表一个ZIP压缩文件内的进入点；&lt;/li&gt;
&lt;li&gt;ZipInputStream类用来读取ZIP压缩格式的文件，所支持的包括已压缩及未压缩的进入点；&lt;/li&gt;
&lt;li&gt;ZipOutputStream类用来写出ZIP压缩格式的文件，而且所支持的包括已压缩及未压缩的进入点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的数据输入/输出流</title>
    <link href="https://www.gengruiblog.cn/article/20210904.html"/>
    <id>https://www.gengruiblog.cn/article/20210904.html</id>
    <published>2021-09-03T16:00:00.000Z</published>
    <updated>2021-10-31T23:13:48.765Z</updated>
    
    <content type="html"><![CDATA[<p>数据输入/输出流(DataInputStream类与DataOutputStream类)允许应用程序以与机器无关的方式从底层输入流中读取基本Java数据类型。</p><a id="more"></a><p>常用的构造方法如下：</p><ul><li>DataInputStream(InputStream in):使用指定的基础InputStream创建一个DataInputStream</li><li>DataOutputStream(OutputStream out):创建一个新的数据输出流，将数据写入指定基础输出流</li></ul><p>DataOutputStream类提供了如下几种写入字符串的方法：</p><ul><li>writeBytes(String s)</li><li>writeChars(String s)</li><li>writeUTF(String s)</li></ul><p>DataInputStream类只提供了一个readUTF()方法返回字符串</p><p>通过如下示例来进行说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example_01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FileOutputStream fs = <span class="keyword">new</span> FileOutputStream(<span class="string">"word.txt"</span>);</span><br><span class="line">DataOutputStream ds = <span class="keyword">new</span> DataOutputStream(fs);</span><br><span class="line">ds.writeUTF(<span class="string">"使用writeUTF()方法写入数据"</span>);</span><br><span class="line">ds.writeChars(<span class="string">"使用writeChars()方法写入数据"</span>);</span><br><span class="line">ds.writeBytes(<span class="string">"使用writeBytes()方法写入数据"</span>);</span><br><span class="line">ds.close();</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"word.txt"</span>);</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(fis);</span><br><span class="line">System.out.println(dis.readUTF());</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>word.txt的内容如下：</p><p><img src="https://gengrui01.github.io/picture/java-io-data/1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据输入/输出流(DataInputStream类与DataOutputStream类)允许应用程序以与机器无关的方式从底层输入流中读取基本Java数据类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中带缓存的输入/输出流</title>
    <link href="https://www.gengruiblog.cn/article/20210903.html"/>
    <id>https://www.gengruiblog.cn/article/20210903.html</id>
    <published>2021-09-02T16:00:00.000Z</published>
    <updated>2021-10-31T23:00:31.460Z</updated>
    
    <content type="html"><![CDATA[<p>缓存是I/O的一种性能优化，缓存流为I/O流增加了内存缓存区。</p><a id="more"></a><h2 id="1-BufferedInputStream与BufferedOutputStream类"><a href="#1-BufferedInputStream与BufferedOutputStream类" class="headerlink" title="1. BufferedInputStream与BufferedOutputStream类"></a>1. BufferedInputStream与BufferedOutputStream类</h2><p>BufferedInputStream类可以对所有InputStream类进行带缓存区的包装以达到性能的优化，有以下两种构造方法：</p><ul><li>BufferedInputStream(InputStream in)</li><li>BufferedInputStream(InputStream in,int Size)</li></ul><p>字节数据读取文件的流程如下：</p><p><img src="https://gengrui01.github.io/picture/java-io-buffered/1.png" alt=""></p><p>使用BufferedOutputStream输出信息和用OutputStream输出信息完全一样</p><p>只不过前者有一个flush()方法用来将缓冲区中的数据强制输出完，构造方法和BufferedInputStream类似</p><h2 id="2-BufferedReader和BufferedWriter类"><a href="#2-BufferedReader和BufferedWriter类" class="headerlink" title="2. BufferedReader和BufferedWriter类"></a>2. BufferedReader和BufferedWriter类</h2><p>这两个类分别继承了Reader类与Writer类，这两个类同样具有内部缓存机制，并可以以行为单位进行输入、输出。</p><p>字符数据读取文件的过程如下：</p><p><img src="https://gengrui01.github.io/picture/java-io-buffered/2.png" alt=""></p><p>BufferedReader类常用的方法如下：</p><ul><li>read()：读取单个字符</li><li>readline()：读取一个文本行，并将其返回为字符串</li></ul><p>BufferedWriter类中的方法都返回void，常用方法如下：</p><ul><li>write(String s,int off,int len)：写入字符串的某一部分</li><li>flush()：刷新该流的缓存</li><li>newLine():写入一个行分隔符</li></ul><p>在使用BufferedWriter类的write()方法时，数据并没有立刻被写入到输出流，而是首先进入缓存区中。</p><p>如果想立刻将缓存区中的数据写入输出流，一定要调用flush()方法。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">String content[] = &#123;<span class="string">"你"</span>,<span class="string">"好"</span>,<span class="string">"啊"</span>&#125;;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"word.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;content.length;k++) &#123;</span><br><span class="line">bufw.write(content[k]);</span><br><span class="line">bufw.newLine();</span><br><span class="line">&#125;</span><br><span class="line">bufw.close();</span><br><span class="line">fw.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((s = bufr.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+i+<span class="string">"行："</span>+s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;缓存是I/O的一种性能优化，缓存流为I/O流增加了内存缓存区。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的文件输入/输出流</title>
    <link href="https://www.gengruiblog.cn/article/20210902.html"/>
    <id>https://www.gengruiblog.cn/article/20210902.html</id>
    <published>2021-09-01T16:00:00.000Z</published>
    <updated>2021-10-31T23:06:57.586Z</updated>
    
    <content type="html"><![CDATA[<p>程序运行期间，大部分数据都在内存中进行操作，当程序结束或关闭时，这些数据将消失。</p><p>如果需要将数据永久保存，可使用文件输入/输出流与指定的文件建立连接，将需要的数据永久保存到文件中。</p><a id="more"></a><h2 id="1-FileInputStream与FileOutputStream类"><a href="#1-FileInputStream与FileOutputStream类" class="headerlink" title="1. FileInputStream与FileOutputStream类"></a>1. FileInputStream与FileOutputStream类</h2><p>FileInputStream类与FileOutputStream类都用来操作磁盘文件。</p><p>FileInputStream是InputStream的子类，FileOutputStream是OutputStream类的子类。</p><p>FileInputStream常用的构造方法如下：</p><ul><li>FileInputStream(String name)</li><li>FileInputStream(File file)</li></ul><p>FileOutputStream类与FileInputStream类的构造方法相同，但是使用FileOutputStream创建对象时，可以指定不存在的文件名，但此文件不能是一个已被其它程序打开的文件。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"word.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"><span class="keyword">byte</span> buy[] = <span class="string">"断剑重铸之日，骑士归来之时"</span>.getBytes();</span><br><span class="line">out.write(buy);</span><br><span class="line">out.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="keyword">byte</span> byt[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = in.read(byt);</span><br><span class="line">System.out.println(<span class="string">"文件中的信息是："</span>+<span class="keyword">new</span> String(byt,<span class="number">0</span>,len));</span><br><span class="line">in.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-FileReader与FileWriter类"><a href="#2-FileReader与FileWriter类" class="headerlink" title="2. FileReader与FileWriter类"></a>2. FileReader与FileWriter类</h2><p>对于FileOutputStream向文件中写入数据与使用FileInputStream类从文件中将内容读出来，都有一个缺点：</p><p>即这两个类都只提供了对字节或字节数组的读取方法，所以在读取汉字的时候，可能会出现乱码的现象。</p><p>使用Reader或Writer类可以避免，这两个类采用字符流。</p><p>FileReader流顺序地读载文件，只要不关闭流，每次调用read()方法就顺序地读取源中其余的内容，直到源的末尾或流被关闭。</p><p>通过以下示例来说明FileReader和FileWriter类的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ftest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        String s[] = &#123;<span class="string">"java"</span>, <span class="string">"python"</span>, <span class="string">"c"</span>, <span class="string">"c++"</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileWriter out = <span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>);</span><br><span class="line">            BufferedWriter outBW = <span class="keyword">new</span> BufferedWriter(out);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">                outBW.write(s[i]);</span><br><span class="line">                outBW.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">            outBW.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileReader in = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"test.txt"</span>));</span><br><span class="line">            BufferedReader inBR = <span class="keyword">new</span> BufferedReader(in);</span><br><span class="line">            String stext = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((stext = inBR.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + j + <span class="string">"行内容："</span> + stext);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            inBR.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序运行期间，大部分数据都在内存中进行操作，当程序结束或关闭时，这些数据将消失。&lt;/p&gt;
&lt;p&gt;如果需要将数据永久保存，可使用文件输入/输出流与指定的文件建立连接，将需要的数据永久保存到文件中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中File类</title>
    <link href="https://www.gengruiblog.cn/article/20210901.html"/>
    <id>https://www.gengruiblog.cn/article/20210901.html</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2021-10-31T13:50:50.441Z</updated>
    
    <content type="html"><![CDATA[<p>File类是java.io包中唯一代表磁盘文件本身的对象。</p><p>File类定义了一些平台无关的方法来操作文件，可以通过调用File类中的方法中的方法，实现创建、删除、重命名文件等操作。</p><p>File类的对象主要用来获取文件本身的一些信息。</p><a id="more"></a><h2 id="1-文件的创建与删除"><a href="#1-文件的创建与删除" class="headerlink" title="1. 文件的创建与删除"></a>1. 文件的创建与删除</h2><p>可以使用File类创建一个文件对象，常用的有一下三种：</p><p>（1）File(String pathname)</p><p>该构造方法通过将给定路径名字符串转换为抽象路径名来创建一个新File实例</p><p>pathname：为指定路径名称（包含文件名）</p><p>（2）File(String parent,String child)</p><p>该构造方法根据定义的父路径和子路径（包含文件名）字符串创建一个新的File对象</p><p>parent:父路径字符串，d:/doc</p><p>child:子路径字符串，java.txt</p><p>（3）File(File f,String child)</p><p>该构造方法根据parent抽象路径名和child路径名字符串创建一个新File实例</p><p>f:父路径对象，d:/doc/</p><p>child:子路径字符串,java.txt</p><p>通过以下示例进行详细说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"word.txt"</span>);</span><br><span class="line"><span class="keyword">if</span>(file.exists()) &#123;</span><br><span class="line">file.delete();</span><br><span class="line">System.out.println(<span class="string">"文件已删除"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">file.createNewFile();</span><br><span class="line">System.out.println(<span class="string">"文件已创建"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-获取文件信息"><a href="#2-获取文件信息" class="headerlink" title="2. 获取文件信息"></a>2. 获取文件信息</h2><p>File类获取文件本身信息的常用方法如下：</p><p><img src="https://gengrui01.github.io/picture/java-file/1.png" alt=""></p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"word.txt"</span>);</span><br><span class="line"><span class="keyword">if</span>(file.exists()) &#123;</span><br><span class="line">String name = file.getName();</span><br><span class="line"><span class="keyword">long</span> length = file.length();</span><br><span class="line"><span class="keyword">boolean</span> hidden = file.isHidden();</span><br><span class="line">System.out.println(<span class="string">"文件名称为："</span>+name);</span><br><span class="line">System.out.println(<span class="string">"文件长度为："</span>+length);</span><br><span class="line">System.out.println(<span class="string">"文件是否为隐藏文件："</span>+hidden);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"文件不存在"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;File类是java.io包中唯一代表磁盘文件本身的对象。&lt;/p&gt;
&lt;p&gt;File类定义了一些平台无关的方法来操作文件，可以通过调用File类中的方法中的方法，实现创建、删除、重命名文件等操作。&lt;/p&gt;
&lt;p&gt;File类的对象主要用来获取文件本身的一些信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java IO流入门</title>
    <link href="https://www.gengruiblog.cn/article/20210831.html"/>
    <id>https://www.gengruiblog.cn/article/20210831.html</id>
    <published>2021-08-30T16:00:00.000Z</published>
    <updated>2021-10-31T13:20:20.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流的概念和作用"><a href="#流的概念和作用" class="headerlink" title="流的概念和作用"></a>流的概念和作用</h2><p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。</p><p>即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p><a id="more"></a><h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ul><li>根据处理数据类型的不同分为：字符流和字节流</li><li>根据数据流向不同分为：输入流和输出流</li></ul><h2 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h2><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。</p><p>字节流和字符流的区别：</p><ul><li>读写单位不同：<ul><li>字节流以字节（8bit）为单位</li><li>字符流以字符为单位，根据码表映射字符，一次可能读多个字节</li></ul></li><li>处理对象不同：<ul><li>字节流能处理所有类型的数据（如图片、avi等）</li><li>字符流只能处理字符类型的数据</li></ul></li><li>字节流：一次读入或读出是8位二进制。</li><li>字符流：一次读入或读出是16位二进制。</li></ul><p>设备上的数据无论是图片或者视频，文字，它们都以二进制存储的。</p><p>二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。</p><p>意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。</p><p><strong>结论：</strong> 只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</p><h2 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h2><p>输入流只能进行读操作，输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。</p><p>Java语言定义了许多类专门负责各种方式的输入/输出，这些类都被放在java.io包中。</p><p>其中，所有输入流类都是抽象类InputStream(字节输入流)或抽象类Reader(字符输入流)的子类；而所有输出流都是抽象类OutputStream(字节输出流)或抽象类Writer(字符输出流)的子类。</p><ol><li>输入流：</li></ol><p><img src="https://gengrui01.github.io/picture/java-io/2.png" alt=""></p><ul><li>输入字节流 InputStream</li></ul><p>InputStream类是字节输入流的抽象类，是所有字节输入流的父类。InputStream类的具体层次结构如下：</p><p><img src="https://gengrui01.github.io/picture/java-io/4.png" alt=""></p><p>常用方法如下：</p><p>（1）read()方法：从输入流中读取数据的下个字节。返回0-255范围内的int字节值。到达流末尾，则返回-1</p><p>（2）read(byte[] b)：从输入流中读入一定长度的字节，并以整数的形式返回字节数</p><p>（3）mark(int readimit())：在输入流的当前位置放置标记，readimit表示输入流在标记位置失效前允许读取的字节数</p><p>（4）reset()：将输入指针返回当前所做的标记处</p><p>（5）skip(long n)：跳过输入流上的n个字节并返回实际跳过的字节数</p><p>（6）markSupported()：如果当前流支持mark()/reset()操作就返回True</p><p>（7）close()：关闭输入流并释放与该流关联的所有系统资源</p><ul><li>输入字符流 Reader</li></ul><p>Java中的字符是Unicode编码，是双字节的。InputStream是用来处理字节的，并不适合处理字符文本。</p><p>Java为字符文本的输入专门提供了一套单独的类Reader，但Reader类并不是InputStream的替换者。</p><p>Reader类是字符输入流的抽象类，所有字符输入流的实现都是它的子类。</p><p>Reader类的层次结构如下：</p><p><img src="https://gengrui01.github.io/picture/java-io/5.png" alt=""></p><ol start="2"><li>输出流：</li></ol><p><img src="https://gengrui01.github.io/picture/java-io/3.png" alt=""></p><ul><li>输出字节流 OutputStream</li></ul><p>OutputStream类是字节输出流的抽象类，此抽象类是表示输出字节流的所有类的超类。该类的层次结构如下：</p><p><img src="https://gengrui01.github.io/picture/java-io/6.png" alt=""></p><p>OutputStream类中的所有方法均返回void，常用方法如下：</p><p>（1）write(int b)：将指定的字节写入此输出流</p><p>（2）write(byte[] b)：将b个字节从指定的byte数组写入此输出流</p><p>（3）write(byte[] b,int off,int len)：将指定的byte数组中从偏移量off开始的len个字节写入到输出流</p><p>（4）flush()：彻底完成输出并清空缓存区</p><p>（5）close()：关闭输出流</p><ul><li>输出字符流 Writer</li></ul><p>Writer类是字符输出流的抽象类，所有字符输出类的实现都是它的子类</p><p>层次结构如下：</p><p><img src="https://gengrui01.github.io/picture/java-io/7.png" alt=""></p><h2 id="Java流类图结构"><a href="#Java流类图结构" class="headerlink" title="Java流类图结构"></a>Java流类图结构</h2><p><img src="https://gengrui01.github.io/picture/java-io/1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;流的概念和作用&quot;&gt;&lt;a href=&quot;#流的概念和作用&quot; class=&quot;headerlink&quot; title=&quot;流的概念和作用&quot;&gt;&lt;/a&gt;流的概念和作用&lt;/h2&gt;&lt;p&gt;流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。&lt;/p&gt;
&lt;p&gt;即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java注解Annotation的用法</title>
    <link href="https://www.gengruiblog.cn/article/20210829.html"/>
    <id>https://www.gengruiblog.cn/article/20210829.html</id>
    <published>2021-08-28T16:00:00.000Z</published>
    <updated>2021-10-11T12:16:34.369Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言中的类、方法、变量、参数和包等都可以被标注注解</p><p>和Javadoc注释不同的是Java注解可以通过反射获取标注内容，在编译器生成类文件时注解可以被嵌入到字节码中</p><p>Java虚拟机可以保留注解内容，在运行时可以获取到注解内容</p><a id="more"></a><h2 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h2><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中</p><h3 id="作用在代码的注解"><a href="#作用在代码的注解" class="headerlink" title="作用在代码的注解"></a>作用在代码的注解</h3><ul><li>@Override：检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated：标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings：指示编译器去忽略注解中声明的警告</li></ul><h3 id="作用在其他注解的注解-又称“元注解”"><a href="#作用在其他注解的注解-又称“元注解”" class="headerlink" title="作用在其他注解的注解(又称“元注解”)"></a>作用在其他注解的注解(又称“元注解”)</h3><ul><li>@Target：用于描述注解的使用范围，即被描述的注解可以用在什么地方，取值(ElementType)：<ul><li>CONSTRUCTOR：用于描述构造器</li><li>FIELD：用于描述域</li><li>LOCAL_VARIABLE：用于描述局部变量</li><li>METHOD：用于描述方法</li><li>PACKAGE：用于描述包</li><li>PARAMETER：用于描述参数</li><li>TYPE：用于描述类、接口(包括注解类型) 或enum声明</li></ul></li><li>@Retention：标识需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值(RetentionPolicy)：<ul><li>SOURCE:在源文件中有效（即源文件保留）</li><li>CLASS:在class文件中有效（即class保留）</li><li>RUNTIME:在运行时有效（即运行时保留）</li></ul></li><li>@Documented：标记这个注解应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化(@Documented是一个标记注解，没有成员)</li><li>@Inherited：也是一个标记注解。如果一个使用@Inherited修饰的Annotation类型被用于一个class，则这个Annotation将被用于该class的子类</li></ul><h2 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h2><p>在实际项目中，经常会碰到下面这种场景，一个接口的实现类或者抽象类的子类很多，经常需要根据不同情况（比如根据配置文件）实例化并使用不同的子类。典型的例子是结合工厂使用职责链模式。</p><p>此时，可以为每个实现类加上特定的Annotation，并在Annotation中给该类取一个标识符，应用程序可通过该标识符来判断应该实例化哪个子类。</p><p>下面这个例子，定义了一个名为Component的Annotation，它包含一个名为identifier的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span> <span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上文所说的实现类加上@Component</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value=<span class="string">"upper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpperCaseComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doWork</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> input.toUpperCase();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用程序中可以通过反射获取UpperCaseComponent对应的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class componentClass = Class.forName(<span class="string">"UpperCaseComponent"</span>);</span><br><span class="line">        <span class="keyword">if</span>(componentClass.isAnnotationPresent(Component<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            Component component = (Component)componentClass.getAnnotation(Component<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(component.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-annotation/1.png" alt=""></p><h2 id="Annotation与Interface的异同"><a href="#Annotation与Interface的异同" class="headerlink" title="Annotation与Interface的异同"></a>Annotation与Interface的异同</h2><ul><li>Annotation类型使用关键字<code>@interface</code>而非<code>interface</code></li><li>Annotation的方法定义是受限制的<ul><li>其方法必须声明为无参数、无异常抛出的</li><li>这些方法同时也定义了Annotation的成员——方法名即为成员名，而方法返回类型即为成员类型</li><li>方法返回类型必须为Java基础类型、Class类型、枚举类型、Annotation类型或者相应的一维数组</li><li>方法后面可以使用default关键字和一个默认数值来声明成员的默认值，null不能作为成员默认值</li><li>成员一般不能是泛型，只有当其类型是Class时可以使用泛型，因为此方法能够用类型转换将各种类型转换为Class</li></ul></li><li>Annotation和interface都可以定义常量、静态成员类型</li><li>interface可以被实现或者继承，Annotation不可以</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java语言中的类、方法、变量、参数和包等都可以被标注注解&lt;/p&gt;
&lt;p&gt;和Javadoc注释不同的是Java注解可以通过反射获取标注内容，在编译器生成类文件时注解可以被嵌入到字节码中&lt;/p&gt;
&lt;p&gt;Java虚拟机可以保留注解内容，在运行时可以获取到注解内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Class类与Java反射</title>
    <link href="https://www.gengruiblog.cn/article/20210828.html"/>
    <id>https://www.gengruiblog.cn/article/20210828.html</id>
    <published>2021-08-27T16:00:00.000Z</published>
    <updated>2021-10-11T12:25:59.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>反射就是在运行状态中</p><p>对于任意一个类，都能够知道这个类的所有属性和方法</p><p>对于任意一个对象，都能够调用它的任意方法和属性，并且能改变它的属性</p><a id="more"></a><h3 id="为什么要使用反射"><a href="#为什么要使用反射" class="headerlink" title="为什么要使用反射"></a>为什么要使用反射</h3><p>在Java中，我们编写好的.java类要先编译生成.class文件，之后运行出我们期望的结果</p><p>通常我们需要获取一个类的信息都是在编译期获得的，例如直接点（.）出属性和方法，或者使用new创建对象，这些都是使用了类的信息</p><p>可是如果需要在运行期需要获得Java类的信息就需要用到反射了</p><h3 id="反射的作用是什么？"><a href="#反射的作用是什么？" class="headerlink" title="反射的作用是什么？"></a>反射的作用是什么？</h3><p>反射机制就是允许程序在运行时取得任何一个已知名称的class的内部信息</p><p>包括其modifiers(修饰符)，fields(属性)，methods(方法)等</p><p>并可于运行时改变fields内容或调用methods。(同反射的概念)</p><h3 id="反射的实现"><a href="#反射的实现" class="headerlink" title="反射的实现"></a>反射的实现</h3><p>为了实现反射，我们先回顾 <a href="https://www.gengruiblog.cn/article/20180718.html">JVM类加载机制</a> 中类的生命周期</p><p>可以发现我们可以利用类加载时所开的入口（java.lang.Class对象）对该类进行解剖</p><p>把各个组成部分(构造器，属性，方法等)映射成一个个对象</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>Class类就是Java反射机制的入口，它封装了一个类或接口的运行时信息，通过调用Class类的方法可以获取这些信息</p><p>而Class类的对象就用于表示当前运行的 Java 应用程序中的类和接口</p><h3 id="得到Class类对象的方式"><a href="#得到Class类对象的方式" class="headerlink" title="得到Class类对象的方式"></a>得到Class类对象的方式</h3><ol><li>通过对象调用 getClass() 方法来获取</li></ol><p>我们都知道所有的java类都是继承了Object这个类</p><p>在Object类中有一个getClass()方法可以得到该类所维持的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> A();</span><br><span class="line">Class a1=a.getClass();</span><br></pre></td></tr></table></figure><ol start="2"><li>通过类名.class</li></ol><p>该方法最为安全可靠，程序性能更高</p><p>这说明任何一个类都有一个隐含的静态成员变量 class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class a2=A<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>Class类的forName(String classpathname)方法</li></ol><p>不需要关注类型，用的最多，但可能抛出 ClassNotFoundException 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class a3 = Class.forName(<span class="string">"reflect.A"</span>);</span><br></pre></td></tr></table></figure><p><strong><em>TIPS:</em></strong> </p><blockquote><p>一个类在 JVM 中只会有一个 Class 实例<br>即我们对上面获取的 a1,a2,a3 进行 equals 比较，发现都是true</p></blockquote><h3 id="Class类提供的方法"><a href="#Class类提供的方法" class="headerlink" title="Class类提供的方法"></a>Class类提供的方法</h3><ol><li>获取类信息</li><li>获取Constructor对象</li><li>获取Field对象</li><li>获取Method对象</li></ol><h2 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h2><p>首先做准备工作定义一个User.java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..........省略set 和 get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="得到Constructor类对象的方式"><a href="#得到Constructor类对象的方式" class="headerlink" title="得到Constructor类对象的方式"></a>得到Constructor类对象的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectConstructor</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取Class对象的引用</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"reflect.User"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化默认构造方法，User必须无参构造函数,否则将抛异常</span></span><br><span class="line">        User user = (User) clazz.newInstance();</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setName(<span class="string">"Rollen"</span>);</span><br><span class="line">        System.out.println(<span class="string">"user:"</span>+user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取带String参数的public构造函数</span></span><br><span class="line">        Constructor cs1 =clazz.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//创建User</span></span><br><span class="line">        User user1= (User) cs1.newInstance(<span class="string">"xiaolong"</span>);</span><br><span class="line">        user1.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">"user1:"</span>+user1.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取得指定带int和String参数构造函数,该方法是私有构造private</span></span><br><span class="line">        Constructor cs2=clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//由于是private必须设置可访问</span></span><br><span class="line">        cs2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//创建user对象</span></span><br><span class="line">        User user2= (User) cs2.newInstance(<span class="number">25</span>,<span class="string">"lidakang"</span>);</span><br><span class="line">        System.out.println(<span class="string">"user2:"</span>+user2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/1.png" alt=""></p><h3 id="Constructor类提供的方法"><a href="#Constructor类提供的方法" class="headerlink" title="Constructor类提供的方法"></a>Constructor类提供的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造函数参数类型</span></span><br><span class="line">Constructor cs3=clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Class&lt;?&gt; clazzs[] = cs3.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class claz:clazzs) &#123;</span><br><span class="line">    System.out.println(<span class="string">"参数名称:"</span>+claz.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/2.png" alt=""></p><h2 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h2><p>首先做准备工作定义一个Person.java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个Student.java类继承Person</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="得到Field类对象的方式"><a href="#得到Field类对象的方式" class="headerlink" title="得到Field类对象的方式"></a>得到Field类对象的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"reflect.Student"</span>);</span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段,</span></span><br><span class="line">        <span class="comment">// 否则抛NoSuchFieldException</span></span><br><span class="line">        Field field = clazz.getField(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(<span class="string">"field:"</span>+field);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取</span></span><br><span class="line">        Field fields[] = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f:fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">"f:"</span>+f.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段</span></span><br><span class="line">        Field field2 = clazz.getDeclaredField(<span class="string">"desc"</span>);</span><br><span class="line">        System.out.println(<span class="string">"field2:"</span>+field2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/3.png" alt=""></p><h3 id="Field类提供的方法"><a href="#Field类提供的方法" class="headerlink" title="Field类提供的方法"></a>Field类提供的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">Student st= (Student) clazz.newInstance();</span><br><span class="line"><span class="comment">//获取父类public字段并赋值</span></span><br><span class="line">Field ageField = clazz.getField(<span class="string">"age"</span>);</span><br><span class="line">ageField.set(st,<span class="number">18</span>);</span><br><span class="line">Field nameField = clazz.getField(<span class="string">"name"</span>);</span><br><span class="line">nameField.set(st,<span class="string">"Lily"</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/4.png" alt=""></p><h2 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h2><p>首先做准备工作定义一个Shape.java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> count, String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw "</span>+ name +<span class="string">",count="</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个Circle.java类继承Shape</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"drawCircle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAllCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="得到Method类对象的方式"><a href="#得到Method类对象的方式" class="headerlink" title="得到Method类对象的方式"></a>得到Method类对象的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectMethod</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"reflect.Circle"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据参数获取public的Method,包含继承自父类的方法</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"draw"</span>,<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"method:"</span>+method);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有public的方法:</span></span><br><span class="line">        Method[] methods =clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m:methods)&#123;</span><br><span class="line">            System.out.println(<span class="string">"m::"</span>+m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前类的方法包含private,该方法无法获取继承自父类的method</span></span><br><span class="line">        Method method1 = clazz.getDeclaredMethod(<span class="string">"drawCircle"</span>);</span><br><span class="line">        System.out.println(<span class="string">"method1::"</span>+method1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/5.png" alt=""></p><h3 id="Method类提供的方法"><a href="#Method类提供的方法" class="headerlink" title="Method类提供的方法"></a>Method类提供的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">Circle circle = (Circle) clazz.newInstance();</span><br><span class="line"><span class="comment">//获取指定参数的方法对象Method</span></span><br><span class="line">Method drawMethod = clazz.getMethod(<span class="string">"draw"</span>,<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="comment">//通过Method对象的invoke(Object obj,Object... args)方法调用</span></span><br><span class="line">drawMethod.invoke(circle,<span class="number">15</span>,<span class="string">"圈圈"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对私有无参方法的操作</span></span><br><span class="line">Method drawCircleMethod = clazz.getDeclaredMethod(<span class="string">"drawCircle"</span>);</span><br><span class="line"><span class="comment">//修改私有方法的访问标识</span></span><br><span class="line">drawCircleMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">drawCircleMethod.invoke(circle);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对有返回值得方法操作</span></span><br><span class="line">Method getAllCountMethod =clazz.getDeclaredMethod(<span class="string">"getAllCount"</span>);</span><br><span class="line">Integer count = (Integer) getAllCountMethod.invoke(circle);</span><br><span class="line">System.out.println(<span class="string">"count:"</span>+count);</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;反射就是在运行状态中&lt;/p&gt;
&lt;p&gt;对于任意一个类，都能够知道这个类的所有属性和方法&lt;/p&gt;
&lt;p&gt;对于任意一个对象，都能够调用它的任意方法和属性，并且能改变它的属性&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java列表泛型结合lambda表达式使用</title>
    <link href="https://www.gengruiblog.cn/article/20210826.html"/>
    <id>https://www.gengruiblog.cn/article/20210826.html</id>
    <published>2021-08-25T16:00:00.000Z</published>
    <updated>2021-09-17T11:27:13.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="列表泛型的使用"><a href="#列表泛型的使用" class="headerlink" title="列表泛型的使用"></a>列表泛型的使用</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>一个数据类，用于记录职工信息</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">public</span> String time;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一列此类数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; data = Arrays.asList(e1,e2,e3......)</span><br></pre></td></tr></table></figure><h3 id="将员工按照姓名的首字母分组"><a href="#将员工按照姓名的首字母分组" class="headerlink" title="将员工按照姓名的首字母分组"></a>将员工按照姓名的首字母分组</h3><p>将员工Employee按照姓名的首字母(假设均为英文名)进行分组</p><p>我们要得到的结果应该是一个 <code>Map：char -&gt; List&lt;Employee&gt;</code> 这样的映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Character, List&lt;Employee&gt;&gt; groupByFirstChar(List&lt;Employee&gt; data)&#123;</span><br><span class="line">    Map&lt;Character, List&lt;Employee&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Employee e : data)&#123;</span><br><span class="line">        Character c = e.getName().charAt(<span class="number">0</span>);</span><br><span class="line">        List&lt;Employee&gt; l = result.get(c);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span>)&#123;</span><br><span class="line">            l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            l.add(e);</span><br><span class="line">            result.put(c, l);</span><br><span class="line">        &#125;</span><br><span class="line">        l.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将员工按照工资分组"><a href="#将员工按照工资分组" class="headerlink" title="将员工按照工资分组"></a>将员工按照工资分组</h3><p>将员工Employee按照工资分个组吧，5000以下的，5000~10000的 … 等</p><p>也不会太难，将key换一下，稍作逻辑处理即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, List&lt;Employee&gt;&gt; groupBySalary(List&lt;Employee&gt; data) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Employee&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Employee e : data) &#123;</span><br><span class="line">        String key = separate(e.getSalary());</span><br><span class="line">        List&lt;Employee&gt; l = result.get(key);</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;</span><br><span class="line">            l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            l.add(e);</span><br><span class="line">            result.put(key, l);</span><br><span class="line">        &#125;</span><br><span class="line">        l.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">separate</span><span class="params">(<span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (salary &lt;= <span class="number">5000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"5000以下"</span>;</span><br><span class="line">    <span class="keyword">if</span> (salary &lt;= <span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"5000~10000"</span>;</span><br><span class="line">    <span class="keyword">if</span> (salary &lt;= <span class="number">20000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"10000~20000"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"20000以上"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列表泛型结合接口泛型及内部类的使用"><a href="#列表泛型结合接口泛型及内部类的使用" class="headerlink" title="列表泛型结合接口泛型及内部类的使用"></a>列表泛型结合接口泛型及内部类的使用</h2><h3 id="找相同"><a href="#找相同" class="headerlink" title="找相同"></a>找相同</h3><p>稍作比较可以发现，无论怎么分组，唯一的变化是key值的选取方式</p><p>第一次将Employee的name的第一字母作为key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e -&gt; e.name.charAt(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>也可以将获取首字母单独写成一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e -&gt; getFirstChar(e.getName()):Character</span><br></pre></td></tr></table></figure><p>第二次将Employee的salary按照方法separat转换为String作为key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e -&gt; separate(e.getSalary()):String</span><br></pre></td></tr></table></figure><p>再比如新的需求是将员工按照入职年份分组</p><p>那就将Employee的time按照方法getYear转换为String作为key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e -&gt; getYear(e.getTime()):String</span><br></pre></td></tr></table></figure><p>为了看起来更美观，可以讲三个方法的参数都设置成Employee 方法体就不写了 这里只列出参数和返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e -&gt; getFirstChar(e) : Character</span><br><span class="line">Employee e -&gt; separate(e) : String</span><br><span class="line">Employee e -&gt; getYear(e) : String</span><br></pre></td></tr></table></figure><p>-&gt;的左边为参数，-&gt;的右边是方法的签名，:的右边为返回值</p><h3 id="引入接口泛型及内部类"><a href="#引入接口泛型及内部类" class="headerlink" title="引入接口泛型及内部类"></a>引入接口泛型及内部类</h3><p>这时我们自然会想到将变化的部分抽取为参数，其他不变的部分抽取为方法体，那么就可以省去那些重复的代码</p><p>显然变化的部分就是上面列出的，将Employee e转化成key的方法</p><p>但是我们知道java是不能把方法作为参数进行传递的，不过对于稍有经验的程序猿来说这并不是问题，我们可以使用接口来实现我们的目的</p><p>同时又会遇到另一个问题，以上三个方法的返回值是不同的，因此我们要用到<strong>泛型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; Map&lt;K, List&lt;Employee&gt;&gt; groupByKey(List&lt;Employee&gt; data, GetKey&lt;K&gt; getKey)&#123;</span><br><span class="line">    Map&lt;K, List&lt;Employee&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Employee e : data) &#123;</span><br><span class="line">        K key = getKey.getKey(e);</span><br><span class="line">        List&lt;Employee&gt; l = result.get(key);</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;</span><br><span class="line">            l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            l.add(e);</span><br><span class="line">            result.put(key, l);</span><br><span class="line">        &#125;</span><br><span class="line">        l.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GetKey</span>&lt;<span class="title">K</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">(Employee e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么上面的第一个需求就可以这样实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, List&lt;Employee&gt;&gt; result = groupByKey(data, <span class="keyword">new</span> GetKey&lt;Character&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Character <span class="title">getKey</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">            e.name.charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>第二个需求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; result = groupByKey(list, <span class="keyword">new</span> GetKey&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">            separate(e.salary);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="列表泛型结合lambda表达式使用"><a href="#列表泛型结合lambda表达式使用" class="headerlink" title="列表泛型结合lambda表达式使用"></a>列表泛型结合lambda表达式使用</h2><h3 id="找相似"><a href="#找相似" class="headerlink" title="找相似"></a>找相似</h3><p>可以发现，我们只需要更改泛型参数和匿名内部类的实现即可</p><p>唯一的问题恐怕是这么写实在不太好看，而且很多例行公事的代码，尤其体现在匿名内部类上</p><p>事实上我们只关心这个匿名内部类的参数和返回值，其他部分仅仅是语法要求</p><h3 id="引入lambda表达式"><a href="#引入lambda表达式" class="headerlink" title="引入lambda表达式"></a>引入lambda表达式</h3><p>java8恰好为我们提供了很好的方式来避免复杂的例行公事的方式：lambda表达式</p><p>以上实现就可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, List&lt;Employee&gt;&gt; resultByFirstChar = groupByKey(list, e -&gt; e.name.charAt(<span class="number">0</span>));</span><br><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; resultBySalary = groupByKey(list, e -&gt; separate(e.salary));</span><br></pre></td></tr></table></figure><p>lambda表达式恰恰只表现出我们所关心的，参数和返回值，同时由于类型推断，可以省去参数类型</p><p>lambda表达式的具体语法这里就不介绍了，网上可以查到很多资料</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;列表泛型的使用&quot;&gt;&lt;a href=&quot;#列表泛型的使用&quot; class=&quot;headerlink&quot; title=&quot;列表泛型的使用&quot;&gt;&lt;/a&gt;列表泛型的使用&lt;/h2&gt;&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;一个数据类，用于记录职工信息&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="https://www.gengruiblog.cn/article/20210825.html"/>
    <id>https://www.gengruiblog.cn/article/20210825.html</id>
    <published>2021-08-24T16:00:00.000Z</published>
    <updated>2021-09-13T12:04:48.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="向上转型-amp-向下转型"><a href="#向上转型-amp-向下转型" class="headerlink" title="向上转型 &amp; 向下转型"></a>向上转型 &amp; 向下转型</h2><p>Java语言允许用父类申明变量,用子类实例化,这种将子类对象直接赋值给父类对象的语法称为向上转型,而且这个过程是自动化的</p><p>但反过来用子类申明变量用父类实例化是不允许的,因为子类往往比父类更加复杂,计算机无法将简单的对象自动的转化为复杂的对象</p><p>向下转型需要做强制的转化,在父类对象前使用强制转换的语法才能实现向下转型,而且转型之后也有可能发生数据缺失</p><a id="more"></a><p><img src="https://gengrui01.github.io/picture/java-generics/1.png" alt=""></p><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>举个例子帮助大家了解泛型是什么</p><p><img src="https://gengrui01.github.io/picture/java-generics/2.png" alt=""></p><p>这里有一条公路，我们可以在这条路上开汽车/骑自行车/骑马</p><p>但如果这条路上放了一个标志机动车道这样的话，我们就不能在这条路上骑自行车和骑马了</p><p>我们只能开汽车，如果这个标志换成了自行车道的话，那么我们就只能骑自行车，但不能开汽车了，也不能骑马</p><p>这个标志限制了这条路上允许行驶的交通工具，它的作用啊就相当于泛型</p><p>Java1.5版本提供了泛型的概念，泛型的实质上就是使程序员可以定义安全的数据类型</p><h2 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h2><p>泛型可以在定义类的时候定义,它的语法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名&lt;类型参数<span class="number">1</span>,类型参数<span class="number">2</span>,...,类型参数n&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>创建类时在类名与大括号之间写一对尖括号，在括号里面写泛型的类型参数，可以写一个也可以写很多个</p><p>具体例子如下:</p><p><img src="https://gengrui01.github.io/picture/java-generics/3.png" alt=""></p><p>在这个监控号里面呢写了一个泛型类型，我们可以起任意一个名字(一般不用已经存在的类名)</p><p>通常会用一个大写的英文字母来代替，之后直接用这个泛型的来创建成员变量,也可以放在方法的参数中，也可以作为方法的返回值</p><p><strong><em>TIPS:</em></strong></p><blockquote><p>如果我们定义了泛型却不使用,Eclipse会发出警告<br>但这样啊不会影响到我们程序的运行</p></blockquote><h2 id="使用泛型-VS-不使用泛型"><a href="#使用泛型-VS-不使用泛型" class="headerlink" title="使用泛型 VS 不使用泛型"></a>使用泛型 VS 不使用泛型</h2><p>接下来写两个例子对比使用泛型和不使用泛型的效果</p><h3 id="不使用泛型"><a href="#不使用泛型" class="headerlink" title="不使用泛型"></a>不使用泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object b; <span class="comment">// 定义Object类型成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getB</span><span class="params">()</span> </span>&#123; <span class="comment">// 设置相应getXXX()方法</span></span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(Object b)</span> </span>&#123; <span class="comment">// 设置相应setXXX()方法</span></span><br><span class="line"><span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">t1.setB(<span class="keyword">true</span>); <span class="comment">// 向上转型操作</span></span><br><span class="line">System.out.println(t1.getB());</span><br><span class="line">Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">t2.setB(<span class="number">12.3f</span>);</span><br><span class="line">Float f = (Float) (t2.getB()); <span class="comment">// 向下转型操作</span></span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-generics/9.png" alt=""></p><p>这样的代码是有隐患的,比如我们将Float类型的t2强转为int类型时编译是不会报错的,但是运行必报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)t2.getB();</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p>于是JDK提供了泛型</p><h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T b; <span class="comment">// 定义泛型成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getB</span><span class="params">()</span> </span>&#123; <span class="comment">// 设置相应getXXX()方法</span></span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(T b)</span> </span>&#123; <span class="comment">// 设置相应setXXX()方法</span></span><br><span class="line"><span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test2&lt;Boolean&gt; t1 = <span class="keyword">new</span> Test2&lt;Boolean&gt;();</span><br><span class="line">t1.setB(<span class="keyword">true</span>);</span><br><span class="line">        t1.setB(<span class="string">"abc"</span>); <span class="comment">// 会报参数类型错误</span></span><br><span class="line">        <span class="keyword">float</span> i = t1.getB(); <span class="comment">// 会报参数类型错误</span></span><br><span class="line">System.out.println(t1.getB());</span><br><span class="line"></span><br><span class="line">Test2&lt;Integer&gt; t2 = <span class="keyword">new</span> Test2&lt;&gt;();<span class="comment">// JDK1.7升级,后面泛型可省略</span></span><br><span class="line">t2.setB(<span class="number">123</span>);</span><br><span class="line">System.out.println(t2.getB());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-generics/7.png" alt=""></p><p><strong><em>TIPS:</em></strong></p><blockquote><p>泛型定义时可以不止一个<br>但申明时泛型要么都实现,要么都不实现(不写就是Object)</p></blockquote><h3 id="使用多个泛型"><a href="#使用多个泛型" class="headerlink" title="使用多个泛型"></a>使用多个泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T b;</span><br><span class="line"><span class="keyword">private</span> K k;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(T b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">getK</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setK</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.k = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test2&lt;Boolean, Float&gt; t1 = <span class="keyword">new</span> Test2&lt;&gt;();</span><br><span class="line">t1.setB(<span class="keyword">true</span>);</span><br><span class="line">t1.setK(<span class="number">1.1f</span>);</span><br><span class="line">System.out.println(<span class="string">"b:"</span> + t1.getB() + <span class="string">"   k:"</span> + t1.getK());</span><br><span class="line"></span><br><span class="line">Test2&lt;Integer, String&gt; t2 = <span class="keyword">new</span> Test2&lt;&gt;();</span><br><span class="line">t2.setB(<span class="number">123</span>);</span><br><span class="line">t2.setK(<span class="string">"string"</span>);</span><br><span class="line">System.out.println(<span class="string">"b:"</span> + t2.getB() + <span class="string">"   k:"</span> + t2.getK());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-generics/8.png" alt=""></p><h2 id="限制泛型的类型"><a href="#限制泛型的类型" class="headerlink" title="限制泛型的类型"></a>限制泛型的类型</h2><p>我们使用任何的类型来实例化一个泛型对象，这样是存在弊端的</p><p>于是Java提供了一种语法来限制泛型的可实现类,这种语法呢就是泛型的继承</p><p>它的语法如下图所示:</p><p><img src="https://gengrui01.github.io/picture/java-generics/6.png" alt=""></p><p>我们在创建泛型的时候使用extends关键字，这样就给泛型T添加了一个限制</p><p>这个泛型必须是anyClass的子类，虽然这里使用的是extend关键字，但是这个anyClass既可以是类也可以是接口</p><p>我们呢写一个例子给大家看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">List</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test3&lt;ArrayList&gt; t1 = <span class="keyword">new</span> Test3&lt;&gt;();</span><br><span class="line">Test3&lt;LinkedList&gt; t2 = <span class="keyword">new</span> Test3&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Test3&lt;HashSet&gt; t3 = <span class="keyword">new</span> Test3&lt;&gt;(); <span class="comment">// HashSet 不是 List 的子类 所以会报错</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>泛型机制中提供了泛型通配符，它的作用主要是在创建泛型对象时限制泛型的类型，并且啊限制泛型对象的使用</p><p>它的语法如下图所示:</p><p><img src="https://gengrui01.github.io/picture/java-generics/4.png" alt=""></p><p>这里的问号来代表泛型通配符，他可以代表任意的类型</p><p>如果这个问号继承了一个类那么这个泛型就必须是anyClass的子类,并且此对象不能作增加和改写的操作，限制了这个泛型的对象只能读取，不能增加和改写</p><p>泛型通配符还有另外一种使用方法，可以使用super关键字，这样就限制了泛型必须是anyClass或者是anyClass的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        l1.add(<span class="string">"成员1"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;? extends List&gt; l2 = <span class="keyword">new</span> ArrayList&lt;List&gt;();<span class="comment">// 指定了上界</span></span><br><span class="line">        List&lt;? <span class="keyword">super</span> List&gt; l3 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();<span class="comment">// 指定了下界</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后呢，我们对泛型做出一些总结</p><ol><li>泛型只能是类类型</li></ol><p>正确: <code>Demo&lt;Integer&gt;</code></p><p>错误: <code>Demo&lt;int&gt;</code></p><ol start="2"><li>泛型的类型个数呢可以是多个</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo&lt;T,K,V&gt;</span><br></pre></td></tr></table></figure><p>注意泛型最好呢是要写一个单个的英文字母</p><ol start="3"><li>使用extends关键字限制泛型使用的范围</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo&lt;T extends Number&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用通配符来限制泛型的上下界</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo&lt;?&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;向上转型-amp-向下转型&quot;&gt;&lt;a href=&quot;#向上转型-amp-向下转型&quot; class=&quot;headerlink&quot; title=&quot;向上转型 &amp;amp; 向下转型&quot;&gt;&lt;/a&gt;向上转型 &amp;amp; 向下转型&lt;/h2&gt;&lt;p&gt;Java语言允许用父类申明变量,用子类实例化,这种将子类对象直接赋值给父类对象的语法称为向上转型,而且这个过程是自动化的&lt;/p&gt;
&lt;p&gt;但反过来用子类申明变量用父类实例化是不允许的,因为子类往往比父类更加复杂,计算机无法将简单的对象自动的转化为复杂的对象&lt;/p&gt;
&lt;p&gt;向下转型需要做强制的转化,在父类对象前使用强制转换的语法才能实现向下转型,而且转型之后也有可能发生数据缺失&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java枚举类型</title>
    <link href="https://www.gengruiblog.cn/article/20210824.html"/>
    <id>https://www.gengruiblog.cn/article/20210824.html</id>
    <published>2021-08-23T16:00:00.000Z</published>
    <updated>2021-09-13T04:34:32.092Z</updated>
    
    <content type="html"><![CDATA[<p>常量指的就是计算机中不可改变的量。比如一年中有四个季节，彩虹有七种原色，这些都是固定的值，也就是所谓的常量</p><p>在Java中我们通过使用final关键字来创建常量</p><p>但是这种方式创建出的常量仍然存在一些弊端，所以JDK1.5中就新增了枚举的概念</p><a id="more"></a><p>枚举是一种数据类型，它是一系列具有名称的常量的集合</p><p>枚举和普通的常量有一些不同之处，如果使用枚举的话，只能使用枚举中已经设定好的常量，只要是不在这个集合中的常量我们都无法使用</p><h2 id="创建枚举"><a href="#创建枚举" class="headerlink" title="创建枚举"></a>创建枚举</h2><p>创建枚举的语法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    枚举<span class="number">1</span>,</span><br><span class="line">    枚举<span class="number">2</span>,</span><br><span class="line">    枚举<span class="number">3</span>,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看这里使用了enum关键字，而这个enum关键字它和class、interface这些关键字的作用大致相似，只不过它所声明的这个类型叫做枚举类型</p><p>用户可以将一个枚举类型看作成为一个类，他继承了java.lang.Enum这个类</p><p>当我们定义一个枚举类型的时候,每一个枚举类型的成员都可以看作为这个类型的实例，而这些枚举类型都默认被这个<code>public static final</code>修饰</p><p>也就是说这些对象都是公有的静态常量，所以当我们使用枚举类型成员的时候，直接可以用<code>枚举名.枚举值</code>的方式来调用这些枚举成员</p><p>我们来看一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Constants&#123;</span><br><span class="line">    Constants_A,</span><br><span class="line">    Constants_B,</span><br><span class="line">    Constants_C,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建枚举成员的时候不需要写它是什么类型,只需要直接像这样给他写一个名字就可以了,然后用逗号隔开</p><p>最后一个枚举成员，后面可以写分号，也可以写逗号，也可以什么都不写，这个枚举我们就是创建完了</p><h2 id="普通常量-VS-枚举常量"><a href="#普通常量-VS-枚举常量" class="headerlink" title="普通常量 VS 枚举常量"></a>普通常量 VS 枚举常量</h2><h3 id="普通常量"><a href="#普通常量" class="headerlink" title="普通常量"></a>普通常量</h3><p>首先创建一个接口,接口里面的量都是公有静态常量,默认会有<code>public static final</code>修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Constants</span> </span>&#123; <span class="comment">// 将常量放置在接口中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Constants_A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Constants_B = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在demo中定义doit()方法,将常量作为参数传进方法,根据常量的值打出对应常量名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line"><span class="keyword">case</span> Constants.Constants_A:</span><br><span class="line">System.out.println(<span class="string">"doit() Constants_A"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Constants.Constants_B:</span><br><span class="line">System.out.println(<span class="string">"doit() Constants_B"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">doit(Constants.Constants_A); <span class="comment">// 使用接口中定义的常量</span></span><br><span class="line">        doit(<span class="number">12</span>);</span><br><span class="line">doit(<span class="number">3</span>);<span class="comment">// 使用接口中不存在的常量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-enum/3.png" alt=""></p><p>普通变量有两个缺点:</p><ol><li>doit()方法传入的参数如果在常量中不存在,编译运行都没有任何报错信息</li><li>两个常量可以等于同一个值,编译时switch case报错</li></ol><h3 id="枚举常量"><a href="#枚举常量" class="headerlink" title="枚举常量"></a>枚举常量</h3><p>创建一个枚举,枚举里面有常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Constants2 &#123;</span><br><span class="line">    Constants_A, Constants_B, Constants_C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在demo中定义doit2()方法,将枚举作为参数传进方法,根据枚举打出对应枚举名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个方法，这里的参数为枚举类型对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doit2</span><span class="params">(Constants2 constants2)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">switch</span> (constants2) &#123;</span><br><span class="line">        <span class="keyword">case</span> Constants_A:</span><br><span class="line">            System.out.println(<span class="string">"doit2() Constants_A"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Constants_B:</span><br><span class="line">            System.out.println(<span class="string">"doit2() Constants_B"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Constants_C:</span><br><span class="line">            System.out.println(<span class="string">"doit2() Constants_C"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加main方法,测试打印的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doit2(Constants2.Constants_A);</span><br><span class="line">doit2(Constants2.Constants_B);</span><br><span class="line">doit2(Constants2.Constants_C);</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-enum/4.png" alt=""></p><p>注意:</p><ol><li>doit()方法传入的参数必须是枚举类型对象</li><li>枚举类型没有值</li></ol><h2 id="枚举类型的常用方法"><a href="#枚举类型的常用方法" class="headerlink" title="枚举类型的常用方法"></a>枚举类型的常用方法</h2><p>枚举类型的继承自java.lang.Enum，所以枚举也可以调用方法，介绍一下比较常用的这4个方法</p><h3 id="values-方法"><a href="#values-方法" class="headerlink" title="values()方法"></a>values()方法</h3><p>可以将枚举类型的所有成员以数组的形式返回出来</p><p>我们在main方法中打印Constants2中的枚举成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constants2[] enumArray = Constants2.values();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enumArray.length; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"枚举类型成员变量："</span> + enumArray[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个value的这个方法之后呢，会枚举类型的所有成员封装成一个数组</p><p><img src="https://gengrui01.github.io/picture/java-enum/5.png" alt=""></p><h3 id="valueOf-方法"><a href="#valueOf-方法" class="headerlink" title="valueOf()方法"></a>valueOf()方法</h3><p>该方法可以将普通字符串转化为枚举实例,类似于包装类提供的valueOf()方法</p><p>我们在main方法中创建两个枚举对象,分别接收枚举对象以及valueOf()方法转化的枚举实例</p><p>打印俩枚举对象是否完全相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constants2 c1 = Constants2.Constants_A;</span><br><span class="line">Constants2 c2 = Constants2.valueOf(<span class="string">"Constants_A"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"c1与c2是否相等："</span> + (c1 == c2));</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-enum/6.png" alt=""></p><p>在<code>valueOf()</code>中传入不存在的值,如下代码所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constants2 c2 = Constants2.valueOf(<span class="string">"OK"</span>);</span><br></pre></td></tr></table></figure><p>会报找不到枚举值的错误</p><p><img src="https://gengrui01.github.io/picture/java-enum/7.png" alt=""></p><h3 id="ordinal-方法"><a href="#ordinal-方法" class="headerlink" title="ordinal()方法"></a>ordinal()方法</h3><p>枚举成员的是有索引位置的,第一个索引为0,第二个为1,以此类推</p><p><img src="https://gengrui01.github.io/picture/java-enum/2.png" alt=""></p><p>ordinal()方法就是用来得到枚举成员的位置索引</p><p>我们在main方法中输出Constants2所有枚举成员的索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constants2[] enumArray = Constants2.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enumArray.length; i++) &#123;</span><br><span class="line">    System.out.println(enumArray[i] + <span class="string">"在枚举类型中位置索引值是"</span> + enumArray[i].ordinal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-enum/9.png" alt=""></p><h3 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h3><p>该方法用来比较两个枚举对象在定义时的顺序</p><p>仍然以Constants2为例</p><p><img src="https://gengrui01.github.io/picture/java-enum/1.png" alt=""></p><p>我们在main方法中创建一个枚举对象存放Constants_B</p><p>再创建一个数组enumArray获取枚举类型的所有成员</p><p>最后for循环遍历enumArray,输出Constants_B和枚举中所有成员的比较结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constants2 c = Constants2.Constants_B;</span><br><span class="line">Constants2[] enumArray = Constants2.values();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enumArray.length; i++) &#123;</span><br><span class="line">    System.out.println(c + <span class="string">"与枚举类型成员"</span> + enumArray[i] + <span class="string">"的比较结果为"</span> + c.compareTo(enumArray[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-enum/8.png" alt=""></p><h2 id="枚举类型的优势"><a href="#枚举类型的优势" class="headerlink" title="枚举类型的优势"></a>枚举类型的优势</h2><p>枚举类型提供了一种非常友好的定义常量的方法</p><p>枚举类型有以下几个特点</p><ol><li>它是类型安全的，因为每一个枚举都是一个枚举对象而不是一个具体的数值，所以它不会被其他数值所替代</li><li>它是紧凑有效的数据定义</li><li>枚举还可以和程序的其他部分完美的交互，比如说switch语句就直接可以用枚举来作为参数</li><li>它的运行效率高</li></ol><p>第1点和第4点是枚举最大的优势类型,所以我们通常定义常量的时候建议大家多使用枚举类型，而不是使用传统的常量数字</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常量指的就是计算机中不可改变的量。比如一年中有四个季节，彩虹有七种原色，这些都是固定的值，也就是所谓的常量&lt;/p&gt;
&lt;p&gt;在Java中我们通过使用final关键字来创建常量&lt;/p&gt;
&lt;p&gt;但是这种方式创建出的常量仍然存在一些弊端，所以JDK1.5中就新增了枚举的概念&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
</feed>
