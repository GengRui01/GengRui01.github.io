<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>耿锐的博客</title>
  
  <subtitle>欢迎的来到耿锐的技术小栈</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.gengruiblog.cn/"/>
  <updated>2021-10-05T07:27:15.101Z</updated>
  <id>https://www.gengruiblog.cn/</id>
  
  <author>
    <name>耿锐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言数据类型转换</title>
    <link href="https://www.gengruiblog.cn/article/20210925.html"/>
    <id>https://www.gengruiblog.cn/article/20210925.html</id>
    <published>2021-09-24T16:00:00.000Z</published>
    <updated>2021-10-05T07:27:15.101Z</updated>
    
    <content type="html"><![CDATA[<p>C语言规定，不同类型的数据进行运算时要先转换成相同类型的数据才能进行运算</p><p>数据类型转换就是将数据（变量、数值、表达式的结果等）从一种类型转换为另一种类型</p><p>数据类型的各种转换只影响表达式的运算结果，并不改变原变量的定义类型，并且其数据值也不会发生任何改变</p><a id="more"></a><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>自动类型转换就是编译器默默地、隐式地、偷偷地进行的数据类型转换</p><p>这种转换不需要程序员干预，会由C语言编译系统自动完成</p><p>转换规则是：</p><p>把占用内存空间少的（低级）类型向占用空间多的（高级）类型转换，以保证运算的精度</p><p><img src="https://gengrui01.github.io/picture/c-datatype-conversion/1.png" alt=""></p><ul><li>图中的纵向箭头表示必定的转换</li><li>图中的横向箭头表示当经过纵向的转换后，进行运算的数据类型仍然不同时进行的转换方式</li></ul><blockquote><p>例：若有定义“double d=153;int i=10;float f=3.8;”，则表达式d+’a’+i*d/f的值的类型是<strong>___</strong>。</p></blockquote><p>分析：</p><ol><li>将int型变量i和float型变量f转换为double型后，进行i*d/f的运算，结果为double型。</li><li>将char型常量’a’转换为int型，进行d+’a’的计算，此时“+”左右两边数据的类型不同，则再将int型转换为double型，进行加法运算，结果为double型。</li><li>将（1）的结果和（2）的结果进行加法计算，最终结果为double型</li></ol><blockquote><p>自动类型转换示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="keyword">int</span> s1, r = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">double</span> s2;</span><br><span class="line">    s1 = r * r * PI;</span><br><span class="line">    s2 = r * r * PI;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s1=%d, s2=%f\n"</span>, s1, s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：s1=78, s2=78.539749</p><p>分析：</p><ul><li>在计算表达式r<em>r</em>PI时，r 和 PI 都被转换成 double 类型，表达式的结果也是 double 类型</li><li>但由于 s1 为整型，所以赋值运算的结果仍为整型，舍去了小数部分，导致数据失真</li></ul><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>采用强制类型转换运算符将某种数据类型强制转换成指定的数据类型</p><p>其一般形式为：</p><p><code>(类型说明符)(表达式)</code></p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">float</span>) a;  <span class="comment">/* 将变量 a 转换为 float 类型 */</span></span><br><span class="line">(<span class="keyword">int</span>)(x+y);  <span class="comment">/* 把表达式 x+y 的结果转换为 int 整型 */</span></span><br><span class="line">(<span class="keyword">float</span>) <span class="number">100</span>;  <span class="comment">/* 将数值 100（默认为int类型）转换为 float 类型 */</span></span><br></pre></td></tr></table></figure><blockquote><p>例：强制类型转换示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">    c=(<span class="keyword">float</span>)(a+b)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%f\n"</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：c=3.500000</p><p><strong><em>TIPS:</em></strong> </p><blockquote><p>需强制类型转换中的表达式一定要括起来，否则只对紧随括号后的量进行类型转换<br>强制类型转换是一种不安全的转换，如果是从高级类型转换成低级类型，则会损失数据的精度</p></blockquote><h2 id="类型转换只是临时性的"><a href="#类型转换只是临时性的" class="headerlink" title="类型转换只是临时性的"></a>类型转换只是临时性的</h2><p>无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换</p><p>转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值</p><blockquote><p>例如：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">400.8</span>;  <span class="comment">/* 总价 */</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">5</span>;  <span class="comment">/* 数目 */</span></span><br><span class="line">    <span class="keyword">double</span> unit;  <span class="comment">/* 单价 */</span></span><br><span class="line">    <span class="keyword">int</span> total_int = (<span class="keyword">int</span>)total;</span><br><span class="line">    unit = total / count;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total=%lf, total_int=%d, unit=%lf\n"</span>, total, total_int, unit);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>total=400.800000, total_int=400, unit=80.160000</p><p>分析：</p><ul><li>第 6 行代码，total 变量被转换成了 int 类型才赋值给 total_int 变量</li><li>而这种转换并未影响 total 变量本身的类型和值</li><li>如果 total 的值变了，那么 total 的输出结果将变为 400.000000</li><li>如果 total 的类型变了，那么 unit 的输出结果将变为 80.000000</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言规定，不同类型的数据进行运算时要先转换成相同类型的数据才能进行运算&lt;/p&gt;
&lt;p&gt;数据类型转换就是将数据（变量、数值、表达式的结果等）从一种类型转换为另一种类型&lt;/p&gt;
&lt;p&gt;数据类型的各种转换只影响表达式的运算结果，并不改变原变量的定义类型，并且其数据值也不会发生任何改变&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.gengruiblog.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言运算符和表达式</title>
    <link href="https://www.gengruiblog.cn/article/20210924.html"/>
    <id>https://www.gengruiblog.cn/article/20210924.html</id>
    <published>2021-09-23T16:00:00.000Z</published>
    <updated>2021-09-26T07:18:08.985Z</updated>
    
    <content type="html"><![CDATA[<p>C语言中，运算符和表达式数量之多，在其他高级语言中是很少见的</p><p>正是丰富的运算符和表达式使C语言功能十分完善，这也是C语言的特点之一</p><p>本文介绍其中的一部分运算符，其他的运算符将陆续在后续各文中讲述</p><a id="more"></a><h2 id="赋值运算符和赋值表达式"><a href="#赋值运算符和赋值表达式" class="headerlink" title="赋值运算符和赋值表达式"></a>赋值运算符和赋值表达式</h2><p>赋值运算符有“=”、“+=”、“-=”、“*=”、“/=”和“%=”等</p><p>用赋值运算符将运算对象连接而成的表达式称为赋值表达式</p><h3 id="简单赋值运算符"><a href="#简单赋值运算符" class="headerlink" title="简单赋值运算符"></a>简单赋值运算符</h3><p>将“=”右边表达式的值赋给左边的变量</p><p>例如： <code>a=8;</code>、 <code>s=a*2+b;</code></p><p>先计算出右边表达式的值，再赋给左边的变量。如果“=”左右两边类型不同，系统会按照赋值类型转换的原则将右边的类型转换成左边的类型</p><h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p>在简单赋值运算符前面加上算术运算符就构成复合算术赋值运算符，如下表所示：</p><table><thead><tr><th>运算符</th><th>应用举例</th><th>等价形式</th></tr></thead><tbody><tr><td>+=</td><td>a+=x</td><td>a=a+(x)</td></tr><tr><td>-=</td><td>a-=x</td><td>a=a-(x)</td></tr><tr><td>*=</td><td>a*=x</td><td>a=a*(x)</td></tr><tr><td>/=</td><td>a/=x</td><td>a=a/(x)</td></tr><tr><td>%=</td><td>a%=x</td><td>a=a%(x)</td></tr></tbody></table><h3 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h3><p>由赋值运算符将一个变量和一个表达式连接起来的式子所组成。一般形式为：<code>变量 = 表达式</code></p><p>下面是赋值表达式的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v=<span class="number">4.0</span>*PI*r*r*r/<span class="number">3.0</span></span><br><span class="line">a=<span class="number">15</span>+(i=<span class="number">6</span>)</span><br><span class="line">b=(x=<span class="number">3</span>)+(y=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>而 <code>3=x</code> 和 <code>a+b=4</code> 都是错误的赋值表达式</p><p>赋值表达式的执行过程是：</p><ol><li>计算赋值运算符右侧表达式的值；</li><li>将所计算出的值赋给赋值运算符左侧的变量</li></ol><p><strong><em>TIPS:</em></strong></p><blockquote><p>赋值运算符的左边只能是变量，不能是常量或表达式<br>赋值表达式的值就是赋值运算符左边变量的值<br>赋值表达式的右边也可以是一个赋值表达式</p></blockquote><p>如下例题：</p><blockquote><p>例：若有定义“int x=15,a,b;”，则表达式“x%=(a=3)+(b=4)”的值是 ?</p></blockquote><p>答案：</p><ul><li>x%=(a=3)+(b=4)</li><li>x%=3+4</li><li>x%=7</li><li>x=x%7</li><li>x=15代入得：</li><li>x=15%7=1</li></ul><blockquote><p>例：已有声明“int x=15, y; float z=12;”，下列表达式中语法正确的是        。<br>A．y=x%z<br>B．y=x+=z*=4<br>C．y=x/2=z<br>D．(y=x+3)=z/2</p></blockquote><p>答案：B</p><h2 id="算数运算符和算数表达式"><a href="#算数运算符和算数表达式" class="headerlink" title="算数运算符和算数表达式"></a>算数运算符和算数表达式</h2><h3 id="基本的算术运算符"><a href="#基本的算术运算符" class="headerlink" title="基本的算术运算符"></a>基本的算术运算符</h3><table><thead><tr><th>运算符</th><th>+</th><th>-</th><th>*</th><th>/</th><th>%</th></tr></thead><tbody><tr><td>名称</td><td>加</td><td>减</td><td>乘</td><td>除</td><td>取余</td></tr></tbody></table><p><strong><em>TIPS:</em></strong></p><blockquote><p>两个整型数据做除法运算时，结果一定是整数<br>求余运算的结果是两个整型数据相除的余数。求余运算只能用于整型数据的运算<br>算数运算符两边的数据类型应相同，若不同时，编译系统会先转换为同一数据类型，然后再进行运算</p></blockquote><h3 id="单目运算符"><a href="#单目运算符" class="headerlink" title="单目运算符"></a>单目运算符</h3><ul><li><code>-</code> 负号：负数</li><li><code>++</code> 自增运算符：使变量的值自加1</li><li><code>--</code> 自减运算符：使变量的值自减1</li></ul><p>有两种使用形式：</p><ul><li>前缀方式：用于变量前面，它是 <strong>“先计算，后使用”</strong> </li><li>后缀方式：用于变量后面，它是 <strong>“先使用，后计算”</strong> </li></ul><blockquote><p>例：设有定义如下：<br>#define d 2<br>int x=5;<br>float y=3.83;<br>char c=’d’;<br>分析以下各表达式使用正确与否：<br>A．(-x)++<br>B．y++<br>C．c++<br>D．d++</p></blockquote><p>答案：A错  B对  C对  D错</p><h3 id="算术运算符的优先级和结合性"><a href="#算术运算符的优先级和结合性" class="headerlink" title="算术运算符的优先级和结合性"></a>算术运算符的优先级和结合性</h3><ol><li>单目运算符的优先级高于双目运算符</li><li>双目算术运算符中*、/、%的优先级高于+、-</li><li>在优先级相同的情况下，按规定的“结合方向”进行处理</li></ol><h3 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h3><ul><li>算术表达式是由算术运算符、运算对象和括号连接起来的式子</li><li>所有的数学表达式均可写成C语言的算术表达式，但是有些数学表达式无法直接用C语言的算术表达式写出，此时需要调用C语言中的数学函数来实现</li></ul><p><strong><em>TIPS:</em></strong></p><blockquote><p>表达式中的乘号不能省略，且表达式中的所有字符均应写在同一行上<br>在表达式中还可以使用多层圆括号（不能使用中括号[]和花括号{}），但是要注意括号的配对<br>在数学中，5×6÷4的运算结果与6÷4×5的结果相同，都是 7.5，但是C语言中表达式5<em>6/4的结果却与6/4</em>5的结果不一样<br>还需注意 8/(8/10)之类的表达式，因为(8/10)的结果为 0，用0做除数将会出现运算溢出的错误，为了不使 8/10 的结果为 0，应将整型常量改为实型常量8.0/10</p></blockquote><p>举个例子：</p><blockquote><p>例：输入一个三位正整数，输出其反序数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">456</span>;</span><br><span class="line">    <span class="keyword">int</span> a = number / <span class="number">100</span>; <span class="comment">/* 计算百位数 */</span></span><br><span class="line">    <span class="keyword">int</span> b = (number - a * <span class="number">100</span>) / <span class="number">10</span>;<span class="comment">/* 计算十位数 */</span></span><br><span class="line">    <span class="keyword">int</span> c = number % <span class="number">10</span>;<span class="comment">/* 计算个位数 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"反序数是:%d%d%d\n"</span>, c, b, a); <span class="comment">/* 输出*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：反序数是:321</p><h2 id="逗号运算符和逗号表达式"><a href="#逗号运算符和逗号表达式" class="headerlink" title="逗号运算符和逗号表达式"></a>逗号运算符和逗号表达式</h2><p>逗号运算符（,）：功能是把多个表达式连接起来组成一个表达式，称为逗号表达式</p><p>逗号表达式的一般形式为： </p><p>表达式1，表达式2，…，表达式n</p><ol><li>逗号表达式的执行顺序：从左到右依次执行每个表达式</li><li>逗号表达式的值为“表达式n”的值</li><li>逗号运算符是双目运算符，其优先级最低，是左结合的</li><li>并非所有出现逗号的地方都可以作为逗号表达式，如<code>printf(&quot;%d%d&quot;,&amp;a,&amp;b)</code>，其中的 <code>&quot;%d%d&quot;,&amp;a,&amp;b</code> 并不是一个逗号表达式，而是<code>printf</code>函数的参数</li></ol><blockquote><p>例：逗号表达式应用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j=<span class="number">7</span>;</span><br><span class="line"><span class="keyword">float</span> k=<span class="number">5</span>;</span><br><span class="line">i=(j=j+<span class="number">2</span>,j/k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i=%d\n"</span>,i);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：i=1</p><h2 id="求字节数运算符"><a href="#求字节数运算符" class="headerlink" title="求字节数运算符"></a>求字节数运算符</h2><p>sizeof(…)：是一个单目运算符，用于计算数据类型所占的字节数，其一般格式为：</p><ol><li>sizeof(表达式)或sizeof 表达式</li><li>sizeof(数据类型名)</li></ol><blockquote><p>例：不同数据类型字节数示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char类型占%d字节\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"short int类型占%d字节\n"</span>,<span class="keyword">sizeof</span>(short <span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"int类型占%d字节\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float类型占%d字节\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"double类型占%d字节\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><ul><li>char类型占1字节</li><li>short int类型占2字节</li><li>int类型占4字节</li><li>float类型占4字节</li><li>double类型占8字节</li></ul><blockquote><p>例：求字节数运算符示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">a=<span class="keyword">sizeof</span>(<span class="number">3</span>+<span class="number">5.0</span>);</span><br><span class="line">b=<span class="keyword">sizeof</span> <span class="number">3</span>+<span class="number">5.0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d,%d\n"</span>,a,b,<span class="keyword">sizeof</span>(<span class="string">"china"</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：8,9,6</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言中，运算符和表达式数量之多，在其他高级语言中是很少见的&lt;/p&gt;
&lt;p&gt;正是丰富的运算符和表达式使C语言功能十分完善，这也是C语言的特点之一&lt;/p&gt;
&lt;p&gt;本文介绍其中的一部分运算符，其他的运算符将陆续在后续各文中讲述&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.gengruiblog.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言数据类型、变量和常量</title>
    <link href="https://www.gengruiblog.cn/article/20210923.html"/>
    <id>https://www.gengruiblog.cn/article/20210923.html</id>
    <published>2021-09-22T16:00:00.000Z</published>
    <updated>2021-09-24T00:48:59.138Z</updated>
    
    <content type="html"><![CDATA[<p>通常在学习程序设计语言的初期，要从基本要素入手，逐步掌握语言的各种语法规则</p><p>就好比造一座大厦，基础没有打好基于往上盖，其后果可想而知</p><p>所以要想熟练的使用C语言进行程序设计是一个循序渐进的过程</p><p>这篇文章开始我们会写一些C语言代码，循序渐进的掌握C语言的语法规则</p><a id="more"></a><h2 id="简单代码运行"><a href="#简单代码运行" class="headerlink" title="简单代码运行"></a>简单代码运行</h2><blockquote><p>代码1：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                     </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"HelloWorld!"</span>);   </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>#include &lt;stdio.h&gt;</code>：stdio.h为系统文件，内部定义了printf()等方法，在程序最开始可以使用include将头文件引入进来</li><li><code>int main(void)</code>：在一个C程序中有且仅有一个main()函数，他是程序运行的入口，main函数前面表示的是程序的返回值类型，后面表示的是传入参数，这里传入参数为void，也就是为空（可省略），返回参数是int类型</li><li><code>printf(&quot;HelloWorld!&quot;);</code>：此处调用了标准输出函数，会将引号中的内容输出到屏幕上，语句后的分号表示该语句的结束</li><li><code>return()</code> 语句可以就结束程序，一般返回0表示程序运行正常，返回其他值则表示不同的错误情况</li></ul><blockquote><p>代码2：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Programming is fun.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"And Programming in C is even more fun!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>\n</code>：换行符，表示在输出“Programming is fun.”后换行，<code>\n</code>是转义字符，在本章节会介绍</li></ul><blockquote><p>代码3：输入半径，分别计算球体积和球表面积</p></blockquote><p>设球半径为r、球体积为v、球表面积为f，球体积和球表面积的计算公式如下：</p><p><img src="https://gengrui01.github.io/picture/c-datatype-constant-varibles/1.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">float</span> v,f;</span><br><span class="line">    r=<span class="number">2</span>;</span><br><span class="line">    v=<span class="number">4.0</span>*PI*r*r*r/<span class="number">3.0</span>;</span><br><span class="line">    f=<span class="number">4.0</span>*PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"体积为：%f，表面积为：%f\n"</span>,v,f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>#define PI 3.14159</code>：定义一个符号常量PI，这样程序中凡是需要使用3.14159的地方都可以用PI代替</li><li><code>void main()</code>：main函数前面表示的是程序的返回值类型，后面表示的是传入参数，这里传入参数为空被省略了，返回参数也是空，也可以被省略</li><li><code>%f</code>：会将printf引号内除了<code>%f</code>之外的内容原样输出，并在第一个<code>%f</code>上输出v的值，在第二个<code>%f</code>上输出f的值</li></ul><h2 id="C语言的数据类型"><a href="#C语言的数据类型" class="headerlink" title="C语言的数据类型"></a>C语言的数据类型</h2><p><img src="https://gengrui01.github.io/picture/c-datatype-constant-varibles/2.png" alt=""></p><h2 id="C语言的常量"><a href="#C语言的常量" class="headerlink" title="C语言的常量"></a>C语言的常量</h2><p>常量是指在程序运行的过程中值不能被改变的量</p><h3 id="直接常量"><a href="#直接常量" class="headerlink" title="直接常量"></a>直接常量</h3><p><strong>1. 整数常量</strong></p><ul><li>十进制表示：由数字0～9，正、负号组成</li><li>八进制表示：以0（数字0）为前缀，其后由数字0～7组成；八进制数一般是无符号数</li><li>十六进制表示：以0x或0X为前缀，其后由数字0～9和字母A～F（字母大小写均可）组成，十六进制数一般是无符号数</li></ul><p><strong>2. 实型常量</strong></p><p>实型常量即实数，又称为浮点数。</p><p>C语言中，实数只能用十进制形式表示，实数的表示方法有两种：小数形式和指数形式。</p><ul><li>小数形式：如12.345，3.，-.123。</li><li>指数形式：由尾数部分、字母E或e和指数部分组成，格式为：±尾数E指数</li></ul><p><strong><em>TIPS:</em></strong></p><blockquote><p>(1) 以小数形式表示实数时，必须有小数点，并且小数点的前、后至少一边要有数字。<br>(2) 以指数形式表示实数时，字母E (或e)的前后必须有数字，并且指数部分只能是整数。如12.-E3、1.5E、E6都是不正确的实数。</p></blockquote><p><strong>3. 字符型常量</strong></p><ul><li>(1) 字符常量只能用单引号括起来，不能用双引号或其它括号。</li><li>(2) 字符常量只能是单个字符，不能是多个字符组成的字符串。</li><li>(3) 字符可以是ASCII字符集中的任意字符。按ASCII码的大小，不同的字符之间存在着次序，以字符的ASCII码值按升序连续排列。</li><li>(4) 对于控制符（如回车、换行等）与不可见字符，在C语言中通过转义字符来表示。</li></ul><p><strong><em>常见转义字符:</em></strong></p><table><thead><tr><th>转义字符</th><th>转义功能</th><th>ASCII码值</th></tr></thead><tbody><tr><td>\0</td><td>空字符</td><td>0</td></tr><tr><td>\a</td><td>响铃</td><td>7</td></tr><tr><td>\b</td><td>退格（Backspace）</td><td>8</td></tr><tr><td>\t</td><td>水平制表符（横向跳格）</td><td>9</td></tr><tr><td>\n</td><td>回车换行（Enter）</td><td>10</td></tr><tr><td>\v</td><td>竖向跳格</td><td>11</td></tr><tr><td>\f</td><td>换页</td><td>12</td></tr><tr><td>\r</td><td>回车</td><td>13</td></tr><tr><td>&quot;</td><td>双引号（”）</td><td>34</td></tr><tr><td>&#39;</td><td>单引号（’）</td><td>39</td></tr><tr><td>?</td><td>问号（?）</td><td>63</td></tr><tr><td>\</td><td>反斜线字符（\）</td><td>92</td></tr><tr><td>\ddd</td><td>1~3位八进制所代表的字符</td><td></td></tr><tr><td>\xhh</td><td>1~2位十六进制所代表的字符</td><td></td></tr></tbody></table><blockquote><p>转义字符的使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> b,c,d,e;</span><br><span class="line">    b='\43';</span><br><span class="line">    c=<span class="string">'\103'</span>;</span><br><span class="line">    d=<span class="string">'\x2a'</span>;</span><br><span class="line">    e=<span class="string">'\x41'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b=%c,c=%c,d=%c,e=%c\n"</span>,b,c,d,e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\"good\0morning!\b\"!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\123456"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>b=#,c=C,d=*,e=A<br>“good morning”!<br>S456</p><p><strong>4. 字符串常量</strong></p><p>字符串常量是由一对双引号””括起来的零个或多个字符序列，如：”HelloWorld”</p><p>字符串中可以使用空格字符、转义字符和其他字符，也可以使用汉字等文字符号</p><p>字符串中还可以使用空字符，如：”” 表示空串，即不包含任何字符</p><p>注意：</p><ul><li>系统自动在每个字符串的尾部加上’\0’作为字符串的结束标志<ul><li>n个字符组成的字符串，在内存中要占用n+1个字节空间</li><li>可以使用sizeof运算符来计算字符串占用的内存空间大小</li></ul></li><li>字符串的长度等于该字符串中所包含的有效字符的个数<ul><li>在字符串中如遇到’\0’则认为该字符串结束</li><li>如果字符串中有转义字符，则一个转义字符作为一个字符</li><li>可以使用strlen()函数计算字符串的长度</li></ul></li><li>字符常量和字符串常量在内存中的存储情况是不同的<ul><li>如’6’在内存中占1个字节，存储的是其ASCII码</li><li>“6”在内存中占2个字节，一个字节存储’6’，一个字节存储’\0’</li></ul></li></ul><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p>在C语言中，可以用一个标识符来表示一个常量，称之为符号常量</p><p>符号常量在使用之前必须先定义，其一般形式为：</p><p><strong>#define 标识符 常量值</strong></p><p>一个#define命令只能定义一个符号常量，若要定义多个符号常量，需使用多个#define命令</p><blockquote><p>例：某程序需要使用一个代表常数3.145的符号常量名xp，则以下定义中正确的是          。<br>A．#define xp 3.145;<br>B．#define xp(3.145)<br>C．#define xp=3.145<br>D．#define xp 3.145</p></blockquote><p>答案：D</p><blockquote><p>例：已知某程序如下：<br>#define P 2.5<br>void main( )<br>{<br>    printf(“%f”, P);<br>}<br>则main函数中标识符P代表的操作数是<strong>____</strong>。</p></blockquote><p>答案：2.5</p><blockquote><p>例：利用符号常量计算价格</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRICE 20</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num,total;</span><br><span class="line">    num=<span class="number">10</span>;</span><br><span class="line">    total=num* PRICE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"总价格为：%d\n"</span>,total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>总价格为：200</p><p><strong>符号常量的使用，可以为编写程序提供很多好处：</strong></p><ul><li>增加程序的可读性</li><li>提高程序的可维护性</li><li>简化程序代码</li><li>方便数组的定义</li></ul><h2 id="C语言的变量"><a href="#C语言的变量" class="headerlink" title="C语言的变量"></a>C语言的变量</h2><p>在程序的运行过程中，其值可以被改变的量称为变量</p><p>变量用于从外部接收数据、保存一些不断变化的值、保存中间结果及最终结果，而这些都无法用常量来实现</p><h3 id="变量的定义与使用"><a href="#变量的定义与使用" class="headerlink" title="变量的定义与使用"></a>变量的定义与使用</h3><p><strong>1. 变量的定义</strong></p><p><code>[存储类型] 类型说明符 变量名；</code></p><ul><li>定义四个静态的整型变量a,b,c,d：<code>static int a,b,c,d;</code></li><li>定义两个字符型变量ch1,ch2：<code>char ch1,ch2;</code></li><li>定义一个单精度浮点数变量f：<code>float f;</code></li></ul><p><strong><em>TIPS:</em></strong></p><ol><li>类型说明符必须是C语言中的有效数据类型，如int、float、double、char等，用于指定变量的类型，该类型决定了编译时分配给变量的内存单元的多少</li><li>变量名表可以由一个或多个变量名组成，各变量名之间用“，”分隔。变量名必须是合法的C语言标识符，变量名一般使用小写字母</li><li>变量的定义必须放在变量的使用之前，一般在函数体的开头部分进行定义</li></ol><p><strong>2. 变量的初始化</strong></p><p>C语言允许在定义变量的同时对变量赋值，这个过程称为变量的初始化</p><ul><li>定义一个整型变量x并赋初值为2：<code>int x=2;</code></li><li>定义两个整型变量s和t，分别赋初值为1：<code>int s=1,t=1;</code></li><li>定义一个单精度型变量f并赋初值为3.68：<code>float f =3.68;</code></li><li>定义一个字符型变量ch并赋初值为字符x：<code>char ch=&#39;x&#39;;</code></li></ul><p><strong><em>TIPS:</em></strong></p><ul><li>对一个变量赋初值之后，该值被存储在分配给该变量的内存空间中</li><li>不允许对多个未定义的同类型变量连续初始化</li><li>初始化时，“=”右边表达式的数据类型和“=”左边的变量的类型如果不一致，系统会进行自动赋值转换</li><li>没有进行初始化的变量，其值是由定义时所使用的存储类型决定的</li></ul><ol start="3"><li>变量的使用</li></ol><p>变量应该先赋值，后引用</p><blockquote><p>例：变量使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="string">'A'</span>;</span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    b=a+ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d,%c\n"</span>,a,b,c,ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>若程序运行时输入：<br>10↙<br>则程序的运行结果如下：<br>10,75,10,A</p><h3 id="整形变量"><a href="#整形变量" class="headerlink" title="整形变量"></a>整形变量</h3><p>Visual C++ 2010环境下，各种整型的关键字及占用内存字节数和取值范围如下表：</p><table><thead><tr><th>关键字</th><th>类型</th><th>占用字节数</th><th>取值范围</th></tr></thead><tbody><tr><td>short int</td><td>短整型</td><td>2</td><td>-32768~32767</td></tr><tr><td>int</td><td>整型</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>long int</td><td>长整型</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>unsigned short</td><td>无符号短整型</td><td>2</td><td>0~65535</td></tr><tr><td>unsigned int</td><td>无符号整型</td><td>4</td><td>0~4294964295</td></tr><tr><td>unsigned long</td><td>无符号长整型</td><td>4</td><td>0~4294964295</td></tr></tbody></table><p><strong><em>TIPS:</em></strong></p><ul><li>各种无符号整数所占的字节数与相应的有符号整数相同。但由于省去了符号位，故不能表示负数。</li><li>有符号整数以二进制补码形式存储。最左边第1位表示符号，该位为0，表示正数，该位为1，表示负数。</li><li>无符号整数以二进制原码形式存储。</li></ul><blockquote><p>例：不同类型整型变量的定义与使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> e;</span><br><span class="line">    a=<span class="number">5</span>;b=<span class="number">6</span>;e=<span class="number">10</span>;</span><br><span class="line">    c=a+e;</span><br><span class="line">    d=b+e;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%d,d=%d\n"</span>,c,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>c=15,d=16</p><blockquote><p>例：短整型变量的溢出</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    short <span class="keyword">int</span> a, b;</span><br><span class="line">    a = <span class="number">32767</span>;</span><br><span class="line">    b = a + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d, b=%d\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>a=32767,b=-32768</p><h3 id="实型变量"><a href="#实型变量" class="headerlink" title="实型变量"></a>实型变量</h3><p>实型的关键字及占用内存字节数和取值范围如表所示：</p><table><thead><tr><th>关键字</th><th>类型</th><th>占用字节数</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>单精度型</td><td>4</td><td>3.4E-38~3.4E+38</td></tr><tr><td>double</td><td>双精度型</td><td>8</td><td>1.7E-308~1.7E+308</td></tr></tbody></table><ul><li>单精度型数据能保留7位有效数字</li><li>双精度型数据能保留16位有效数字</li></ul><blockquote><p>例：实型变量的使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a=<span class="number">1234.56789</span>;</span><br><span class="line">    <span class="keyword">double</span> b=<span class="number">1234.567895678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%f,b=%f\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>a=1234.567871,b=1234.567896</p><h3 id="字符型变量"><a href="#字符型变量" class="headerlink" title="字符型变量"></a>字符型变量</h3><ul><li>字符型变量的值是字符常量，即用单引号引起来的单个字符</li><li>字符型变量的类型说明符是char，其类型说明的格式和命名规则与整型变量相同</li></ul><p><strong><em>TIPS:</em></strong></p><blockquote><p>由于字符常量在内存中占用一个字节，用于存储它的ASCII码值<br>所以C语言中的字符具有数值特征，可以像整数一样参加运算<br>允许对整型变量赋以字符值，也允许对字符变量赋以整型值。</p></blockquote><p>举个例子：</p><blockquote><p>例：字符变量的使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c1,c2;</span><br><span class="line">    c1=<span class="string">'A'</span>;</span><br><span class="line">    c2=<span class="number">65</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c,%c\n"</span>,c1,c2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,c1,c2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>A,A<br>65,65</p><blockquote><p>例：字符变量的使用示例</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c1,c2;</span><br><span class="line">    c1=<span class="string">'A'</span>;</span><br><span class="line">    c2=<span class="string">'B'</span>;</span><br><span class="line">    c1=c1+<span class="number">32</span>;</span><br><span class="line">    c2=c2+<span class="number">32</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c,%c\n"</span>,c1,c2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,c1,c2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>a,b<br>97,98</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常在学习程序设计语言的初期，要从基本要素入手，逐步掌握语言的各种语法规则&lt;/p&gt;
&lt;p&gt;就好比造一座大厦，基础没有打好基于往上盖，其后果可想而知&lt;/p&gt;
&lt;p&gt;所以要想熟练的使用C语言进行程序设计是一个循序渐进的过程&lt;/p&gt;
&lt;p&gt;这篇文章开始我们会写一些C语言代码，循序渐进的掌握C语言的语法规则&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.gengruiblog.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言程序设计的特点及运行方式</title>
    <link href="https://www.gengruiblog.cn/article/20210922.html"/>
    <id>https://www.gengruiblog.cn/article/20210922.html</id>
    <published>2021-09-21T16:00:00.000Z</published>
    <updated>2021-09-17T00:46:35.407Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章有讲到C语言是一门结构化语言，还讲了我们写代码需要先用文字描述算法、再用流程图、之后伪代码、最后再写代码</p><p>这篇文章C语言的发展历史、特点、语法，以及如何将代码一步步运行出结果</p><a id="more"></a><h2 id="C语言的发展历史"><a href="#C语言的发展历史" class="headerlink" title="C语言的发展历史"></a>C语言的发展历史</h2><ul><li>1963年英国剑桥大学推出了CPL（Combined Programming Language）语言。 </li><li>1967年剑桥大学的Martin Richards对CPL语言进行了简化，推出了BCPL（Basic Combined Programming Language）语言。 </li><li>1970年美国贝尔实验室的Ken Thompson对BCPL语言又做了进一步简化，设计出了更接近硬件的B语言。</li><li>1972年工作于美国贝尔实验室的Dennis Ritchie在B语言的基础上设计出C语言。  </li><li>1973年，Dennis Ritchie和Ken Thompson对UNIX操作系统进行了重写，其中90%以上的代码采用的是C语言，很大程度上提高了UNIX操作系统的可移植性和可读性。 </li><li>1983年，美国国家标准协会（American National Standards Institute，简称ANSI）制定了一套C语言标准，称为ANSI C。 </li><li>目前使用的如Microsoft C、Turbo C等版本均以ANSI C为标准，同时各自分别进行了一些扩充。本书使用的主要是Turbo C编译系统。</li></ul><h2 id="C语言的特点"><a href="#C语言的特点" class="headerlink" title="C语言的特点"></a>C语言的特点</h2><p><strong>优点：</strong></p><ol><li>C语言语句简洁紧凑，使用方便灵活</li><li>运算符丰富，表达能力强</li><li>C语言程序可移植性好</li><li>生成的目标代码质量高，运行效率高</li><li>语言处理能力强</li><li>C语言是一种结构化语言</li></ol><p><strong>缺点：</strong></p><p>C语言对语法检查不严格，许多时候需要程序员自己保证程序的正确，而这对初学者是很难做到的。</p><p>例如，数据类型检查不严格，表达式运算会出现二义性；对数组下标越界不检查，导致程序出错。</p><p>除此之外，由于C语言运算符较多，初学者很难掌握其运算的优先级与结合性。 </p><h2 id="C语言的语法"><a href="#C语言的语法" class="headerlink" title="C语言的语法"></a>C语言的语法</h2><h3 id="C语言中的约定"><a href="#C语言中的约定" class="headerlink" title="C语言中的约定"></a>C语言中的约定</h3><ol><li>标识符</li></ol><ul><li>由字母、数字和下划线组成，其中第一个字符必须是字母或下划线<ul><li>例如，_00、print、FOR均是合法的标识符，而&amp;a、-123、a b均是不合法的标识符。</li></ul></li><li>英文字母的大小写是有区别的</li><li>命名最好做到“见名知义”，增加程序的可读性</li><li>标识符的有效长度为1~255个字符</li></ul><ol start="2"><li>关键字</li></ol><table><thead><tr><th>类别</th><th>关键字</th></tr></thead><tbody><tr><td>数据类型关键字（12个）</td><td>char，double，enum，float，int，long，short，signed，struct，union，unsigned，void</td></tr><tr><td>控制语句关键字（12个）</td><td>break，continue，case，do，default，else，for，goto，if，return，switch，while</td></tr><tr><td>存储类型关键字（4个）</td><td>auto，extern，register，static</td></tr><tr><td>其它关键字（4个）</td><td>const，sizeof，typedef，volatile</td></tr></tbody></table><ol start="3"><li>用户自定义标识符:</li></ol><p>程序中定义的变量名、数据类型名、函数名和符号常量名</p><ol start="4"><li>预定义标识符</li></ol><p>头文件和库函数中定义的一些标识符（例如scanf、printf等）</p><ol start="5"><li>分隔符：</li></ol><ul><li>逗号：分隔变量名</li><li>空格：分隔各单词</li></ul><h3 id="C语言的语法成分"><a href="#C语言的语法成分" class="headerlink" title="C语言的语法成分"></a>C语言的语法成分</h3><ol><li>常量</li></ol><p>常量是有数据类型的，例如，整型常量2、实型常量2.0、字符型常量’2’ 、字符串常量”C Programming.”等。</p><ol start="2"><li>变量</li></ol><p>变量定义的一般形式是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 变量名;</span><br></pre></td></tr></table></figure><p>例如，例1.1中的 <code>int a,b,c;</code> 定义了三个整型变量。</p><ol start="3"><li>运算符</li></ol><ul><li>算术运算符：+（加）、-（减）、*（乘）、/（除）、%（求余）；</li><li>关系运算符：&gt;（大于）、&gt;=（大于等于）、==（等于）、&lt;（小于）、&lt;=（小于等于）等等。</li></ul><p>参与运算时只要求有一个数据对象的称为单目运算符，有两个数据对象的称为双目运算符，有三个数据对象的称为三目运算符。</p><ol start="4"><li>表达式</li></ol><p>运算符有优先级，例如，表达式 <code>b*b-4*a*c&gt;0</code> 中，由于算术运算优先于关系运算，所以先计算 <code>b*b-4*a*c</code> ，再做关系比较运算 <code>&gt;</code> 。</p><ol start="5"><li>语句</li></ol><p>在C语言中，语句是程序最基本的执行单位，以分号结尾。</p><ol start="6"><li>函数定义与调用</li></ol><p>函数十完成特定功能的小模块，是C语言中唯一的种子程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>    <span class="comment">/* 求最大值的函数*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z;              <span class="comment">/* 定义临时变量z */</span></span><br><span class="line"><span class="keyword">if</span>(x&gt;y)</span><br><span class="line">z=x;            <span class="comment">/* x&gt;y时，z的值等于x */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">z=y;            <span class="comment">/* 否则，z的值等于y */</span></span><br><span class="line"><span class="keyword">return</span> z;           <span class="comment">/* 结束函数，返回z */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>输入与输出</li></ol><p>C语言没有提供用于数据输入及输出的语句，所有的输入与输出都是通过系统提供的有关函数（如scanf()和printf()函数）来实现的。</p><h2 id="C程序的编辑、编译、链接、运行"><a href="#C程序的编辑、编译、链接、运行" class="headerlink" title="C程序的编辑、编译、链接、运行"></a>C程序的编辑、编译、链接、运行</h2><p><img src="https://gengrui01.github.io/picture/c-features-operation/1.png" alt=""></p><ol><li>编辑：将编写的C语言代码以文件的形式存储在计算机中，其拓展名为 <strong><em>.c</em></strong></li><li>编译：通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成二进制目标程序文件，其拓展名为 <strong><em>.obj</em></strong></li></ol><ul><li>编译过程中的错误多为词法和语法错误，如果原文件存在这些错误，则编译系统会给出错误提示信息，应根据错误提示信息查找错误并改正源程序，再次重新编译，直到没有错误</li></ul><ol start="3"><li>链接：将目标程序与系统提供的库函数或是其他目标程序进行链接，得到最终的二进制可执行文件，其拓展名为 <strong><em>.exe</em></strong></li><li>运行：双击 <strong><em>.exe</em></strong> 可执行文件运行后结果会显示在屏幕上</li></ol><ul><li>可执行文件运行后要验证程序的运行结果，如果发现运行结果与设计目的不相符（通常称为逻辑错误），说明程序在设计思路或算法上出现了问题，需要重新检查源程序找出问题并且修改，然后重新编译、链接、运行，直到得到正确结果</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章有讲到C语言是一门结构化语言，还讲了我们写代码需要先用文字描述算法、再用流程图、之后伪代码、最后再写代码&lt;/p&gt;
&lt;p&gt;这篇文章C语言的发展历史、特点、语法，以及如何将代码一步步运行出结果&lt;/p&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.gengruiblog.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>程序与程序设计语言</title>
    <link href="https://www.gengruiblog.cn/article/20210921.html"/>
    <id>https://www.gengruiblog.cn/article/20210921.html</id>
    <published>2021-09-20T16:00:00.000Z</published>
    <updated>2021-09-16T05:13:33.307Z</updated>
    
    <content type="html"><![CDATA[<p>程序（program）是为<strong>实现特定目标</strong>或<strong>解决特定问题</strong>而用计算机语言（程序设计语言）编写的一系列语句和指令，计算机能严格按照这些指令去做。</p><p>程序具有以下特点：</p><ol><li>完成某一特定的任务；</li><li>使用某种程序设计语言描述如何完成该任务；  </li><li>存储在计算机中，并且被运行后才能起作用。 </li></ol><a id="more"></a><h2 id="程序设计语言的发展"><a href="#程序设计语言的发展" class="headerlink" title="程序设计语言的发展"></a>程序设计语言的发展</h2><p>程序设计语言经过多年的发展，其技术和方法日臻成熟。其发展经历了几个阶段：</p><h3 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h3><ul><li>采用二进制指令代码</li><li>特点：难学、难写、难记、难修改  </li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul><li>采用助记符代替机器指令 </li><li>特点：依赖于机器硬件，可移植性不好 </li></ul><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ul><li>运算符和运算表达式与人们日常所用的数学式子差不多，很容易理解</li><li>高级语言又经历了不同的发展阶段：<ol><li>非结构化的语言 <ul><li>编程风格比较随意，没有编程规范可以遵循，程序中的流程可以随意跳转。 </li></ul></li><li>结构化的语言 <ul><li>结构化程序设计方法规定：程序由具有良好特性的基本结构（顺序结构、分支结构、循环结构）构成</li><li>程序中的流程不允许随意跳转，程序总是由上而下顺序执行各个基本结构。 </li></ul></li><li>面向对象的语言<ul><li>对象是由数据以及对数据所进行的操作的封装体</li><li>采用面向对象的程序设计方法开发应用程序变得更容易，耗时更少，效率更高。  </li></ul></li></ol></li></ul><h2 id="程序设计语言的功能"><a href="#程序设计语言的功能" class="headerlink" title="程序设计语言的功能"></a>程序设计语言的功能</h2><h3 id="数据表达"><a href="#数据表达" class="headerlink" title="数据表达"></a>数据表达</h3><p>对程序中用到的数据进行声明。</p><p>数据是计算机处理的对象，在解决实际问题时，通常需要申明各种类型的数据，数据类型就是对某些具有相同性质的数据集的总称</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>对不同类型的数据进行处理。</p><p>按照结构化程序设计的观点，任何程序的基本结构都可以通过三种基本的控制结构进行组合来实现，分别是顺序结构、分支结构、循环结构</p><p>这三种结构的共同特点是：</p><ol><li>只有单一的入口和单一的出口；</li><li>结构中的每个部分都有被执行的可能；</li><li>结构内不应出现永不终止的死循环。</li></ol><h2 id="程序的算法表示"><a href="#程序的算法表示" class="headerlink" title="程序的算法表示"></a>程序的算法表示</h2><h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p>“软件的主体是程序，程序的核心是算法”。瑞士计算机科学家尼·沃思（N·Wirth）有一句名言：“计算机科学就是研究算法的学问”。     </p><p>通俗地讲，算法就是解决问题的方法与步骤。</p><blockquote><p>例如要交换两个变量a和b的值，按照下面的步骤就可以完成交换：</p></blockquote><ol><li>输入变量a和b的值；</li><li>将变量a的值赋给变量t；</li><li>将变量b的值赋给变量a；</li><li>将变量t的值赋给变量b；</li><li>输出变量a与b的值。</li></ol><h3 id="算法的特征"><a href="#算法的特征" class="headerlink" title="算法的特征"></a>算法的特征</h3><ol><li>确定性：</li></ol><p>算法的每条指令必须有明确的含义，不能有二义性</p><p>对于相同的输入必须得出相同的执行结果</p><ol start="2"><li>有穷性：</li></ol><p>一个算法应包含有限个操作步骤</p><p>也就是说，在执行若干个操作步骤之后，算法将结束</p><p>而且每一步都在有限的时间内完成</p><ol start="3"><li>可行性：</li></ol><p>算法中指定的操作都可以通过已经实现的基本运算执行有限次后实现</p><ol start="4"><li><p>有零个或多个输入</p></li><li><p>有一个或多个输出</p></li></ol><p>算法的目的是为了求“解”，“解”只有通过输出才能得到</p><h3 id="算法的描述"><a href="#算法的描述" class="headerlink" title="算法的描述"></a>算法的描述</h3><p><strong>1. 用文字描述算法</strong></p><blockquote><p>例：有10个两位的正整数，找出其中最大的数，写出其算法。</p></blockquote><ol><li>输入第一个数，放入max中；</li><li>用i统计比较的次数，其初值置为1；</li><li>若i≤9，转第4步，否则转第8步；</li><li>再输入一个数，放在x中；</li><li>比较x和max中的数，若x&gt;max，则将x的值赋给max；否则max的值不变；</li><li>i增加1；</li><li>返回到第3步；</li><li>输出max中的数，此时max中的数即为10个数中最大的数。</li></ol><blockquote><p>例：写出求两个自然数的最大公约数的算法</p></blockquote><p>采用古希腊数学家欧几里得提出的“欧几里得算法”描述如下：</p><ol><li>输入两个自然数a、b；</li><li>求a除以b的余数r；</li><li>使a = b，即用b代替a；</li><li>使b = r，即用r代替b；</li><li>若r≠0，则重复执行步骤2、3、4，否则转第6步；</li><li>输出a，a即为a和b的最大公约数。</li></ol><p>用文字描述算法的缺点：</p><p>很难“系统”并“精确”地表达算法，且有时叙述冗长，别人不容易理解。</p><p><strong>2. 用流程图描述算法</strong></p><p>常用到的流程图框：</p><p><img src="https://gengrui01.github.io/picture/c-program-language/1.png" alt=""></p><p>三种基本的控制结构图示例：</p><p><img src="https://gengrui01.github.io/picture/c-program-language/2.png" alt=""></p><blockquote><p>例：有10个两位的正整数，找出其中最大的数，画出其流程图。</p></blockquote><p><img src="https://gengrui01.github.io/picture/c-program-language/3.png" alt=""></p><blockquote><p>例：画出求两个自然数的最大公约数的流程图</p></blockquote><p><img src="https://gengrui01.github.io/picture/c-program-language/4.png" alt=""></p><p>画流程图网站推荐：<a href="https://www.processon.com/i/5aff91c9e4b0ad4428891336" target="_blank" rel="noopener">ProcessOn免费在线作图</a></p><p><strong>3. 伪代码表示</strong></p><p>伪代码是一种近似高级语言但又不受语法约束的语言描述方式，它不能在计算机中运行，但可以用来描述算法。</p><blockquote><p>例：有10个两位的正整数，找出其中最大的数，用伪代码写出其算法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    输入第1个数赋给max；</span><br><span class="line">    for(i&#x3D;1;i&lt;&#x3D;9;i++)</span><br><span class="line">    &#123;输入第i+1个数赋给x；</span><br><span class="line">        if(x&gt;max)</span><br><span class="line">            max&#x3D;x;</span><br><span class="line">    &#125;</span><br><span class="line">    输出max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 程序设计语言表示</strong></p><blockquote><p>例：写代码交换两个变量a和b的值</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,t;<span class="comment">/* 定义所用的变量 */</span></span><br><span class="line">    a=<span class="number">3</span>;b=<span class="number">5</span>;<span class="comment">/* 给变量赋值 */</span></span><br><span class="line">    t=a; <span class="comment">/* 变量a的值存入变量t中 */</span></span><br><span class="line">    a=b; <span class="comment">/* 变量b的值赋予变量a */</span></span><br><span class="line">    b=t; <span class="comment">/* 变量t的值赋予变量b */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,a,b);<span class="comment">/* 输出交换后的变量的值 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序（program）是为&lt;strong&gt;实现特定目标&lt;/strong&gt;或&lt;strong&gt;解决特定问题&lt;/strong&gt;而用计算机语言（程序设计语言）编写的一系列语句和指令，计算机能严格按照这些指令去做。&lt;/p&gt;
&lt;p&gt;程序具有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成某一特定的任务；&lt;/li&gt;
&lt;li&gt;使用某种程序设计语言描述如何完成该任务；  &lt;/li&gt;
&lt;li&gt;存储在计算机中，并且被运行后才能起作用。 &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://www.gengruiblog.cn/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Visual Studio 2019 安装 并 运行第一个C语言项目文件</title>
    <link href="https://www.gengruiblog.cn/article/20210920.html"/>
    <id>https://www.gengruiblog.cn/article/20210920.html</id>
    <published>2021-09-19T16:00:00.000Z</published>
    <updated>2021-09-15T05:36:53.732Z</updated>
    
    <content type="html"><![CDATA[<p>本教程包含：</p><ol><li>介绍如何在官网下载并安装 Visual Studio 2019</li><li>创建并运行第一个C语言项目文件</li></ol><p>下面就是详细步骤：</p><a id="more"></a><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><h3 id="方式1-百度网盘链接"><a href="#方式1-百度网盘链接" class="headerlink" title="方式1 百度网盘链接"></a>方式1 百度网盘链接</h3><p>链接：<a href="https://pan.baidu.com/s/1Zpa_dx3t7qdNX2WyID3BTA" target="_blank" rel="noopener">单击此处百度网盘下载Visual Studio 2019安装包</a></p><p>提取码：sfid</p><h3 id="方式2-官网下载"><a href="#方式2-官网下载" class="headerlink" title="方式2 官网下载"></a>方式2 官网下载</h3><p><a href="https://visualstudio.microsoft.com/zh-hans/vs/" target="_blank" rel="noopener">Visual Studio IDE: 面向开发人员的一体式编程工具</a></p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/1.png" alt=""></p><h2 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h2><ol><li>右键 -&gt; 以管理员身份运行安装包</li></ol><p>如果收到用户帐户控制通知，请选择“是”</p><p>会出现如下界面等待进度条满</p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/2.png" alt=""></p><ol start="2"><li>要求确认 Microsoft 许可条款和 Microsoft 隐私声明，点击“继续”即可</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/3.png" alt=""></p><ol start="3"><li>自动下载安装，等待两行进度条满</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/4.png" alt=""></p><ol start="4"><li>选择工作负载</li></ol><p>安装完成后进入下图界面选择工作负载，不同应用不同语言勾选不同的工作负荷</p><p>例如C语言/C++语言开发需要向下拉 在 <strong>桌面应用和移动应用</strong> 下 找到 <strong>使用C++的桌面开发</strong> ，勾选</p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/5.png" alt=""></p><ol start="5"><li>点击“安装位置” 可以更换安装路径，也可以不做调整使用默认位置点击 “安装”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/6.png" alt=""></p><ol start="6"><li>接下来，会出现多个显示 Visual Studio 安装进度的状态屏幕，等待进度条满即可</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/7.png" alt=""></p><ol start="7"><li>重启电脑</li></ol><p>按转换完成后会提示需要重启，按要求点击“重启”即可</p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/8.png" alt=""></p><ol start="8"><li>在开始菜单栏找到 <strong>Visual Studio 2019</strong> 右键 -&gt; 更多 -&gt; 打开文件所在位置</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/9.png" alt=""></p><ol start="9"><li>找到 <strong>Visual Studio 2019</strong> 的快捷方式 右键 -&gt; 发送到 -&gt; 桌面快捷方式</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/10.png" alt=""></p><h2 id="程序设置"><a href="#程序设置" class="headerlink" title="程序设置"></a>程序设置</h2><ol><li>双击桌面的快捷方式打开，第一次会提示注册登录，也可以直接选择“下次再说”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/11.png" alt=""></p><ol start="2"><li>根据个人喜好选择喜欢的主题颜色，之后点击“启动Visual Studio”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/12.png" alt=""></p><ol start="3"><li>第一次启动需要准备时间，耐心等待</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/13.png" alt=""></p><h2 id="Visual-Studio-创建的第一个C语言项目"><a href="#Visual-Studio-创建的第一个C语言项目" class="headerlink" title="Visual Studio 创建的第一个C语言项目"></a>Visual Studio 创建的第一个C语言项目</h2><ol><li>设置完成后进来如下界面，点击“创建新项目”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/14.png" alt=""></p><ol start="2"><li>进到下图所示界面，选择“空项目”，点击“下一步”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/15.png" alt=""></p><ol start="3"><li>使用默认位置及名称点击“创建”创建项目</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/16.png" alt=""></p><h2 id="Visual-Studio-运行的第一个项目文件"><a href="#Visual-Studio-运行的第一个项目文件" class="headerlink" title="Visual Studio 运行的第一个项目文件"></a>Visual Studio 运行的第一个项目文件</h2><ol><li>创建好的项目界面如下图所示，找到“解决方案资源管理器”下的“源文件”，右键 -&gt; 添加 -&gt; 新建项</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/17.png" alt=""></p><ol start="2"><li>选择C++文件，修改文件名称及后缀名（注意C语言文件的后缀名是.c），点击“添加”</li></ol><p><img src="https://gengrui01.github.io/picture/visual-studio-install/18.png" alt=""></p><ol start="3"><li>在文件中写入如下代码：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击 调试 -&gt; 开始调试</p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/19.png" alt=""></p><p>弹出如下框并输出 “HelloWorld!” 表示我们已经使用 Visual Studio 运行成功了第一个C语言项目</p><p><img src="https://gengrui01.github.io/picture/visual-studio-install/20.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本教程包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;介绍如何在官网下载并安装 Visual Studio 2019&lt;/li&gt;
&lt;li&gt;创建并运行第一个C语言项目文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面就是详细步骤：&lt;/p&gt;
    
    </summary>
    
    
      <category term="安装与配置" scheme="https://www.gengruiblog.cn/categories/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Java IO流入门及File类</title>
    <link href="https://www.gengruiblog.cn/article/20210831.html"/>
    <id>https://www.gengruiblog.cn/article/20210831.html</id>
    <published>2021-08-30T16:00:00.000Z</published>
    <updated>2021-10-17T14:19:20.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流的概念和作用"><a href="#流的概念和作用" class="headerlink" title="流的概念和作用"></a>流的概念和作用</h2><p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。</p><p>即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p><a id="more"></a><h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ul><li>根据处理数据类型的不同分为：字符流和字节流</li><li>根据数据流向不同分为：输入流和输出流</li></ul><h2 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h2><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。</p><p>字节流和字符流的区别：</p><ul><li>读写单位不同：<ul><li>字节流以字节（8bit）为单位</li><li>字符流以字符为单位，根据码表映射字符，一次可能读多个字节</li></ul></li><li>处理对象不同：<ul><li>字节流能处理所有类型的数据（如图片、avi等）</li><li>字符流只能处理字符类型的数据</li></ul></li><li>字节流：一次读入或读出是8位二进制。</li><li>字符流：一次读入或读出是16位二进制。</li></ul><p>设备上的数据无论是图片或者视频，文字，它们都以二进制存储的。</p><p>二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。</p><p>意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。</p><p><strong>结论：</strong> 只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</p><h2 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h2><p>输入流只能进行读操作，输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。</p><ul><li>输入字节流 InputStream<ul><li>InputStream 是所有的输入字节流的父类，它是一个抽象类。</li><li>ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。</li><li>PipedInputStream 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。</li><li>ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。</li></ul></li><li>输出字节流 OutputStream<ul><li>OutputStream 是所有的输出字节流的父类，它是一个抽象类。</li><li>ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。</li><li>PipedOutputStream 是向与其它线程共用的管道中写入数据。</li><li>ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。</li></ul></li></ul><p><strong>结论：</strong> </p><ul><li>输入流：InputStream或者Reader：从文件中读到程序中；</li><li>输出流：OutputStream或者Writer：从程序中输出到文件中；</li></ul><h2 id="Java流类图结构"><a href="#Java流类图结构" class="headerlink" title="Java流类图结构"></a>Java流类图结构</h2><p><img src="https://gengrui01.github.io/picture/java-io-file/1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;流的概念和作用&quot;&gt;&lt;a href=&quot;#流的概念和作用&quot; class=&quot;headerlink&quot; title=&quot;流的概念和作用&quot;&gt;&lt;/a&gt;流的概念和作用&lt;/h2&gt;&lt;p&gt;流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。&lt;/p&gt;
&lt;p&gt;即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java注解Annotation的用法</title>
    <link href="https://www.gengruiblog.cn/article/20210829.html"/>
    <id>https://www.gengruiblog.cn/article/20210829.html</id>
    <published>2021-08-28T16:00:00.000Z</published>
    <updated>2021-10-11T12:16:34.369Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言中的类、方法、变量、参数和包等都可以被标注注解</p><p>和Javadoc注释不同的是Java注解可以通过反射获取标注内容，在编译器生成类文件时注解可以被嵌入到字节码中</p><p>Java虚拟机可以保留注解内容，在运行时可以获取到注解内容</p><a id="more"></a><h2 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h2><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中</p><h3 id="作用在代码的注解"><a href="#作用在代码的注解" class="headerlink" title="作用在代码的注解"></a>作用在代码的注解</h3><ul><li>@Override：检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated：标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings：指示编译器去忽略注解中声明的警告</li></ul><h3 id="作用在其他注解的注解-又称“元注解”"><a href="#作用在其他注解的注解-又称“元注解”" class="headerlink" title="作用在其他注解的注解(又称“元注解”)"></a>作用在其他注解的注解(又称“元注解”)</h3><ul><li>@Target：用于描述注解的使用范围，即被描述的注解可以用在什么地方，取值(ElementType)：<ul><li>CONSTRUCTOR：用于描述构造器</li><li>FIELD：用于描述域</li><li>LOCAL_VARIABLE：用于描述局部变量</li><li>METHOD：用于描述方法</li><li>PACKAGE：用于描述包</li><li>PARAMETER：用于描述参数</li><li>TYPE：用于描述类、接口(包括注解类型) 或enum声明</li></ul></li><li>@Retention：标识需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值(RetentionPolicy)：<ul><li>SOURCE:在源文件中有效（即源文件保留）</li><li>CLASS:在class文件中有效（即class保留）</li><li>RUNTIME:在运行时有效（即运行时保留）</li></ul></li><li>@Documented：标记这个注解应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化(@Documented是一个标记注解，没有成员)</li><li>@Inherited：也是一个标记注解。如果一个使用@Inherited修饰的Annotation类型被用于一个class，则这个Annotation将被用于该class的子类</li></ul><h2 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h2><p>在实际项目中，经常会碰到下面这种场景，一个接口的实现类或者抽象类的子类很多，经常需要根据不同情况（比如根据配置文件）实例化并使用不同的子类。典型的例子是结合工厂使用职责链模式。</p><p>此时，可以为每个实现类加上特定的Annotation，并在Annotation中给该类取一个标识符，应用程序可通过该标识符来判断应该实例化哪个子类。</p><p>下面这个例子，定义了一个名为Component的Annotation，它包含一个名为identifier的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span> <span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上文所说的实现类加上@Component</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value=<span class="string">"upper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpperCaseComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doWork</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> input.toUpperCase();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用程序中可以通过反射获取UpperCaseComponent对应的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class componentClass = Class.forName(<span class="string">"UpperCaseComponent"</span>);</span><br><span class="line">        <span class="keyword">if</span>(componentClass.isAnnotationPresent(Component<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            Component component = (Component)componentClass.getAnnotation(Component<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            System.out.println(component.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-annotation/1.png" alt=""></p><h2 id="Annotation与Interface的异同"><a href="#Annotation与Interface的异同" class="headerlink" title="Annotation与Interface的异同"></a>Annotation与Interface的异同</h2><ul><li>Annotation类型使用关键字<code>@interface</code>而非<code>interface</code></li><li>Annotation的方法定义是受限制的<ul><li>其方法必须声明为无参数、无异常抛出的</li><li>这些方法同时也定义了Annotation的成员——方法名即为成员名，而方法返回类型即为成员类型</li><li>方法返回类型必须为Java基础类型、Class类型、枚举类型、Annotation类型或者相应的一维数组</li><li>方法后面可以使用default关键字和一个默认数值来声明成员的默认值，null不能作为成员默认值</li><li>成员一般不能是泛型，只有当其类型是Class时可以使用泛型，因为此方法能够用类型转换将各种类型转换为Class</li></ul></li><li>Annotation和interface都可以定义常量、静态成员类型</li><li>interface可以被实现或者继承，Annotation不可以</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java语言中的类、方法、变量、参数和包等都可以被标注注解&lt;/p&gt;
&lt;p&gt;和Javadoc注释不同的是Java注解可以通过反射获取标注内容，在编译器生成类文件时注解可以被嵌入到字节码中&lt;/p&gt;
&lt;p&gt;Java虚拟机可以保留注解内容，在运行时可以获取到注解内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Class类与Java反射</title>
    <link href="https://www.gengruiblog.cn/article/20210828.html"/>
    <id>https://www.gengruiblog.cn/article/20210828.html</id>
    <published>2021-08-27T16:00:00.000Z</published>
    <updated>2021-10-11T12:25:59.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>反射就是在运行状态中</p><p>对于任意一个类，都能够知道这个类的所有属性和方法</p><p>对于任意一个对象，都能够调用它的任意方法和属性，并且能改变它的属性</p><a id="more"></a><h3 id="为什么要使用反射"><a href="#为什么要使用反射" class="headerlink" title="为什么要使用反射"></a>为什么要使用反射</h3><p>在Java中，我们编写好的.java类要先编译生成.class文件，之后运行出我们期望的结果</p><p>通常我们需要获取一个类的信息都是在编译期获得的，例如直接点（.）出属性和方法，或者使用new创建对象，这些都是使用了类的信息</p><p>可是如果需要在运行期需要获得Java类的信息就需要用到反射了</p><h3 id="反射的作用是什么？"><a href="#反射的作用是什么？" class="headerlink" title="反射的作用是什么？"></a>反射的作用是什么？</h3><p>反射机制就是允许程序在运行时取得任何一个已知名称的class的内部信息</p><p>包括其modifiers(修饰符)，fields(属性)，methods(方法)等</p><p>并可于运行时改变fields内容或调用methods。(同反射的概念)</p><h3 id="反射的实现"><a href="#反射的实现" class="headerlink" title="反射的实现"></a>反射的实现</h3><p>为了实现反射，我们先回顾 <a href="https://www.gengruiblog.cn/article/20180718.html">JVM类加载机制</a> 中类的生命周期</p><p>可以发现我们可以利用类加载时所开的入口（java.lang.Class对象）对该类进行解剖</p><p>把各个组成部分(构造器，属性，方法等)映射成一个个对象</p><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>Class类就是Java反射机制的入口，它封装了一个类或接口的运行时信息，通过调用Class类的方法可以获取这些信息</p><p>而Class类的对象就用于表示当前运行的 Java 应用程序中的类和接口</p><h3 id="得到Class类对象的方式"><a href="#得到Class类对象的方式" class="headerlink" title="得到Class类对象的方式"></a>得到Class类对象的方式</h3><ol><li>通过对象调用 getClass() 方法来获取</li></ol><p>我们都知道所有的java类都是继承了Object这个类</p><p>在Object类中有一个getClass()方法可以得到该类所维持的Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> A();</span><br><span class="line">Class a1=a.getClass();</span><br></pre></td></tr></table></figure><ol start="2"><li>通过类名.class</li></ol><p>该方法最为安全可靠，程序性能更高</p><p>这说明任何一个类都有一个隐含的静态成员变量 class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class a2=A<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>Class类的forName(String classpathname)方法</li></ol><p>不需要关注类型，用的最多，但可能抛出 ClassNotFoundException 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class a3 = Class.forName(<span class="string">"reflect.A"</span>);</span><br></pre></td></tr></table></figure><p><strong><em>TIPS:</em></strong> </p><blockquote><p>一个类在 JVM 中只会有一个 Class 实例<br>即我们对上面获取的 a1,a2,a3 进行 equals 比较，发现都是true</p></blockquote><h3 id="Class类提供的方法"><a href="#Class类提供的方法" class="headerlink" title="Class类提供的方法"></a>Class类提供的方法</h3><ol><li>获取类信息</li><li>获取Constructor对象</li><li>获取Field对象</li><li>获取Method对象</li></ol><h2 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h2><p>首先做准备工作定义一个User.java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..........省略set 和 get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="得到Constructor类对象的方式"><a href="#得到Constructor类对象的方式" class="headerlink" title="得到Constructor类对象的方式"></a>得到Constructor类对象的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectConstructor</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取Class对象的引用</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"reflect.User"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化默认构造方法，User必须无参构造函数,否则将抛异常</span></span><br><span class="line">        User user = (User) clazz.newInstance();</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        user.setName(<span class="string">"Rollen"</span>);</span><br><span class="line">        System.out.println(<span class="string">"user:"</span>+user);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取带String参数的public构造函数</span></span><br><span class="line">        Constructor cs1 =clazz.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//创建User</span></span><br><span class="line">        User user1= (User) cs1.newInstance(<span class="string">"xiaolong"</span>);</span><br><span class="line">        user1.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">"user1:"</span>+user1.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取得指定带int和String参数构造函数,该方法是私有构造private</span></span><br><span class="line">        Constructor cs2=clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">//由于是private必须设置可访问</span></span><br><span class="line">        cs2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//创建user对象</span></span><br><span class="line">        User user2= (User) cs2.newInstance(<span class="number">25</span>,<span class="string">"lidakang"</span>);</span><br><span class="line">        System.out.println(<span class="string">"user2:"</span>+user2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/1.png" alt=""></p><h3 id="Constructor类提供的方法"><a href="#Constructor类提供的方法" class="headerlink" title="Constructor类提供的方法"></a>Constructor类提供的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造函数参数类型</span></span><br><span class="line">Constructor cs3=clazz.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Class&lt;?&gt; clazzs[] = cs3.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class claz:clazzs) &#123;</span><br><span class="line">    System.out.println(<span class="string">"参数名称:"</span>+claz.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/2.png" alt=""></p><h2 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h2><p>首先做准备工作定义一个Person.java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个Student.java类继承Person</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String desc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="comment">//省略set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="得到Field类对象的方式"><a href="#得到Field类对象的方式" class="headerlink" title="得到Field类对象的方式"></a>得到Field类对象的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"reflect.Student"</span>);</span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段,</span></span><br><span class="line">        <span class="comment">// 否则抛NoSuchFieldException</span></span><br><span class="line">        Field field = clazz.getField(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(<span class="string">"field:"</span>+field);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取</span></span><br><span class="line">        Field fields[] = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f:fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">"f:"</span>+f.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段</span></span><br><span class="line">        Field field2 = clazz.getDeclaredField(<span class="string">"desc"</span>);</span><br><span class="line">        System.out.println(<span class="string">"field2:"</span>+field2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/3.png" alt=""></p><h3 id="Field类提供的方法"><a href="#Field类提供的方法" class="headerlink" title="Field类提供的方法"></a>Field类提供的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">Student st= (Student) clazz.newInstance();</span><br><span class="line"><span class="comment">//获取父类public字段并赋值</span></span><br><span class="line">Field ageField = clazz.getField(<span class="string">"age"</span>);</span><br><span class="line">ageField.set(st,<span class="number">18</span>);</span><br><span class="line">Field nameField = clazz.getField(<span class="string">"name"</span>);</span><br><span class="line">nameField.set(st,<span class="string">"Lily"</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/4.png" alt=""></p><h2 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h2><p>首先做准备工作定义一个Shape.java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> count, String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw "</span>+ name +<span class="string">",count="</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个Circle.java类继承Shape</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"drawCircle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAllCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="得到Method类对象的方式"><a href="#得到Method类对象的方式" class="headerlink" title="得到Method类对象的方式"></a>得到Method类对象的方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectMethod</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = Class.forName(<span class="string">"reflect.Circle"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据参数获取public的Method,包含继承自父类的方法</span></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"draw"</span>,<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"method:"</span>+method);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有public的方法:</span></span><br><span class="line">        Method[] methods =clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m:methods)&#123;</span><br><span class="line">            System.out.println(<span class="string">"m::"</span>+m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前类的方法包含private,该方法无法获取继承自父类的method</span></span><br><span class="line">        Method method1 = clazz.getDeclaredMethod(<span class="string">"drawCircle"</span>);</span><br><span class="line">        System.out.println(<span class="string">"method1::"</span>+method1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/5.png" alt=""></p><h3 id="Method类提供的方法"><a href="#Method类提供的方法" class="headerlink" title="Method类提供的方法"></a>Method类提供的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">Circle circle = (Circle) clazz.newInstance();</span><br><span class="line"><span class="comment">//获取指定参数的方法对象Method</span></span><br><span class="line">Method drawMethod = clazz.getMethod(<span class="string">"draw"</span>,<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="comment">//通过Method对象的invoke(Object obj,Object... args)方法调用</span></span><br><span class="line">drawMethod.invoke(circle,<span class="number">15</span>,<span class="string">"圈圈"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对私有无参方法的操作</span></span><br><span class="line">Method drawCircleMethod = clazz.getDeclaredMethod(<span class="string">"drawCircle"</span>);</span><br><span class="line"><span class="comment">//修改私有方法的访问标识</span></span><br><span class="line">drawCircleMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">drawCircleMethod.invoke(circle);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对有返回值得方法操作</span></span><br><span class="line">Method getAllCountMethod =clazz.getDeclaredMethod(<span class="string">"getAllCount"</span>);</span><br><span class="line">Integer count = (Integer) getAllCountMethod.invoke(circle);</span><br><span class="line">System.out.println(<span class="string">"count:"</span>+count);</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-class-reflection/6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;反射就是在运行状态中&lt;/p&gt;
&lt;p&gt;对于任意一个类，都能够知道这个类的所有属性和方法&lt;/p&gt;
&lt;p&gt;对于任意一个对象，都能够调用它的任意方法和属性，并且能改变它的属性&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java列表泛型结合lambda表达式使用</title>
    <link href="https://www.gengruiblog.cn/article/20210826.html"/>
    <id>https://www.gengruiblog.cn/article/20210826.html</id>
    <published>2021-08-25T16:00:00.000Z</published>
    <updated>2021-09-17T11:27:13.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="列表泛型的使用"><a href="#列表泛型的使用" class="headerlink" title="列表泛型的使用"></a>列表泛型的使用</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>一个数据类，用于记录职工信息</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">public</span> String time;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一列此类数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; data = Arrays.asList(e1,e2,e3......)</span><br></pre></td></tr></table></figure><h3 id="将员工按照姓名的首字母分组"><a href="#将员工按照姓名的首字母分组" class="headerlink" title="将员工按照姓名的首字母分组"></a>将员工按照姓名的首字母分组</h3><p>将员工Employee按照姓名的首字母(假设均为英文名)进行分组</p><p>我们要得到的结果应该是一个 <code>Map：char -&gt; List&lt;Employee&gt;</code> 这样的映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Character, List&lt;Employee&gt;&gt; groupByFirstChar(List&lt;Employee&gt; data)&#123;</span><br><span class="line">    Map&lt;Character, List&lt;Employee&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Employee e : data)&#123;</span><br><span class="line">        Character c = e.getName().charAt(<span class="number">0</span>);</span><br><span class="line">        List&lt;Employee&gt; l = result.get(c);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span>)&#123;</span><br><span class="line">            l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            l.add(e);</span><br><span class="line">            result.put(c, l);</span><br><span class="line">        &#125;</span><br><span class="line">        l.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将员工按照工资分组"><a href="#将员工按照工资分组" class="headerlink" title="将员工按照工资分组"></a>将员工按照工资分组</h3><p>将员工Employee按照工资分个组吧，5000以下的，5000~10000的 … 等</p><p>也不会太难，将key换一下，稍作逻辑处理即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, List&lt;Employee&gt;&gt; groupBySalary(List&lt;Employee&gt; data) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Employee&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Employee e : data) &#123;</span><br><span class="line">        String key = separate(e.getSalary());</span><br><span class="line">        List&lt;Employee&gt; l = result.get(key);</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;</span><br><span class="line">            l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            l.add(e);</span><br><span class="line">            result.put(key, l);</span><br><span class="line">        &#125;</span><br><span class="line">        l.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">separate</span><span class="params">(<span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (salary &lt;= <span class="number">5000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"5000以下"</span>;</span><br><span class="line">    <span class="keyword">if</span> (salary &lt;= <span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"5000~10000"</span>;</span><br><span class="line">    <span class="keyword">if</span> (salary &lt;= <span class="number">20000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"10000~20000"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"20000以上"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列表泛型结合接口泛型及内部类的使用"><a href="#列表泛型结合接口泛型及内部类的使用" class="headerlink" title="列表泛型结合接口泛型及内部类的使用"></a>列表泛型结合接口泛型及内部类的使用</h2><h3 id="找相同"><a href="#找相同" class="headerlink" title="找相同"></a>找相同</h3><p>稍作比较可以发现，无论怎么分组，唯一的变化是key值的选取方式</p><p>第一次将Employee的name的第一字母作为key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e -&gt; e.name.charAt(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>也可以将获取首字母单独写成一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e -&gt; getFirstChar(e.getName()):Character</span><br></pre></td></tr></table></figure><p>第二次将Employee的salary按照方法separat转换为String作为key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e -&gt; separate(e.getSalary()):String</span><br></pre></td></tr></table></figure><p>再比如新的需求是将员工按照入职年份分组</p><p>那就将Employee的time按照方法getYear转换为String作为key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e -&gt; getYear(e.getTime()):String</span><br></pre></td></tr></table></figure><p>为了看起来更美观，可以讲三个方法的参数都设置成Employee 方法体就不写了 这里只列出参数和返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e -&gt; getFirstChar(e) : Character</span><br><span class="line">Employee e -&gt; separate(e) : String</span><br><span class="line">Employee e -&gt; getYear(e) : String</span><br></pre></td></tr></table></figure><p>-&gt;的左边为参数，-&gt;的右边是方法的签名，:的右边为返回值</p><h3 id="引入接口泛型及内部类"><a href="#引入接口泛型及内部类" class="headerlink" title="引入接口泛型及内部类"></a>引入接口泛型及内部类</h3><p>这时我们自然会想到将变化的部分抽取为参数，其他不变的部分抽取为方法体，那么就可以省去那些重复的代码</p><p>显然变化的部分就是上面列出的，将Employee e转化成key的方法</p><p>但是我们知道java是不能把方法作为参数进行传递的，不过对于稍有经验的程序猿来说这并不是问题，我们可以使用接口来实现我们的目的</p><p>同时又会遇到另一个问题，以上三个方法的返回值是不同的，因此我们要用到<strong>泛型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; Map&lt;K, List&lt;Employee&gt;&gt; groupByKey(List&lt;Employee&gt; data, GetKey&lt;K&gt; getKey)&#123;</span><br><span class="line">    Map&lt;K, List&lt;Employee&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Employee e : data) &#123;</span><br><span class="line">        K key = getKey.getKey(e);</span><br><span class="line">        List&lt;Employee&gt; l = result.get(key);</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;</span><br><span class="line">            l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            l.add(e);</span><br><span class="line">            result.put(key, l);</span><br><span class="line">        &#125;</span><br><span class="line">        l.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GetKey</span>&lt;<span class="title">K</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">K <span class="title">getKey</span><span class="params">(Employee e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么上面的第一个需求就可以这样实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, List&lt;Employee&gt;&gt; result = groupByKey(data, <span class="keyword">new</span> GetKey&lt;Character&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Character <span class="title">getKey</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">            e.name.charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>第二个需求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; result = groupByKey(list, <span class="keyword">new</span> GetKey&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">            separate(e.salary);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="列表泛型结合lambda表达式使用"><a href="#列表泛型结合lambda表达式使用" class="headerlink" title="列表泛型结合lambda表达式使用"></a>列表泛型结合lambda表达式使用</h2><h3 id="找相似"><a href="#找相似" class="headerlink" title="找相似"></a>找相似</h3><p>可以发现，我们只需要更改泛型参数和匿名内部类的实现即可</p><p>唯一的问题恐怕是这么写实在不太好看，而且很多例行公事的代码，尤其体现在匿名内部类上</p><p>事实上我们只关心这个匿名内部类的参数和返回值，其他部分仅仅是语法要求</p><h3 id="引入lambda表达式"><a href="#引入lambda表达式" class="headerlink" title="引入lambda表达式"></a>引入lambda表达式</h3><p>java8恰好为我们提供了很好的方式来避免复杂的例行公事的方式：lambda表达式</p><p>以上实现就可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, List&lt;Employee&gt;&gt; resultByFirstChar = groupByKey(list, e -&gt; e.name.charAt(<span class="number">0</span>));</span><br><span class="line">Map&lt;String, List&lt;Employee&gt;&gt; resultBySalary = groupByKey(list, e -&gt; separate(e.salary));</span><br></pre></td></tr></table></figure><p>lambda表达式恰恰只表现出我们所关心的，参数和返回值，同时由于类型推断，可以省去参数类型</p><p>lambda表达式的具体语法这里就不介绍了，网上可以查到很多资料</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;列表泛型的使用&quot;&gt;&lt;a href=&quot;#列表泛型的使用&quot; class=&quot;headerlink&quot; title=&quot;列表泛型的使用&quot;&gt;&lt;/a&gt;列表泛型的使用&lt;/h2&gt;&lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;一个数据类，用于记录职工信息&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="https://www.gengruiblog.cn/article/20210825.html"/>
    <id>https://www.gengruiblog.cn/article/20210825.html</id>
    <published>2021-08-24T16:00:00.000Z</published>
    <updated>2021-09-13T12:04:48.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="向上转型-amp-向下转型"><a href="#向上转型-amp-向下转型" class="headerlink" title="向上转型 &amp; 向下转型"></a>向上转型 &amp; 向下转型</h2><p>Java语言允许用父类申明变量,用子类实例化,这种将子类对象直接赋值给父类对象的语法称为向上转型,而且这个过程是自动化的</p><p>但反过来用子类申明变量用父类实例化是不允许的,因为子类往往比父类更加复杂,计算机无法将简单的对象自动的转化为复杂的对象</p><p>向下转型需要做强制的转化,在父类对象前使用强制转换的语法才能实现向下转型,而且转型之后也有可能发生数据缺失</p><a id="more"></a><p><img src="https://gengrui01.github.io/picture/java-generics/1.png" alt=""></p><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>举个例子帮助大家了解泛型是什么</p><p><img src="https://gengrui01.github.io/picture/java-generics/2.png" alt=""></p><p>这里有一条公路，我们可以在这条路上开汽车/骑自行车/骑马</p><p>但如果这条路上放了一个标志机动车道这样的话，我们就不能在这条路上骑自行车和骑马了</p><p>我们只能开汽车，如果这个标志换成了自行车道的话，那么我们就只能骑自行车，但不能开汽车了，也不能骑马</p><p>这个标志限制了这条路上允许行驶的交通工具，它的作用啊就相当于泛型</p><p>Java1.5版本提供了泛型的概念，泛型的实质上就是使程序员可以定义安全的数据类型</p><h2 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h2><p>泛型可以在定义类的时候定义,它的语法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名&lt;类型参数<span class="number">1</span>,类型参数<span class="number">2</span>,...,类型参数n&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>创建类时在类名与大括号之间写一对尖括号，在括号里面写泛型的类型参数，可以写一个也可以写很多个</p><p>具体例子如下:</p><p><img src="https://gengrui01.github.io/picture/java-generics/3.png" alt=""></p><p>在这个监控号里面呢写了一个泛型类型，我们可以起任意一个名字(一般不用已经存在的类名)</p><p>通常会用一个大写的英文字母来代替，之后直接用这个泛型的来创建成员变量,也可以放在方法的参数中，也可以作为方法的返回值</p><p><strong><em>TIPS:</em></strong></p><blockquote><p>如果我们定义了泛型却不使用,Eclipse会发出警告<br>但这样啊不会影响到我们程序的运行</p></blockquote><h2 id="使用泛型-VS-不使用泛型"><a href="#使用泛型-VS-不使用泛型" class="headerlink" title="使用泛型 VS 不使用泛型"></a>使用泛型 VS 不使用泛型</h2><p>接下来写两个例子对比使用泛型和不使用泛型的效果</p><h3 id="不使用泛型"><a href="#不使用泛型" class="headerlink" title="不使用泛型"></a>不使用泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object b; <span class="comment">// 定义Object类型成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getB</span><span class="params">()</span> </span>&#123; <span class="comment">// 设置相应getXXX()方法</span></span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(Object b)</span> </span>&#123; <span class="comment">// 设置相应setXXX()方法</span></span><br><span class="line"><span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">t1.setB(<span class="keyword">true</span>); <span class="comment">// 向上转型操作</span></span><br><span class="line">System.out.println(t1.getB());</span><br><span class="line">Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">t2.setB(<span class="number">12.3f</span>);</span><br><span class="line">Float f = (Float) (t2.getB()); <span class="comment">// 向下转型操作</span></span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-generics/9.png" alt=""></p><p>这样的代码是有隐患的,比如我们将Float类型的t2强转为int类型时编译是不会报错的,但是运行必报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)t2.getB();</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p>于是JDK提供了泛型</p><h3 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T b; <span class="comment">// 定义泛型成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getB</span><span class="params">()</span> </span>&#123; <span class="comment">// 设置相应getXXX()方法</span></span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(T b)</span> </span>&#123; <span class="comment">// 设置相应setXXX()方法</span></span><br><span class="line"><span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test2&lt;Boolean&gt; t1 = <span class="keyword">new</span> Test2&lt;Boolean&gt;();</span><br><span class="line">t1.setB(<span class="keyword">true</span>);</span><br><span class="line">        t1.setB(<span class="string">"abc"</span>); <span class="comment">// 会报参数类型错误</span></span><br><span class="line">        <span class="keyword">float</span> i = t1.getB(); <span class="comment">// 会报参数类型错误</span></span><br><span class="line">System.out.println(t1.getB());</span><br><span class="line"></span><br><span class="line">Test2&lt;Integer&gt; t2 = <span class="keyword">new</span> Test2&lt;&gt;();<span class="comment">// JDK1.7升级,后面泛型可省略</span></span><br><span class="line">t2.setB(<span class="number">123</span>);</span><br><span class="line">System.out.println(t2.getB());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-generics/7.png" alt=""></p><p><strong><em>TIPS:</em></strong></p><blockquote><p>泛型定义时可以不止一个<br>但申明时泛型要么都实现,要么都不实现(不写就是Object)</p></blockquote><h3 id="使用多个泛型"><a href="#使用多个泛型" class="headerlink" title="使用多个泛型"></a>使用多个泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T b;</span><br><span class="line"><span class="keyword">private</span> K k;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(T b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">getK</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setK</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.k = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test2&lt;Boolean, Float&gt; t1 = <span class="keyword">new</span> Test2&lt;&gt;();</span><br><span class="line">t1.setB(<span class="keyword">true</span>);</span><br><span class="line">t1.setK(<span class="number">1.1f</span>);</span><br><span class="line">System.out.println(<span class="string">"b:"</span> + t1.getB() + <span class="string">"   k:"</span> + t1.getK());</span><br><span class="line"></span><br><span class="line">Test2&lt;Integer, String&gt; t2 = <span class="keyword">new</span> Test2&lt;&gt;();</span><br><span class="line">t2.setB(<span class="number">123</span>);</span><br><span class="line">t2.setK(<span class="string">"string"</span>);</span><br><span class="line">System.out.println(<span class="string">"b:"</span> + t2.getB() + <span class="string">"   k:"</span> + t2.getK());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-generics/8.png" alt=""></p><h2 id="限制泛型的类型"><a href="#限制泛型的类型" class="headerlink" title="限制泛型的类型"></a>限制泛型的类型</h2><p>我们使用任何的类型来实例化一个泛型对象，这样是存在弊端的</p><p>于是Java提供了一种语法来限制泛型的可实现类,这种语法呢就是泛型的继承</p><p>它的语法如下图所示:</p><p><img src="https://gengrui01.github.io/picture/java-generics/6.png" alt=""></p><p>我们在创建泛型的时候使用extends关键字，这样就给泛型T添加了一个限制</p><p>这个泛型必须是anyClass的子类，虽然这里使用的是extend关键字，但是这个anyClass既可以是类也可以是接口</p><p>我们呢写一个例子给大家看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">List</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test3&lt;ArrayList&gt; t1 = <span class="keyword">new</span> Test3&lt;&gt;();</span><br><span class="line">Test3&lt;LinkedList&gt; t2 = <span class="keyword">new</span> Test3&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Test3&lt;HashSet&gt; t3 = <span class="keyword">new</span> Test3&lt;&gt;(); <span class="comment">// HashSet 不是 List 的子类 所以会报错</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>泛型机制中提供了泛型通配符，它的作用主要是在创建泛型对象时限制泛型的类型，并且啊限制泛型对象的使用</p><p>它的语法如下图所示:</p><p><img src="https://gengrui01.github.io/picture/java-generics/4.png" alt=""></p><p>这里的问号来代表泛型通配符，他可以代表任意的类型</p><p>如果这个问号继承了一个类那么这个泛型就必须是anyClass的子类,并且此对象不能作增加和改写的操作，限制了这个泛型的对象只能读取，不能增加和改写</p><p>泛型通配符还有另外一种使用方法，可以使用super关键字，这样就限制了泛型必须是anyClass或者是anyClass的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        l1.add(<span class="string">"成员1"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;? extends List&gt; l2 = <span class="keyword">new</span> ArrayList&lt;List&gt;();<span class="comment">// 指定了上界</span></span><br><span class="line">        List&lt;? <span class="keyword">super</span> List&gt; l3 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();<span class="comment">// 指定了下界</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后呢，我们对泛型做出一些总结</p><ol><li>泛型只能是类类型</li></ol><p>正确: <code>Demo&lt;Integer&gt;</code></p><p>错误: <code>Demo&lt;int&gt;</code></p><ol start="2"><li>泛型的类型个数呢可以是多个</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo&lt;T,K,V&gt;</span><br></pre></td></tr></table></figure><p>注意泛型最好呢是要写一个单个的英文字母</p><ol start="3"><li>使用extends关键字限制泛型使用的范围</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo&lt;T extends Number&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用通配符来限制泛型的上下界</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo&lt;?&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;向上转型-amp-向下转型&quot;&gt;&lt;a href=&quot;#向上转型-amp-向下转型&quot; class=&quot;headerlink&quot; title=&quot;向上转型 &amp;amp; 向下转型&quot;&gt;&lt;/a&gt;向上转型 &amp;amp; 向下转型&lt;/h2&gt;&lt;p&gt;Java语言允许用父类申明变量,用子类实例化,这种将子类对象直接赋值给父类对象的语法称为向上转型,而且这个过程是自动化的&lt;/p&gt;
&lt;p&gt;但反过来用子类申明变量用父类实例化是不允许的,因为子类往往比父类更加复杂,计算机无法将简单的对象自动的转化为复杂的对象&lt;/p&gt;
&lt;p&gt;向下转型需要做强制的转化,在父类对象前使用强制转换的语法才能实现向下转型,而且转型之后也有可能发生数据缺失&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java枚举类型</title>
    <link href="https://www.gengruiblog.cn/article/20210824.html"/>
    <id>https://www.gengruiblog.cn/article/20210824.html</id>
    <published>2021-08-23T16:00:00.000Z</published>
    <updated>2021-09-13T04:34:32.092Z</updated>
    
    <content type="html"><![CDATA[<p>常量指的就是计算机中不可改变的量。比如一年中有四个季节，彩虹有七种原色，这些都是固定的值，也就是所谓的常量</p><p>在Java中我们通过使用final关键字来创建常量</p><p>但是这种方式创建出的常量仍然存在一些弊端，所以JDK1.5中就新增了枚举的概念</p><a id="more"></a><p>枚举是一种数据类型，它是一系列具有名称的常量的集合</p><p>枚举和普通的常量有一些不同之处，如果使用枚举的话，只能使用枚举中已经设定好的常量，只要是不在这个集合中的常量我们都无法使用</p><h2 id="创建枚举"><a href="#创建枚举" class="headerlink" title="创建枚举"></a>创建枚举</h2><p>创建枚举的语法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    枚举<span class="number">1</span>,</span><br><span class="line">    枚举<span class="number">2</span>,</span><br><span class="line">    枚举<span class="number">3</span>,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看这里使用了enum关键字，而这个enum关键字它和class、interface这些关键字的作用大致相似，只不过它所声明的这个类型叫做枚举类型</p><p>用户可以将一个枚举类型看作成为一个类，他继承了java.lang.Enum这个类</p><p>当我们定义一个枚举类型的时候,每一个枚举类型的成员都可以看作为这个类型的实例，而这些枚举类型都默认被这个<code>public static final</code>修饰</p><p>也就是说这些对象都是公有的静态常量，所以当我们使用枚举类型成员的时候，直接可以用<code>枚举名.枚举值</code>的方式来调用这些枚举成员</p><p>我们来看一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Constants&#123;</span><br><span class="line">    Constants_A,</span><br><span class="line">    Constants_B,</span><br><span class="line">    Constants_C,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们创建枚举成员的时候不需要写它是什么类型,只需要直接像这样给他写一个名字就可以了,然后用逗号隔开</p><p>最后一个枚举成员，后面可以写分号，也可以写逗号，也可以什么都不写，这个枚举我们就是创建完了</p><h2 id="普通常量-VS-枚举常量"><a href="#普通常量-VS-枚举常量" class="headerlink" title="普通常量 VS 枚举常量"></a>普通常量 VS 枚举常量</h2><h3 id="普通常量"><a href="#普通常量" class="headerlink" title="普通常量"></a>普通常量</h3><p>首先创建一个接口,接口里面的量都是公有静态常量,默认会有<code>public static final</code>修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Constants</span> </span>&#123; <span class="comment">// 将常量放置在接口中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Constants_A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Constants_B = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在demo中定义doit()方法,将常量作为参数传进方法,根据常量的值打出对应常量名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doit</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line"><span class="keyword">case</span> Constants.Constants_A:</span><br><span class="line">System.out.println(<span class="string">"doit() Constants_A"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Constants.Constants_B:</span><br><span class="line">System.out.println(<span class="string">"doit() Constants_B"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">doit(Constants.Constants_A); <span class="comment">// 使用接口中定义的常量</span></span><br><span class="line">        doit(<span class="number">12</span>);</span><br><span class="line">doit(<span class="number">3</span>);<span class="comment">// 使用接口中不存在的常量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-enum/3.png" alt=""></p><p>普通变量有两个缺点:</p><ol><li>doit()方法传入的参数如果在常量中不存在,编译运行都没有任何报错信息</li><li>两个常量可以等于同一个值,编译时switch case报错</li></ol><h3 id="枚举常量"><a href="#枚举常量" class="headerlink" title="枚举常量"></a>枚举常量</h3><p>创建一个枚举,枚举里面有常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Constants2 &#123;</span><br><span class="line">    Constants_A, Constants_B, Constants_C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在demo中定义doit2()方法,将枚举作为参数传进方法,根据枚举打出对应枚举名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个方法，这里的参数为枚举类型对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doit2</span><span class="params">(Constants2 constants2)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">switch</span> (constants2) &#123;</span><br><span class="line">        <span class="keyword">case</span> Constants_A:</span><br><span class="line">            System.out.println(<span class="string">"doit2() Constants_A"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Constants_B:</span><br><span class="line">            System.out.println(<span class="string">"doit2() Constants_B"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Constants_C:</span><br><span class="line">            System.out.println(<span class="string">"doit2() Constants_C"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加main方法,测试打印的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doit2(Constants2.Constants_A);</span><br><span class="line">doit2(Constants2.Constants_B);</span><br><span class="line">doit2(Constants2.Constants_C);</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-enum/4.png" alt=""></p><p>注意:</p><ol><li>doit()方法传入的参数必须是枚举类型对象</li><li>枚举类型没有值</li></ol><h2 id="枚举类型的常用方法"><a href="#枚举类型的常用方法" class="headerlink" title="枚举类型的常用方法"></a>枚举类型的常用方法</h2><p>枚举类型的继承自java.lang.Enum，所以枚举也可以调用方法，介绍一下比较常用的这4个方法</p><h3 id="values-方法"><a href="#values-方法" class="headerlink" title="values()方法"></a>values()方法</h3><p>可以将枚举类型的所有成员以数组的形式返回出来</p><p>我们在main方法中打印Constants2中的枚举成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constants2[] enumArray = Constants2.values();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enumArray.length; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"枚举类型成员变量："</span> + enumArray[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用这个value的这个方法之后呢，会枚举类型的所有成员封装成一个数组</p><p><img src="https://gengrui01.github.io/picture/java-enum/5.png" alt=""></p><h3 id="valueOf-方法"><a href="#valueOf-方法" class="headerlink" title="valueOf()方法"></a>valueOf()方法</h3><p>该方法可以将普通字符串转化为枚举实例,类似于包装类提供的valueOf()方法</p><p>我们在main方法中创建两个枚举对象,分别接收枚举对象以及valueOf()方法转化的枚举实例</p><p>打印俩枚举对象是否完全相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constants2 c1 = Constants2.Constants_A;</span><br><span class="line">Constants2 c2 = Constants2.valueOf(<span class="string">"Constants_A"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"c1与c2是否相等："</span> + (c1 == c2));</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-enum/6.png" alt=""></p><p>在<code>valueOf()</code>中传入不存在的值,如下代码所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constants2 c2 = Constants2.valueOf(<span class="string">"OK"</span>);</span><br></pre></td></tr></table></figure><p>会报找不到枚举值的错误</p><p><img src="https://gengrui01.github.io/picture/java-enum/7.png" alt=""></p><h3 id="ordinal-方法"><a href="#ordinal-方法" class="headerlink" title="ordinal()方法"></a>ordinal()方法</h3><p>枚举成员的是有索引位置的,第一个索引为0,第二个为1,以此类推</p><p><img src="https://gengrui01.github.io/picture/java-enum/2.png" alt=""></p><p>ordinal()方法就是用来得到枚举成员的位置索引</p><p>我们在main方法中输出Constants2所有枚举成员的索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constants2[] enumArray = Constants2.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enumArray.length; i++) &#123;</span><br><span class="line">    System.out.println(enumArray[i] + <span class="string">"在枚举类型中位置索引值是"</span> + enumArray[i].ordinal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-enum/9.png" alt=""></p><h3 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h3><p>该方法用来比较两个枚举对象在定义时的顺序</p><p>仍然以Constants2为例</p><p><img src="https://gengrui01.github.io/picture/java-enum/1.png" alt=""></p><p>我们在main方法中创建一个枚举对象存放Constants_B</p><p>再创建一个数组enumArray获取枚举类型的所有成员</p><p>最后for循环遍历enumArray,输出Constants_B和枚举中所有成员的比较结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constants2 c = Constants2.Constants_B;</span><br><span class="line">Constants2[] enumArray = Constants2.values();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; enumArray.length; i++) &#123;</span><br><span class="line">    System.out.println(c + <span class="string">"与枚举类型成员"</span> + enumArray[i] + <span class="string">"的比较结果为"</span> + c.compareTo(enumArray[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/java-enum/8.png" alt=""></p><h2 id="枚举类型的优势"><a href="#枚举类型的优势" class="headerlink" title="枚举类型的优势"></a>枚举类型的优势</h2><p>枚举类型提供了一种非常友好的定义常量的方法</p><p>枚举类型有以下几个特点</p><ol><li>它是类型安全的，因为每一个枚举都是一个枚举对象而不是一个具体的数值，所以它不会被其他数值所替代</li><li>它是紧凑有效的数据定义</li><li>枚举还可以和程序的其他部分完美的交互，比如说switch语句就直接可以用枚举来作为参数</li><li>它的运行效率高</li></ol><p>第1点和第4点是枚举最大的优势类型,所以我们通常定义常量的时候建议大家多使用枚举类型，而不是使用传统的常量数字</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常量指的就是计算机中不可改变的量。比如一年中有四个季节，彩虹有七种原色，这些都是固定的值，也就是所谓的常量&lt;/p&gt;
&lt;p&gt;在Java中我们通过使用final关键字来创建常量&lt;/p&gt;
&lt;p&gt;但是这种方式创建出的常量仍然存在一些弊端，所以JDK1.5中就新增了枚举的概念&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Python类的继承</title>
    <link href="https://www.gengruiblog.cn/article/20210615.html"/>
    <id>https://www.gengruiblog.cn/article/20210615.html</id>
    <published>2021-06-14T16:00:00.000Z</published>
    <updated>2021-07-24T04:02:36.455Z</updated>
    
    <content type="html"><![CDATA[<p>未完结</p><a id="more"></a><h2 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h2><p>在 <a href="https://gengrui01.github.io/article/20210610.html" target="_blank" rel="noopener">Python面向对象编程</a> 中有提到类会有一些属性，比如Person类有姓名、性别等属性来修饰Person类</p><p><img src="https://gengrui01.github.io/picture/python-class-extends/1.png" alt=""></p><p>但在描述某些特定种类的人(例如：老师、学生)时，这些属性便不能对特定种类的人进行准确地描述</p><p>这时我们将特定种类的人(例如：老师、学生)抽象出一个新的对象，每个对象又会有特定的属性</p><p><img src="https://gengrui01.github.io/picture/python-class-extends/2.png" alt=""></p><p>虽然我们把特定种类的人(例如：老师、学生)抽象为了一个新的对象，但是特定种类的人仍然是人</p><p>我们把这种特定种类的人和人本身的关系称为继承</p><p>人(Person)类称为父类，特定种类的人(例如：老师、学生)称为子类</p><p>子类是继承于父类的</p><p><img src="https://gengrui01.github.io/picture/python-class-extends/3.png" alt=""></p><p>继承的优势：</p><blockquote><p>继承后子类有父类的所有属性和功能，比如特定种类的人(例如：老师、学生)仍然拥有人所拥有的属性和功能<br>这样子类定义的时候只需要定义缺少的属性，实现缺少的功能即可，提高了代码复用率，减轻程序员负担</p></blockquote><h2 id="代码实现类的继承"><a href="#代码实现类的继承" class="headerlink" title="代码实现类的继承"></a>代码实现类的继承</h2><p>首先定义父类 人(Person)类，他的定义方法和普通类的定义没有区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, sex, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;未完结&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.gengruiblog.cn/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python对象的方法</title>
    <link href="https://www.gengruiblog.cn/article/20210613.html"/>
    <id>https://www.gengruiblog.cn/article/20210613.html</id>
    <published>2021-06-12T16:00:00.000Z</published>
    <updated>2021-07-20T05:54:07.611Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://gengrui01.github.io/article/20210612.html" target="_blank" rel="noopener">Python对象的属性</a> 中我们知道了私有属性只能在类的内部操作，没有办法从外部访问</p><p>但是如果外部需要操作私有属性怎么办？这个时候可以通过定义类或者实例的方法来操作私有属性</p><p>本文就来介绍如何定义类或者实例的方法</p><a id="more"></a><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>实例的方法指的就是在类中定义的函数，实例方法的第一个参数永远都是 <code>self</code> ， <code>self</code> 是一个引用，指向调用该方法的实例对象本身，除此以外，其他参数和普通函数是完全一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br></pre></td></tr></table></figure><p>在上面的定义， <code>name</code> 是实例的私有属性，从外部是无法访问的，而 <code>get_name(self)</code> 就是一个实例方法，在实例方法里面是可以操作私有属性的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = Person(<span class="string">"Anne"</span>)</span><br><span class="line">print(p.getName())</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/python-object-method/1.png" alt=""></p><p>当然，实例方法并不仅仅是为私有属性服务的，我们可以把和类的实例有关的操作都抽象成实例方法</p><p>比如：打印实例的详细信息等等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, location)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.__location = location</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getInfo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'name = &#123;&#125;, age = &#123;&#125;, location = &#123;&#125;'</span>.format(self.name, self.age, self.__location)</span><br><span class="line"></span><br><span class="line">dog = Animal(<span class="string">'wangwang'</span>, <span class="number">1</span>, <span class="string">'BeiJing'</span>)</span><br><span class="line">print(dog.getInfo())</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/python-object-method/2.png" alt=""></p><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>为了操作实例对象的私有属性我们定义了实例方法，同样的如果需要需要操作类的私有属性则应该定义类方法</p><p>实例方法的第一个参数 <code>self</code> 指向调用该方法的实例对象本身</p><p>类方法的第一个参数永远都是 <code>cls</code> ， <code>cls</code> 也是一个引用，指向类本身</p><p>类方法需要使用 <code>@classmethod</code> 来标记为类方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    __location = <span class="string">'China'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setLocation</span><span class="params">(cls, location)</span>:</span></span><br><span class="line">        cls.__location = location</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLocation</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.__location</span><br><span class="line"></span><br><span class="line">print(Animal.getLocation())</span><br><span class="line">Animal.setLocation(<span class="string">'BeiJing'</span>)</span><br><span class="line">print(Animal.getLocation())</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/python-object-method/3.png" alt=""></p><p>因为是在类上调用而不是在实例上调用，所以类方法无法获得任何实例变量，只能获得类的引用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;https://gengrui01.github.io/article/20210612.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python对象的属性&lt;/a&gt; 中我们知道了私有属性只能在类的内部操作，没有办法从外部访问&lt;/p&gt;
&lt;p&gt;但是如果外部需要操作私有属性怎么办？这个时候可以通过定义类或者实例的方法来操作私有属性&lt;/p&gt;
&lt;p&gt;本文就来介绍如何定义类或者实例的方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.gengruiblog.cn/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python对象的属性</title>
    <link href="https://www.gengruiblog.cn/article/20210612.html"/>
    <id>https://www.gengruiblog.cn/article/20210612.html</id>
    <published>2021-06-11T16:00:00.000Z</published>
    <updated>2021-07-20T05:59:09.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="实例属性的定义"><a href="#实例属性的定义" class="headerlink" title="实例属性的定义"></a>实例属性的定义</h3><p>在 <a href="https://gengrui01.github.io/article/20210611.html" target="_blank" rel="noopener">Python类的定义和实例化</a> 中我们已经通过Person类创建出zhangsan、lisi等实例，但是这些实例看上去并没有任何区别</p><p>在现实世界中，一个人拥有名字、性别、年龄等等的信息</p><p>在Python中，可以通过以下的方式赋予实例这些属性</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangsan.name = <span class="string">'zhangsan'</span></span><br><span class="line">zhangsan.sex = <span class="string">'boy'</span></span><br><span class="line">zhangsan.age = <span class="number">18</span></span><br></pre></td></tr></table></figure><p>除此以外，这些属性也可以和普通变量一样进行运算</p><p>比如zhangsan长大了一岁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan.age = zhangsan.age + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="实例属性的初始化"><a href="#实例属性的初始化" class="headerlink" title="实例属性的初始化"></a>实例属性的初始化</h3><p>上述方式定义一个实例的属性非常方便，但如果定义属性的过程中使用了不同的属性名字(比如性别，前者使用了sex，后者使用了gender)，那对于一个类的不同实例存储同一个信息就用了不同的属性，在后面将会难以维护</p><p>在定义 Person 类时，可以为Person类添加一个特殊的 <code>__init__()</code> 方法，当创建实例时， <code>__init__()</code> 方法被自动调用，我们就能在此为每个实例都统一加上以下属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, sex, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><p><strong><em>TIPS:</em></strong> </p><blockquote><p><code>__init__()</code> 方法的第一个参数必须是 self（也可以用别的名字，但建议使用习惯用法）<br>后续参数则可以自由指定，和定义函数没有任何区别</p></blockquote><p>定义类后，就可以相应的实例化对象了，在实例化的时候需要提供除self以外的所有参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangsan = Person(<span class="string">'zhang san'</span>, <span class="string">'boy'</span>, <span class="number">18</span>)</span><br><span class="line">lisi = Person(<span class="string">'li si'</span>, <span class="string">'girl'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>使用方法还是和上面一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(zhangsan.age)</span><br></pre></td></tr></table></figure><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><p>类和实例对象是有区别的，类是抽象，是模板，而实例则是根据类创建的对象</p><p>比如类：动物，只是一个抽象，并没有动物的详细信息，而猫、狗等，则是具体的动物，是类的对象(实例)</p><p>实例对象绑定的属性只属于这个实例，绑定在一个实例上的属性不会影响其它实例</p><p>同样的，类也可以绑定属性，但是类的属性不属于任何一个对象，而是属于这个类</p><p>如果在类上绑定一个属性，则所有实例都可以访问类的属性，并且，所有实例访问的类属性都是同一个</p><p>也就是说，实例属性每个实例各自拥有，互相独立，而类属性有且只有一份</p><p>定义类属性可以直接在 class 中定义</p><p>比如在动物(Animal)类中，加入地域(location)的类属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    location = <span class="string">'China'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure><p>在上面的代码中，location就是属于Animal这个类的类属性</p><p>定义之后，通过Animal()实例化的所有对象都可以访问到location并且得到唯一的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dog = Animal(<span class="string">'wangwang'</span>, <span class="number">1</span>)</span><br><span class="line">cat = Animal(<span class="string">'mimi'</span>, <span class="number">3</span>)</span><br><span class="line">print(dog.name, dog.location)</span><br><span class="line">print(cat.name, cat.location)</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/python-object-attributes/1.png" alt=""></p><h2 id="类属性和实例属性的优先级"><a href="#类属性和实例属性的优先级" class="headerlink" title="类属性和实例属性的优先级"></a>类属性和实例属性的优先级</h2><p>属性可以分为类属性和实例属性，那么如果类属性和实例属性名字相同时会怎么样?</p><p>我们在 <code>Animal</code> 类定义的基础上，初始化一个名为 <code>location</code> 的实例属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    location = <span class="string">'China'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, location)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.location = location</span><br><span class="line"></span><br><span class="line">dog = Animal(<span class="string">'wangwang'</span>, <span class="number">1</span>, <span class="string">'BeiJing'</span>)</span><br><span class="line">cat = Animal(<span class="string">'mimi'</span>, <span class="number">3</span>, <span class="string">'TianJing'</span>)</span><br><span class="line">print(dog.name, dog.location)</span><br><span class="line">print(cat.name, cat.location)</span><br><span class="line">print(Animal.location)</span><br></pre></td></tr></table></figure><p><img src="https://gengrui01.github.io/picture/python-object-attributes/2.png" alt=""></p><p>可见在类属性和实例属性同时存在的情况下实例属性的优先级是要高于类属性的</p><h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>并不是所有的属性都可以被外部访问的，不能被外部访问的属性称为私有属性，私有属性是以双下划线 <code>__</code> 开头的属性</p><h3 id="类私有属性"><a href="#类私有属性" class="headerlink" title="类私有属性"></a>类私有属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    __location = <span class="string">'China'</span></span><br></pre></td></tr></table></figure><h3 id="实例私有属性"><a href="#实例私有属性" class="headerlink" title="实例私有属性"></a>实例私有属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, location)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.__location = location</span><br><span class="line"></span><br><span class="line">dog = Animal(<span class="string">'wangwang'</span>, <span class="number">1</span>, <span class="string">'BeiJing'</span>)</span><br><span class="line">print(dog.name)</span><br><span class="line">print(dog.age)</span><br><span class="line">print(dog.__location)</span><br></pre></td></tr></table></figure><p>私有属性是为了保护类或实例属性不被外部污染而设计的，在外部访问私有属性将会抛出异常，提示没有这个属性，如下图所示：</p><p><img src="https://gengrui01.github.io/picture/python-object-attributes/3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实例属性&quot;&gt;&lt;a href=&quot;#实例属性&quot; class=&quot;headerlink&quot; title=&quot;实例属性&quot;&gt;&lt;/a&gt;实例属性&lt;/h2&gt;&lt;h3 id=&quot;实例属性的定义&quot;&gt;&lt;a href=&quot;#实例属性的定义&quot; class=&quot;headerlink&quot; title=&quot;实例属性的定义&quot;&gt;&lt;/a&gt;实例属性的定义&lt;/h3&gt;&lt;p&gt;在 &lt;a href=&quot;https://gengrui01.github.io/article/20210611.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python类的定义和实例化&lt;/a&gt; 中我们已经通过Person类创建出zhangsan、lisi等实例，但是这些实例看上去并没有任何区别&lt;/p&gt;
&lt;p&gt;在现实世界中，一个人拥有名字、性别、年龄等等的信息&lt;/p&gt;
&lt;p&gt;在Python中，可以通过以下的方式赋予实例这些属性&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.gengruiblog.cn/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python类的定义和实例化</title>
    <link href="https://www.gengruiblog.cn/article/20210611.html"/>
    <id>https://www.gengruiblog.cn/article/20210611.html</id>
    <published>2021-06-10T16:00:00.000Z</published>
    <updated>2021-07-19T10:32:19.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>在Python中，通过 <code>class</code> 关键字后跟类名定义一个类，类名以大写字母开头，整个类的内容以 <code>pass</code> 关键字结束</p><a id="more"></a><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>比如我们需要定义一个人(Person)类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>除此之外还有如下两种定义方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span>  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><p>定义了类之后，就可以对类进行实例化了，实例化是指把抽象的类赋予实物的过程</p><p>比如，定义好Person这个类后，就可以实例化多个Person出来了</p><p>创建实例使用类名()，类似函数调用的形式创建</p><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span> <span class="keyword">pass</span></span><br><span class="line">zhangsan = Person()</span><br><span class="line">lisi = Person()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类的定义&quot;&gt;&lt;a href=&quot;#类的定义&quot; class=&quot;headerlink&quot; title=&quot;类的定义&quot;&gt;&lt;/a&gt;类的定义&lt;/h2&gt;&lt;p&gt;在Python中，通过 &lt;code&gt;class&lt;/code&gt; 关键字后跟类名定义一个类，类名以大写字母开头，整个类的内容以 &lt;code&gt;pass&lt;/code&gt; 关键字结束&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.gengruiblog.cn/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python面向对象编程</title>
    <link href="https://www.gengruiblog.cn/article/20210610.html"/>
    <id>https://www.gengruiblog.cn/article/20210610.html</id>
    <published>2021-06-09T16:00:00.000Z</published>
    <updated>2021-07-19T07:50:50.573Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://gengrui01.github.io/article/20210605.html" target="_blank" rel="noopener">面向过程编程 VS 面向对象编程</a> 中有提到什么是面向对象编程</p><p>面向对象编程是一种程序设计的范式，通过面向对象编程使得我们的代码维护性更高</p><p>面向对象编程指的是将现实世界抽象并且建立起对象模型</p><a id="more"></a><h2 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h2><p>程序指的是不同对象之间相互调用的逻辑</p><p>比如人和车都是独立的对象</p><p><img src="https://gengrui01.github.io/picture/python-object-oriented/1.png" alt=""></p><p>但他们之间又存在某种关系，比如人驾驶车辆</p><p><img src="https://gengrui01.github.io/picture/python-object-oriented/2.png" alt=""></p><h2 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h2><p>将现实世界抽象并且建立起每个对象模型称为类，比如人和车</p><h2 id="什么是类的属性"><a href="#什么是类的属性" class="headerlink" title="什么是类的属性"></a>什么是类的属性</h2><p>对于每个对象都会有一些可以用来描述对象的性质</p><p>比如 人的姓名、性别、年龄等，车的厂商、型号、颜色等</p><p><img src="https://gengrui01.github.io/picture/python-object-oriented/3.png" alt=""></p><h2 id="什么是类的实例化"><a href="#什么是类的实例化" class="headerlink" title="什么是类的实例化"></a>什么是类的实例化</h2><p>将现实世界抽象并且建立起每个对象模型称为类，比如人和车</p><p>抽象出来的对象也可以实例化为现实世界中的具体事物，每个事物的属性值可以不同</p><p>比如姓名张三、性别男、年龄18的人，姓名李四、性别女、年龄18的人…</p><p>对象实例化后得到的具体事物称为实例</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;https://gengrui01.github.io/article/20210605.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面向过程编程 VS 面向对象编程&lt;/a&gt; 中有提到什么是面向对象编程&lt;/p&gt;
&lt;p&gt;面向对象编程是一种程序设计的范式，通过面向对象编程使得我们的代码维护性更高&lt;/p&gt;
&lt;p&gt;面向对象编程指的是将现实世界抽象并且建立起对象模型&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.gengruiblog.cn/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Java语言程序设计架构</title>
    <link href="https://www.gengruiblog.cn/article/20210607.html"/>
    <id>https://www.gengruiblog.cn/article/20210607.html</id>
    <published>2021-06-06T16:00:00.000Z</published>
    <updated>2021-06-17T12:17:31.552Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章用来记录Java语言从 <strong>面向对象编程</strong>、<strong>基于组件开发</strong>、<strong>面向切面编程</strong> 到 <strong>面向服务架构</strong> 的全过程</p><a id="more"></a><h2 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h2><p>面向对象编程(Object-Oriented Programming)是一种编程范式，指在设计程序时大量运用类实例对象的方式</p><p>在面向对象中，算法与数据结构被看做是一个整体，称作对象</p><p>现实世界中任何类的对象都具有一定的属性和操作，也总能用数据结构与算法两者合一地来描述</p><p>所以可以用下面的等式来定义对象和程序：</p><blockquote><p>对象 = （算法 + 数据结构）<br>程序 = （对象 + 对象 + ……）</p></blockquote><p>从上面的等式可以看出，程序就是许多对象在计算机中相继表现自己，而对象则是一个个程序实体</p><p>过去的面向过程编程常常会导致所有的代码都包含在几个模块中，在做一些修改时常常牵一动百，使程序难以阅读和维护</p><p>使用OOP技术常常要使用许多代码模块，每个模块都只提供特定的功能，它们是彼此独立的</p><p>这样就增大了代码重用的几率，更加有利于软件的开发、维护和升级</p><p>当企业的系统很小的时候，用简单的面向对象编程，数据库+服务端+浏览器就可以满足系统需求</p><h2 id="基于组件开发-CBD"><a href="#基于组件开发-CBD" class="headerlink" title="基于组件开发(CBD)"></a>基于组件开发(CBD)</h2><p>随着系统变得越来越复杂和庞大，有很多重复功能的代码，当这些重复的功能模块有变化时代码中就有很多地方要修改</p><p>这时会想到基于组件开发(Component-Based Development)，他是一种软件工程实践，设计时通常要求组件之间高内聚，松耦合</p><p>把系统中那些重复的代码统一起来，约定好接口开发成组件，基于组件再做开发</p><p>基于组件开发时更关注系统层次、子系统边界和子系统间通讯的设计</p><p>组件比起对象的进步在于他定义了一种通用的处理方式，通用规范的引入导致组件是可以替代的</p><h2 id="面向切面编程-AOP"><a href="#面向切面编程-AOP" class="headerlink" title="面向切面编程(AOP)"></a>面向切面编程(AOP)</h2><p>再随着企业变大，基于组件开发时某些方法都会用到同一个组件，每次要用到的时候都需要写一遍调用该组件的语句或者实现接口等</p><p>这时会想到面向切面编程(Aspect-Oriented Programming)，他是指通过预编译和运行期动态代理的方式实现给程序统一添加功能的目的</p><p>把重复的代码或者通用组件调用统一写入与业务代码匹配的切面中，这样业务代码中不需要重复编写或调用组件</p><p>以后再有需要调用的功能模块，直接把这个模块配置为对应切面，该切面的所有功能都会添加到此模块</p><h2 id="面向服务架构-SOA"><a href="#面向服务架构-SOA" class="headerlink" title="面向服务架构(SOA)"></a>面向服务架构(SOA)</h2><p>后来企业变成了集团公司，上线了很多套各种各样的系统</p><p>虽然大部分系统都实现了组件化，但做为一个集团公司仍然有很多共同的业务，不同系统中有很多功能重复的模块</p><p>此时又面临一个业务需求变更可能涉及多套系统升级的问题</p><p>这时会想到面向服务架构(Service-Oriented Architecture)，他是一套软件设计的原则或方法论</p><p>架构师把各个系统功能类似的模块抽象成服务，重复的模块再也没有了，不同系统间互相调用服务接口</p><p>以前要自己写一大堆代码，现在甚至不必关心所需调用服务的实现，只要知道服务接口如何调用，直接调用另一套服务的接口就OK了</p><p><strong>参考链接：</strong></p><p><a href="https://www.zhihu.com/question/20478119/answer/25292423" target="_blank" rel="noopener">面向对象、面向服务、面向组件三种编程模式有什么区别？分别适用于哪些领域的开发？ - 李黄河的回答 - 知乎</a></p><p><a href="https://blog.csdn.net/ocean181/article/details/6720371" target="_blank" rel="noopener">面向对象编程（OOP）、面向组件编程（COP）、面向方面编程（AOP）和面向服务编程（SOP）_始则转俗成真，终乃回真向俗！-CSDN博客_面向组件编程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章用来记录Java语言从 &lt;strong&gt;面向对象编程&lt;/strong&gt;、&lt;strong&gt;基于组件开发&lt;/strong&gt;、&lt;strong&gt;面向切面编程&lt;/strong&gt; 到 &lt;strong&gt;面向服务架构&lt;/strong&gt; 的全过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.gengruiblog.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>面向过程编程 VS 面向对象编程</title>
    <link href="https://www.gengruiblog.cn/article/20210605.html"/>
    <id>https://www.gengruiblog.cn/article/20210605.html</id>
    <published>2021-06-04T16:00:00.000Z</published>
    <updated>2021-06-17T12:07:30.881Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章用来区别面向过程编程(Process-Oriented Programming)和面向对象编程(Object-Oriented Programming)</p><a id="more"></a><h2 id="面向过程编程-POP"><a href="#面向过程编程-POP" class="headerlink" title="面向过程编程(POP)"></a>面向过程编程(POP)</h2><p>在使用JAVA语言之前我们常用C语言，C语言是典型的面向过程的编程语言</p><p>在C语言（或者说面向过程编程语言）中，你就是上帝（主函数就是上帝意志的体现……）</p><p>你把想做的事写到一个一个函数模块，之后在主函数中通过调用不同的函数完成不同的功能，最后达到你想到的效果（得到你想要的输出）</p><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步步实现，使用的时候依次调用就可以了</p><h2 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h2><p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题步骤中的行为</p><p>JAVA是典型的面向对象编程语言之一</p><p>在JAVA（或者说面向对象编程语言）中，你还是上帝，但是你是一个“简政放权”了的上帝</p><p>你创建了一个个对象，然后这些对象干这干那的，最后达到你想到的效果（得到你想要的输出）</p><h3 id="面向过程-VS-面向对象"><a href="#面向过程-VS-面向对象" class="headerlink" title="面向过程 VS 面向对象"></a>面向过程 VS 面向对象</h3><p>用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭</p><p>所谓蛋炒饭最后是要把鸡蛋放饭里翻炒均匀，盖浇饭就是在白米饭上面浇上一份盖菜</p><p>蛋炒饭的好处就是入味均匀，吃起来香</p><p>但如果恰巧你不爱吃鸡蛋，只爱吃青菜的话，那么唯一的办法就是全部倒掉，重新做一份青菜炒饭了</p><p>盖浇饭就没这么多麻烦，你只需要把上面的盖菜拨掉，更换一份盖菜就可以了</p><p>盖浇饭的缺点是入味不均，可能没有蛋炒饭那么香</p><p>到底是蛋炒饭好还是盖浇饭好呢？其实这类问题都很难回答，非要比个上下高低的话，就必须设定一个场景，否则只能说是各有所长</p><p>如果大家都不是美食家，没那么多讲究，那么从饭馆角度来讲的话，做盖浇饭显然比蛋炒饭更有优势，他可以组合出来任意多的组合，而且不会浪费</p><p>盖浇饭的好处就是”菜”“饭”分离，从而提高了制作盖浇饭的灵活性，饭不满意就换饭，菜不满意换菜</p><p>用软件工程的专业术语就是”可维护性”比较好，“饭” 和”菜”的耦合度比较低</p><p>蛋炒饭将”蛋”、“饭”炒在一起，想换”蛋”、”饭”中任何一种都很困难，耦合度很高，以至于”可维护性”比较差</p><p>软件工程追求的目标之一就是可维护性，可维护性主要表现在3个方面：可理解性、可测试性和可修改性</p><p>面向对象的好处之一就是显著的改善了软件系统的可维护性</p><p><strong>参考链接：</strong></p><p><a href="https://www.cnblogs.com/Libinkai/p/10505133.html" target="_blank" rel="noopener">从C到JAVA，从面向过程到面向对象 - 神的彬彬 - 博客园</a></p><p><a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">面向对象与面向过程的本质的区别_李光 未来科技-CSDN博客_面向对象和面向过程的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章用来区别面向过程编程(Process-Oriented Programming)和面向对象编程(Object-Oriented Programming)&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://www.gengruiblog.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>开发模型（瀑布、敏捷开发、DevOps）</title>
    <link href="https://www.gengruiblog.cn/article/20210603.html"/>
    <id>https://www.gengruiblog.cn/article/20210603.html</id>
    <published>2021-06-02T16:00:00.000Z</published>
    <updated>2021-06-10T13:43:01.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单打独斗的程序员"><a href="#单打独斗的程序员" class="headerlink" title="单打独斗的程序员"></a>单打独斗的程序员</h2><p>上个世纪40年代，世界上第一台计算机诞生</p><p>从诞生之日起，它就离不开程序（Program）的驱动，而负责编写程序的人，就被称为“程序员”（Programmer）</p><p>程序员是计算机的驾驭者，那个时候是极其稀缺的人才，只有高学历、名校出身的人，才有资格成为程序员</p><p>随着人类科技的不断发展，PC和Internet陆续问世，我们进入了全民拥抱信息化的时代</p><ul><li>企业用户：将计算机作为办公工具，用以提升生产力</li><li>个人用户：将计算机作为娱乐工具，用以改善生活品质</li></ul><a id="more"></a><p>于是程序逐步演进为“软件（software）”，变成了最赚钱的产品之一</p><p>而程序员有了更专业的称谓，叫做“软件开发工程师（Software Development Engineer）”</p><p>软件开发工程师的工作职责就是完成一个软件从零开始到最终交付，大概包括如下几个阶段：</p><p><img src="https://gengrui01.github.io/picture/develop-model/1.png" alt=""></p><p>起初程序比较简单工作量也不大，程序员一个人可以完成所有阶段的工作</p><h2 id="瀑布（Waterfall）模型"><a href="#瀑布（Waterfall）模型" class="headerlink" title="瀑布（Waterfall）模型"></a>瀑布（Waterfall）模型</h2><p>随着软件产业的日益发展壮大，软件的规模日益庞大，一个人已经很难集中精力完成全部交付过程</p><p>码农的队伍逐渐扩大，工种增加，除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师</p><p>软件测试工程师和软件运维工程师分担了项目构建之后的工作，软件交付过程分工如下：</p><p><img src="https://gengrui01.github.io/picture/develop-model/2.png" alt=""></p><p>分工后软件交付流程如下：</p><p>开发人员编写代码 -&gt; QA质保团队测试 -&gt; 运维团队部署</p><p>在这种流程下，我们必须要等前一个阶段的所有工作都完成了才能进入下一个阶段</p><p>我们把这种软件交付模型称为“瀑布模型”</p><p>这种模型适合用户需求非常明确、开发时间非常充足的项目，大家按部就班轮流执行自己的职责即可</p><h2 id="敏捷开发（Agile-Development）模型"><a href="#敏捷开发（Agile-Development）模型" class="headerlink" title="敏捷开发（Agile Development）模型"></a>敏捷开发（Agile Development）模型</h2><p>随着时间推移，用户对系统的需求不断增加，产品在使用过程中也是会有问题需要改进的</p><p>这个情况下，大家发现，笨重迟缓的瀑布模型已经不合时宜了，于是软件开发团队引入了“敏捷开发”的概念</p><p>敏捷开发在2000年左右开始被世人所关注，是一种以人为核心、迭代、循序渐进的开发方法，能够应对快速变化的需求</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>在说敏捷开发的本质之前我们先来解释下这里提到的一个名词——迭代（Sprint）</p><blockquote><p>迭代是指把一个开发周期很长的开发任务分解为很多个小周期任务<br>每个周期就是一次迭代的过程<br>每一次迭代都可以生产或开发出一个可以交付的软件产品</p></blockquote><p>敏捷开发的本质就是将软件项目的构建切分成多个子项目迭代进行</p><p>保证各个子项目的成果都经过测试，具备集成和可运行的特征</p><p>简单来说就是 把大项目变成小项目，把大时间点变成小时间点</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>并不追求前期完美的设计、完美编码</li><li>力求在很短的周期内开发出产品的核心功能，尽早发布出可用的版本</li><li>在后续的生产周期内，按照新需求不断迭代升级，完善产品</li></ul><h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><p>敏捷开发最常用的一种实现方式就是Scrum方式，接下来我们会讲解Scrum方式敏捷开发的软件交付流程</p><p>在讲解交付流程之前，我们需要对该流程中所涉及的角色、工件以及会议有个大概的了解</p><ul><li>角色<ul><li>PO(Product Owner 产品负责人)<ul><li>负责确定产品的功能和达到要求的标准</li><li>指定软件的发布日期和交付的内容</li><li>有权力接受或拒绝开发团队的工作成果</li></ul></li><li>SM(Scrum Manager 流程管理员)<ul><li>负责整个Scrum流程在项目中的顺利实施和进行</li><li>清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发</li><li>有些公司SM会由ST中的一员兼任</li></ul></li><li>ST(Scrum Team 开发团队)：<ul><li>软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右</li><li>每个成员可能负责不同的技术方面（前端开发、后端开发、测试等）</li><li>要求每成员必须有很强的自我管理能力和一定的表达能力</li></ul></li></ul></li><li>工件<ul><li>PB(Product Backlog 项目需求列表)：PO负责按优先级顺序排列的完整产品需求列表</li><li>SB(Sprint Backlog 迭代需求列表)：SM负责在SPM会议中产出的本次迭代需求列表大体框架，会后细化为更小的任务，控制任务周期在2天内</li><li>SBD(Sprint Burn Down 迭代燃尽图)：ST成员负责在DSM会议中更新自己的任务状态，整体就是整个迭代的完成状态图，又称燃尽图</li></ul></li><li>会议<ul><li>SPM(Sprint Plan Meeting 迭代计划会议)：根据PB讨论本次迭代需要完成的目标，控制迭代周期在1-4周，生成SB大体框架</li><li>DSM(Daily Scrum Meeting 每日站立会议)：ST成员汇报昨日工作、承诺今日工作、阐述所遇问题、更新SBD，每次会议控制在15分钟左右</li><li>Sprint Review Meeting(评审会议)：也称演示会议，ST成员向产品负责人和客户演示自己完成的软件产品</li><li>Sprint Retrospective Meeting(复盘会议)：也称为总结会议，PO、SM、ST轮流发言，总结并讨论改进的地方，放入下一轮迭代中</li></ul></li></ul><h3 id="交付流程"><a href="#交付流程" class="headerlink" title="交付流程"></a>交付流程</h3><p>理清了上面这些流程中所涉及的角色、工件以及会议，我们的交付流程自然就出来了，如下图所示：</p><p><img src="https://gengrui01.github.io/picture/develop-model/3.png" alt=""></p><ul><li>在项目启动之前，团队PO(Product Owner 产品负责人)会整理出所有的项目需求并按优先级顺序排列，为项目做出整体排期，发出PB(Product Backlog 项目需求列表)</li><li>在每一个迭代周期开始，团队PO会组织SPM(Sprint Plan Meeting 迭代计划会议)根据PB讨论本次迭代需要完成的目标，一般会将迭代周期控制在1-4周</li><li>SM(Scrum Manager 流程管理员)在SPM会后负责整理SB(Sprint Backlog 迭代需求列表)，并将需求细化成一个个小任务分配给ST(Scrum Team 开发团队)成员，一般会将任务周期控制在2天内</li><li>之后ST成员按照SB进行具体编码及测试工作<ul><li>ST成员每天早晨都会进行DSM(Daily Scrum Meeting 每日站立会议)，汇报昨日工作、承诺今日工作、阐述所遇问题</li><li>根据任务完成情况更新SBD(Sprint Burn Down 迭代燃尽图)</li></ul></li><li>SB中所有任务完成后组织Sprint Review Meeting(评审会议)，由ST成员向PO及客户演示自己的成果</li><li>评审会议结束项目发版</li><li>发版完成后组织Sprint Retrospective Meeting(复盘会议)，PO、SM、ST轮流发言，总结并讨论改进的地方，放入下一轮迭代的产品需求中</li></ul><h3 id="瀑布模型和敏捷开发模型对比"><a href="#瀑布模型和敏捷开发模型对比" class="headerlink" title="瀑布模型和敏捷开发模型对比"></a>瀑布模型和敏捷开发模型对比</h3><p>随着敏捷开发的推广，开发团队的工作效率逐渐变高，下面这个图看起来两者对比会更加清晰</p><p><img src="https://gengrui01.github.io/picture/develop-model/4.png" alt=""></p><h2 id="DevOps开发模型"><a href="#DevOps开发模型" class="headerlink" title="DevOps开发模型"></a>DevOps开发模型</h2><p>经常发版前发现有问题需要修正，简单问题还好，加班修正后继续发版就好</p><p>如果会有复杂问题出现，发版时间又已经发出去了，只好通宵想办法解决问题</p><p>随着时间推移，软件的复杂度不断攀升，每次发版之前开发、测试、运维都捏着把汗</p><p>为了按时交付软件产品和服务，为了不在饱受通宵加班苦恼，开发和运营工作必须紧密合作，随即提出了DevOps开发模型</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>DevOps这个词，其实是Development和Operations两个词的组合。它的英文发音是 /de’vɒps/，类似于“迪沃普斯”</p><p><img src="https://gengrui01.github.io/picture/develop-model/6.jpg" alt=""></p><p>维基百科定义DevOps是一组过程、方法与系统的统称，用于促进开发、技术运营和质量保障（QA）部门之间的沟通、协作与整合</p><p>DevOps就是让开发人员和运维人员更好地沟通合作，通过自动化流程来使得构建、测试、发布软件的整体过程能够更加地快捷、频繁和可靠</p><p><img src="https://gengrui01.github.io/picture/develop-model/7.jpg" alt=""></p><h3 id="交付流程-1"><a href="#交付流程-1" class="headerlink" title="交付流程"></a>交付流程</h3><p>在DevOps下，运维人员会在项目开发期间就介入到开发过程中，了解开发人员使用的系统架构和技术路线，从而制定适当的运维方案</p><p>而开发人员也会在运维的初期参与到系统部署中，并提供系统部署的优化建议</p><p><img src="https://gengrui01.github.io/picture/develop-model/9.png" alt=""></p><h3 id="DevOps开发模型和瀑布模型、敏捷开发模型对比"><a href="#DevOps开发模型和瀑布模型、敏捷开发模型对比" class="headerlink" title="DevOps开发模型和瀑布模型、敏捷开发模型对比"></a>DevOps开发模型和瀑布模型、敏捷开发模型对比</h3><p>对比前面所说的瀑布式开发和敏捷开发，我们可以明显看出，DevOps贯穿了软件全生命周期，而不仅限于开发阶段</p><p>有两个词经常会伴随着DevOps出现，那就是CI(Continuous Integration 持续集成)和CD(Continuous Delivery 持续交付)</p><p>至于什么是持续集成、持续交付，看下面这个DevOps开发模型和瀑布模型、敏捷开发模型的对比图会更加一目了然</p><p><img src="https://gengrui01.github.io/picture/develop-model/5.png" alt=""></p><p>很多人可能会觉得，“更新版本的速度快了，风险不是更大了吗？”</p><p>敲黑板，勿忘初心啊，我们使用DevOps开发模型就是为了规避发版时的风险啊</p><p>其实，更新版本的速度变快可以帮助我们更快地发现问题，产品被更快地交付到用户手中，团队可以更快地得到用户的反馈，从而进行更快地响应</p><p>而且，DevOps更新版本的变化是比较小的，相对应发版的风险也就会更小，即使出现问题修复起来也会相对容易一些（不至于通宵加班了 真香）</p><h3 id="技术支持"><a href="#技术支持" class="headerlink" title="技术支持"></a>技术支持</h3><p>想要充分落地DevOps，当然离不开软件和平台的支持，目前支持DevOps的软件实在是太多了</p><p>（现在DevOps被吹得天花乱坠肯定也有这些软件和平台的功劳，毕竟可以趁机卖钱啊）</p><p><img src="https://gengrui01.github.io/picture/develop-model/8.jpg" alt=""></p><p>现将工具类型及对应的不完全列举整理如下：</p><ul><li>代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion</li><li>构建工具：Ant、Gradle、maven</li><li>自动部署：Capistrano、CodeDeploy</li><li>持续集成（CI）：Bamboo、Hudson、Jenkins</li><li>配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail</li><li>容器：Docker、LXC、第三方厂商如AWS</li><li>编排：Kubernetes、Core、Apache Mesos、DC/OS</li><li>服务注册与发现：Zookeeper、etcd、Consul</li><li>脚本语言：python、ruby、shell</li><li>日志管理：ELK、Logentries</li><li>系统监控：Datadog、Graphite、Icinga、Nagios</li><li>性能监控：AppDynamics、New Relic、Splunk</li><li>压力测试：JMeter、Blaze Meter、loader.io</li><li>预警：PagerDuty、pingdom、厂商自带如AWS SNS</li><li>HTTP加速器：Varnish</li><li>消息总线：ActiveMQ、SQS</li><li>应用服务器：Tomcat、JBoss</li><li>Web服务器：Apache、Nginx、IIS</li><li>数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库</li><li>项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker</li></ul><p>在工具的选择上，需要结合公司业务需求和技术团队情况而定</p><p>（注：更多关于工具的详细介绍可以参见此文：51 Best DevOps Tools for #DevOps Engineers）</p><h3 id="DevOps-Dev-Ops-？"><a href="#DevOps-Dev-Ops-？" class="headerlink" title="DevOps = Dev + Ops ？"></a>DevOps = Dev + Ops ？</h3><p>很多人可能觉得，所谓DevOps，不就是Dev+Ops嘛，直接把团队合并，或者将所有人员划归开发</p><p>这种理解完全曲解了DevOps开发模式的思想，甚至有点回到类似最初程序员单打独斗的模式了</p><p>DevOps并不仅仅是组织架构变革，更是企业文化和思想观念的变革</p><p>所以他的实现考验的也不仅是一家企业的技术（毕竟有上面那些软件和平台提供技术支持），更是管理水平和企业文化</p><p><strong>参考链接：</strong></p><p><a href="https://www.zhihu.com/question/58702398/answer/1691681949" target="_blank" rel="noopener">什么是DevOps？ - UCloud云计算回答 - 知乎</a></p><p><a href="https://blog.csdn.net/csdn15556927540/article/details/90712308" target="_blank" rel="noopener">什么是敏捷开发？_好记性不如烂笔头-CSDN博客_敏捷开发</a></p><p><a href="https://blog.csdn.net/sinat_35566306/article/details/90404606" target="_blank" rel="noopener">开发模式（敏捷开发，瀑布式开发，螺旋型开发，迭代开发，devOps开发）_sinat_35566306的博客-CSDN博客_瀑布式开发</a></p><p><a href="https://zhuanlan.zhihu.com/p/133219596" target="_blank" rel="noopener">敏捷开发和DevOps - 知乎</a></p><p><a href="https://www.jianshu.com/p/c5d002cf25b9" target="_blank" rel="noopener">Devops - 简书</a></p><p><a href="https://www.processon.com/view/5f07d97d7d9c087fac021e5d" target="_blank" rel="noopener">DevOps敏捷开发架构图 | ProcessOn免费在线作图 |</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单打独斗的程序员&quot;&gt;&lt;a href=&quot;#单打独斗的程序员&quot; class=&quot;headerlink&quot; title=&quot;单打独斗的程序员&quot;&gt;&lt;/a&gt;单打独斗的程序员&lt;/h2&gt;&lt;p&gt;上个世纪40年代，世界上第一台计算机诞生&lt;/p&gt;
&lt;p&gt;从诞生之日起，它就离不开程序（Program）的驱动，而负责编写程序的人，就被称为“程序员”（Programmer）&lt;/p&gt;
&lt;p&gt;程序员是计算机的驾驭者，那个时候是极其稀缺的人才，只有高学历、名校出身的人，才有资格成为程序员&lt;/p&gt;
&lt;p&gt;随着人类科技的不断发展，PC和Internet陆续问世，我们进入了全民拥抱信息化的时代&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;企业用户：将计算机作为办公工具，用以提升生产力&lt;/li&gt;
&lt;li&gt;个人用户：将计算机作为娱乐工具，用以改善生活品质&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://www.gengruiblog.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
</feed>
