[{"title":"MyBatis简介","date":"2021-02-26T16:00:00.000Z","path":"article/20210227.html","text":"概念MyBatis 是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射 与其它ORM框架不同，MyBatis没有将Java对象与数据表关联起来，而是作为Java方法和SQL语句的桥梁，我们一般称它为半ORM框架 功能 方便地定制化SQL，操作数据库对象 使用简单的XML或注解来配置和映射原生类、接口和Java的POJO为数据库中的记录 提供强大的动态SQL功能，可以更加灵活地使用SQL语句 提供插件增强机制，可以轻松集成其它插件 Hibernate与MyBatis对比 Hibernate 全自动化ORM框架，数据库移植性好，基础业务几乎不需要写SQL 易学难精，上手简单但熟练使用需要阅读大量文档，框架结构复杂 MyBatis 半自动化ORM框架，数据库移植性一般，基础业务仍需写SQL，但可以通过基础Mapper来简化 易学易用，上手简单，结构精简清晰，易深入学习 对比结果： Hibernate适合在需求明确、业务固定的项目中使用，如OA、ERP项目 MyBatis适合在需求多变，快速迭代的项目中使用，如互联网的电商项目","tags":[]},{"title":"ORM程序技术","date":"2021-02-25T16:00:00.000Z","path":"article/20210226.html","text":"JDBC操作数据库步骤JDBC连接及操作数据库 注册驱动 获取连接 获取statement对象 执行SQL语句返回结果集 遍历结果集 关闭连接释放资源 原生JDBC连接及操作数据库有几个缺点： 某条语句执行失败时的处理逻辑非常复杂 要对其中某些业务逻辑做修改，改动代码量较大 概念ORM是对象(Object)、关系(Relational)、映射(Mapping)的缩写，是一种用于实现面向对象编程语言里不同类型系统的数据之间转换的程序技术 作用Java是一门面向对象语言，几乎所有的程序中都存在对象和关系数据库 当对象信息发生变化的时候，我们需要去改数据库中的数据 ORM会把对SQL的操作转换为对象的操作，从而让程序员使用起来更加方便和易于接受 一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段 12345678class Person&#123; Integer id; String name; Integer gender; Date birthday; ...... ......&#125; id name gender birthday 1 Anne female 1999-01-01 2 Bob male 1998-08-21 由于类和表之间、属性和字段之间建立起了映射关系，所以SQL对表的操作就可以转换为对象的操作 程序员从此无需编写SQL语句，由框架根据对象的变化及映射关系自动生成SQL语句，这就是ORM的作用 优势 提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 ORM提供了对数据库的映射，不用SQL直接编码，能够像操作对象一样从数据库获取数据","tags":[]},{"title":"SpringMVC简介","date":"2021-02-24T16:00:00.000Z","path":"article/20210225.html","text":"概念SpringMVC是Spring生态圈中的WEB-MVC框架 SpringMVC和Spring的关系由于Spring的概念有狭义广义两种理解方式，SpringMVC和Spring的关系可以从如下两个角度理解： 水平角度：SpringMVC是Spring生态圈中的一个功能模块，两者是包含与被包含的关系； 垂直角度：SpringMVC是建立在Spring核心功能之上的一个WEB-MVC框架，是Spring核心功能的延伸和扩展。 Struts2与SpringMVC对比 Struts2很多功能也需要借助于Spring实现，SpringMVC和Spring有直属血缘的关系，两者吻合度更高 使用SpringMVC时所需要的其他逻辑组件都经由IOC创建Spring容器管理，可根据组件特性保证其线程安全性 SpringMVC利用DI功能，能轻松地装配好各组件之间的依赖，开发者只需要关注编写自己的业务逻辑便可","tags":[]},{"title":"MVC设计模式","date":"2021-02-23T16:00:00.000Z","path":"article/20210224.html","text":"WEB应用WEB应用程序的主流开发技术有 3 种： Servlet PHP .net Servlet是基于Java语言的动态WEB开发技术，Servlet指的是J2EE中所提出来的企业级服务器开发规范。 理论上讲，每一次不同的http请求需要一个Servlet组件来响应，当请求类型比较多时，Servlet就会相应增加，也意味着每一个Servlet都可以成为进入服务器的入口。 原生Servlet构建的MVC开发模式有几个缺点： Servlet本身采用单例设计模式，生命周期由服务器维护，存在线程安全隐患的问题； 随着Servlet数量的增加，对服务器的存储空间也会产生压力； 使用Servlet响应用户请求时，每一个响应逻辑都需要开发者不厌其烦地做些重复的事情，如，解析请求包中的数据、构建响应包、设置页面跳转等等。 概念MVC是模型(Model)、视图(View)、控制器(Controller)的缩写，是一种分离显示业务逻辑、数据和界面的设计模式 组件关系 模型（Model）表示应用程序核心，是应用程序中用于处理应用程序数据逻辑的部分，通常负责在数据库中存取数据。 视图（View）用来显示数据，是应用程序中处理数据显示的部分，通常View是依据Model的数据而创建的。 控制器（Controller）用来处理用户输入并调用模型和视图来满足用户的需求，是应用程序中处理用户交互的部分，通常Controller负责从View读取数据，控制用户输入，并向Model发送数据。 请求响应流程 优势 低耦合性：MVC的视图层和业务层是分离的，如果项目的业务流程或业务规则有所更改，只需要更改MVC的Model层，不需要重新更改编译View和Controller的代码内容。 高可重用性：MVC模式允许不同类型的View访问相同的服务器端代码，多个View可以共享一个Model，它包括任何WEB浏览器(HTTP)或无线浏览器(WAP)，因为这些表示所需要改变的只有View层的实现方式，Model层和Controller层不需要做任何改变。 低生命周期成本：MVC降低了用户界面开发和维护的技术需求，从而降低了生命周期成本 快速部署：使用MVC模式可以大大缩短开发时间，允许后端开发人员只关注业务逻辑，而前端开发人员只需要关注页面的表现形式。 高可维护性：前后端分离使得WEB应用程序更易于维护和修改。","tags":[]},{"title":"Spring简介","date":"2021-02-22T16:00:00.000Z","path":"article/20210223.html","text":"为什么使用Spring？Spring官网 Spring官网首页滚动显示如下内容： Spring makes Java simple. Spring makes Java modern. Spring makes Java productive. Spring makes Java reactive. Spring makes Java cloud-ready. Spring使Java简单易用、紧跟时代、复用性强、快速响应、云就绪。 体系结构介绍 结构图阐释： Data Access/Integration：持久层 是Spring对数据持久化、事务管理的支持。SpringDataJpa就是其中的一种 Web：表现层 是Spring对表现层数据的处理部分的支持。SpirngMVC就是其中的一种 Test：测试层 是Spring对项目提供的一个完整测试环境 中间的两部分 是Spring框架的核心功能 概念Spring刚出世时，仅提供了一些核心功能模块 其中IOC&amp;DI和AOP两大两大核心模块对企业项目开发过程产生了巨大的影响 后来，Spring在核心功能的的基础之上，延伸出更多的功能模块 由这些功能模块为企业项目开发提供了较完整的、全方位的解决方案 所以Spring概念在狭义及广义角度理解不同： 狭义角度：Spring指的是Spring框架核心功能模块 广义角度：Spring是一个提供了众多功能模块的生态圈 核心功能控制反转(IOC) &amp; 依赖注入(DI)控制反转(IOC)简单理解IOC是一种设计模式，将实例化对象的控制权由手动的new变成了Spring框架通过反射机制实例化，并将对象的实例存入在容器种进行管理 依赖注入(DI)首先理解依赖，程序运行的需要可以称之为依赖 如果一个类中的某个属性是另一个类，该属性无需手动赋值，通过Spring的配置文件或者注解，通过Spring框架可以实现直接注入属性 IOC &amp; DI 联合使用B类中需要使用A类时： 未引入Spring框架 12345class B&#123; A a = new A(); ...... ......&#125; 引入Spring框架后 面向切面编程(AOP)首先理解切面，切面是数学中的一个概念，和球面只有一个交点的平面称作球的切面，而接触点称作切点 在Spring中，切面编程指的就是在程序运行某个方法的时候，不修改原始执行代码逻辑，由程序动态地执行某些额外的功能，对原有的方法做增强，这就叫做面向切面编程，那个被监测的执行方法，称呼为切入点。 优势Spring框架以控制反转(IOC)和面向切面编程(AOP)为内核，提供了展现层(SpringMVC)、持久层(SpringJDBC)、业务层事务管理等众多的企业级应用技术，还能整合其他第三方开源框架和类库。 对于对象的实例管理更加方便，代码编写更加优雅，降低代码的耦合性，提升代码的可扩展性。","tags":[]},{"title":"SSH和SSM的区别","date":"2021-02-21T16:00:00.000Z","path":"article/20210222.html","text":"SSH &amp; SSMSSH是Spring+Struts2+Hibernate的缩写，是一种较主流的Java企业级应用框架。 SSM是Spring+SpringMVC+MyBatis的缩写，是继SSH之后，目前比较主流的Java企业级应用框架。 本质上都是Spring框架+MVC模式框架+ORM技术框架 Spring Spring简介 Struts2简介 Struts2是一个基于 MVC设计模式 的表现层框架，Struts2作为控制器来建立模型与视图的数据交互。 缺点 校验较繁琐，多字段时出错返回不同。 安全性太低。 获取传参时较麻烦 SpringMVC SpringMVC简介 Hibernate简介 Hibernate是一个基于 ORM程序技术 的持久层框架，与各种数据库，SQL语句打交道，是数据持久化的一种解决方案。 缺点： 持久层封装过于完整，导致开发人员无法对SQL进行优化，无法灵活应用原生SQL 批量数据处理能力较弱势 导致配置过于复杂，遇到大项目，维护和问题不断 MyBatis MyBatis简介","tags":[]},{"title":"安装MySQL并配置环境变量(以MySQL8为例)","date":"2021-02-20T16:00:00.000Z","path":"article/20210221.html","text":"下载官方下载地址：MySQL :: MySQL Downloads 这是MySQL的官方下载页面，我们安装社区版的MySQL，页面下拉点击“MySQL Community (GPL) Downloads”按钮 接下来跳转到这个页面，点击下载社区版的服务器 确认我们的电脑系统，下载免安装版 此时需要注册用户并登录，我们可以点击下方的“No thanks, just start my download.”按钮跳过登录直接下载 等待压缩包下载完成即可 把下载完成的压缩包解压到指定目录下，要注意路径中不能有中文 配置初始化的my.ini文件在解压后的目录下自行创建my.ini配置文件，使用记事本打开后写入如下配置： 其中安装目录和数据库的数据的存放目录需要根据自己的安装目录进行调整，要和解压后的文件夹目录一致 12345678910111213141516171819202122232425[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=解压后的文件夹目录 例如：D:\\\\software\\mysql-8.0.23-winx64# 设置mysql数据库的数据的存放目录datadir=解压后的文件夹目录后加“\\Data” 例如：D:\\\\software\\mysql-8.0.23-winx64\\Data# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为utf8mb4character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8mb4 这里需要注意我们的数据存放目录为“安装目录\\Data”，Data文件夹不需要自己创建 安装服务并初始化虽然我我们下载的是免安装版，还是要用命令安装MySQL服务并且初始化MySQL 以管理员身份打开控制台，一定要是管理员身份，否则后续部分命令会出现权限错误，点此链接查看如何以管理员身份打开CMD控制台（详解-百度经验） 安装服务转到mysql安装目录的bin目录下 使用.\\mysqld --install命令安装MySQL服务 初始化MySQL使用.\\mysqld --initialize --console命令初始化MySQL 初始化会产生一个随机密码，需要复制下来，后面第一次登录会用到 启动服务使用net start mysql命令开启mysql的服务 使用MySQL登录命令mysql -u root -p随机密码，出现如下界面表示安装成功 修改密码使用如下SQL语句修改root用户密码 1alter user \"root\"@\"localhost\" identified by \"新的密码\"; 提示“Query OK”表示命令执行成功 退出登陆后使用新密码登录，验证密码是否修改成功 关闭控制台 环境变量配置环境变量复制MySQL安装目录下bin目录绝对路径 鼠标右键我的电脑-属性 会进入到可以查看计算机基本信息的系统页 点击左侧“高级系统设置” 会弹出“系统属性”对话框 之后点击“环境变量” 会弹出“环境变量”对话框 选中用户变量下的PATH变量，点击“编辑” 弹出“编辑环境变量”对话框，点击新建，粘贴刚才复制的MySQL安装目录下bin目录绝对路径，点击确定 依次点击“环境变量”对话框和“系统属性”对话框中的确定按钮，完成MySQL环境变量配置 检测环境变量是否配置成功WIN+R键打开运行框，输入cmd点击确定打开控制台 输入mysql -u root -p自设密码验证是否可直接登录，登录成功表示配置成功","tags":[]},{"title":"安装JDK并配置环境变量(以Java8为例)","date":"2021-02-19T16:00:00.000Z","path":"article/20210220.html","text":"下载官方下载地址：JavaSE-Downloads 这是所有版本JDK的下载页面，我们安装Java8版本，往下拉找到JavaSE8，单击JDK Download 在Java SE Development Kit 8u281中找到自己的电脑版本，点击右侧下载按钮 勾选接受协议，点击下载 此时需要注册用户并登录 登录成功后会自动下载，等待安装包下载完成 安装双击打开下载好的安装包，点击下一步即可 点击“更改”可以修改安装路径，修改时要注意路径中不能有中文 也可以使用默认路径不做修改（要记住这个路径，之后配置环境变量会用到） 我们安装的JDK中已经包含了JRE，所以不需要安装“公共JRE” 点击“公共JRE”前面的下拉框，选择第三项“此功能将不可用” 选择好后如下图所示，“公共JRE”前面会变成红色的“X”，之后点击下一步 之后等待安装 安装完成会弹出如下页面，点击关闭 环境变量新建JAVA_HOME环境变量鼠标右键我的电脑-属性 会进入到可以查看计算机基本信息的系统页 点击左侧“高级系统设置” 会弹出“系统属性”对话框 之后点击“环境变量” 会弹出“环境变量”对话框 在用户变量下点击“新增” 新建一个用户变量，变量名为 JAVA_HOME ，变量值为刚才的安装路径，之后点击确定 编辑PATH变量选中PATH变量，点击“编辑” 弹出“编辑环境变量”对话框 新建两个PATH变量分别是%JAVA_HOME%\\bin和%JAVA_HOME%\\jre\\bin 两个PATH变量都新建好后点击确定 新建JAVA_HOME环境变量继续在“环境变量”对话框中的用户变量下点击“新增” 输入变量名CLASSPATH，变量值.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar;，点击确定 依次点击“环境变量”对话框和“系统属性”对话框中的确定按钮，完成JDK环境变量配置 检测环境变量是否配置成功WIN+R键打开运行框，输入cmd点击确定打开控制台 分别输入java -version和javac -version查看JDK版本，结果如图所示表示安装及配置成功","tags":[]},{"title":"git的安装与配置","date":"2021-02-18T16:00:00.000Z","path":"article/20210219.html","text":"下载并安装官方下载地址：Git-Downloads 安装方法：无特殊需求直接下一步即可 配置git设置Git的用户名和邮件地址（邮箱就是注册Github时候的邮箱） 12$ git config --global user.name \"gengrui01\"$ git config --global user.email \"12******09@qq.com\" Git-GitHub建立联系（SSH）删除原有SSH配置检查电脑是否有ssh配置 1$ ls -al ~/.ssh 出现下面提示表示无ssh配置 1ls: cannot access '/c/Users/HUAWEI/.ssh': No such file or directory 如果未提示上述内容表示已经有ssh配置，需要删除用户文件夹下.ssh文件夹中的所有文件 生成SSH密钥键入命令，注意这里需要输入注册Github时候的邮箱地址，停顿的地方一路回车 1$ ssh-keygen -t rsa -C \"12******09@qq.com\" 之后键入命令 12$ ssh-agent -s$ ssh-add ~/.ssh/id_rsa 如果出现如下错误 1Could not open a connection to your authentication agent. 先执行命令 1$ ssh-agent bash 再重新执行 1$ ssh-add ~/.ssh/id_rsa 添加SSH密钥到GitHub账户执行如下命令复制密钥 1$ clip &lt; ~/.ssh/id_rsa.pub 之后打开GitHubhttps://github.com/GengRui01 ，其中“GengRui01”为用户名 按下图步骤打开设置页 单击左边标签栏中的 SSH and GPG keys 打开密钥管理页 单击 New SSH key 添加SSH密钥 title可以随意输入，key直接粘贴刚才复制好的密钥即可 最后点击添加按钮完成SSH密钥添加","tags":[]},{"title":"IDEA安装破解教程(转发)","date":"2021-02-17T16:00:00.000Z","path":"article/20210218.html","text":"此文章为转载文章 原文作者：诸葛借剑 原文平台：博客园 原文链接：IDEA安装破解教程 如下是正文内容： 一、 下载安装包1.1 方式1 百度网盘链接链接：单击此处百度网盘下载 提取码：68m8 1.2 方式2 官网下载单击此处官网下载 二、 安装IDEA 双击 ideaIU-2020.1.exe 跟着图片走 安装完毕 三、 破解IDEA 在IDEA的安装路径旁 新创建一个文件夹，不要有中文。将第一步骤下载的 其他三个文件 移动到 这个新创建的文件夹中 进入启动页，把jetbrains-agent-latest.jar拖入到启动页 点击【为IDEA安装】 跟着图片走 破解完成 此文章为转载文章 原文作者：诸葛借剑 原文平台：博客园 原文链接：IDEA安装破解教程","tags":[]},{"title":"博客改版","date":"2020-07-17T16:00:00.000Z","path":"article/20200718.html","text":"改版计划及目前进度博客改版开始啦，这次的改版主要将博客主题修改为简洁轻量的BlueLake主题 博客部署在每次完成文档修改后执行如下指令完成部署（先生成后上传） 12$ hexo generate$ hexo deploy 备份每次部署完成后执行如下指令完成备份 123$ git add .$ git commit -m \"...\"$ git push 更换开发环境备份的目的是满足异地工作的需求，更换开发环境时只需要安装git和node，执行如下操作即可 安装IDEA IDEA的安装及破解方法见往期文章IDEA的安装与破解 安装git 配置git git的安装及配置方法见往期文章git的安装与配置 idea拉取Hexo-admin备份文件 安装hexo 12345$ cd Hexo-admin$ npm install -g hexo-cli$ npm install hexo$ npm install$ npm install hexo-deployer-git --save","tags":[]},{"title":"JDBC连接及操作数据库","date":"2018-10-24T16:00:00.000Z","path":"article/20181025.html","text":"JDBC连接数据库 连接数据库步骤第一步：注册驱动 第二步：获取连接 第三步：获取statement对象 第四步：执行SQL语句返回结果集 第五步：遍历结果集 第六步：关闭连接释放资源 传统方式连接数据库123456789101112131415161718192021222324public class JDBCDemo &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2.获取连接 Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/ssm\", \"root\", \"root\"); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from tb_user\"); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(\"username\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125; 用这种方式连接数据库存在一个重要的问题： 注册驱动时，当前类和MySQL的驱动类有很强的依赖关系。 当我们没有驱动类的时候，连编译都不能通过。 这种调用者与被调用者之间的依赖关系，就叫做程序的耦合，耦合分为高耦合（紧密联系）和低耦合（松散联系） 我们在开发中，理想的状态应该是编译时不依赖，运行时才依赖。 要做到编译时不依赖，就需要使用反射来创建类对象。 即将注册驱动部分的代码稍作修改如下： 编译时不依赖的数据库连接12345678910111213141516171819202122232425public class JDBCDemo &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接 Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/ssm\", \"root\", \"root\"); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from tb_user\"); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(\"username\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125; 这样做的好处是，我们的类中不再依赖具体的驱动类，此时就算删除mysql的驱动jar包依然可以通过编译，只不过因为没有驱动类所以不能运行罢了。 不过，此处还有一个问题，就是我们反射类对象的全限定类名称是在java类中写死的，数据库的端口号、用户名密码也是写死的，一旦要修改就等于是要修改源码。自己小打小闹写的代码改源码什么的还好说，但如果是上线项目，改源码势必要停服务器重新编运行。 这么看来这个问题造成的后果很严重，其实它的解决方法也很简单，使用配置文件配置数据库连接信息就可以啦。 使用配置文件连接数据库配置文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.username=rootjdbc.password=root 代码实现12345678910111213141516171819202122232425262728293031323334public class JDBCDemoPro &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //读取配置文件db.properties Properties prop = new Properties(); prop.load(new FileInputStream(\"db.properties\")); //获取配置文件中的相关参数值 String driver = prop.getProperty(\"jdbc.driver\"); String url = prop.getProperty(\"jdbc.url\"); String user = prop.getProperty(\"jdbc.username\"); String password = prop.getProperty(\"jdbc.password\"); //1.注册驱动 Class.forName(driver); //2.获取连接 Connection connection = DriverManager.getConnection(url, user, password); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from tb_user\"); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(\"username\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125;","tags":[]},{"title":"类加载机制","date":"2018-07-17T16:00:00.000Z","path":"article/20180718.html","text":"类的生命周期 加载 找到类文件（通过类的全限定名来获取定义此类的二进制字节流） 放入方法区（将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构） 开个入口（生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口） 连接 校验（检查Class文件的字节流中包含的信息是否符合当前虚拟机的要求） 准备（为静态变量和静态常量分配内存，并给静态常量赋设定值，静态变量赋初始值） 解析（jvm将常量池的符号引用替换为直接引用） 初始化(为静态变量赋程序设定的初值，类只有在如下五种情况下会初始化) 使用new关键字创建类的实例，或读取或设置一个静态字段的值，或调用静态方法的时候 通过java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要首先进行初始化 当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化 当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类 使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REFgetStatic、REFputStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化 使用 卸载 类加载器 启动类加载器(BootStrapClassLoader) 负责加载Java的核心库 是用原生代码来实现的 并不继承自java.lang.ClassLoader 扩展类加载器(ExtClassLoader) 负责加载Java的扩展库 在虚拟机实现时提供的扩展库目录里面查找并加载Java类 应用程序类加载器(AppClassLoader) 负责加载classpath路径下的Java类 一般来说 Java应用的类都是由它来完成加载的 可以通过ClassLoader.getSystemClassLoader()来获取它 用户自定义类加载器 用户根据自定义需求，自由的定制加载的逻辑 一般都继承AppClassLoader，仅仅覆盖findClass()方法，继续遵守双亲委派模型 如上四种类加载器之间存在继承关系，除了引导类加载器外，其他的加载器都可以用getParent()方法获取父类加载器 类加载机制类的加载机制是双亲委派机制，工作过程如下： 当前加载器从自己的缓存中查询是否此类已经加载，有就返回加载好的类（每个类加载器都有自己的加载缓存，已经加载的类都会放入缓存中） 当前加载器的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到启动类加载器 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回 双亲委派的优点是： 保证 Java 程序安全稳定运行，Java 核心 API 定义类型不会被随意替换。比如自己写的String.class类就不会被加载 通过带有优先级的层级关可以避免类的重复加载","tags":[]}]