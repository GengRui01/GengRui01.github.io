[{"title":"Python对象的方法","date":"2021-06-12T16:00:00.000Z","path":"article/20210613.html","text":"在 Python对象的属性 中我们知道了私有属性只能在类的内部操作，没有办法从外部访问 但是如果外部需要操作私有属性怎么办？这个时候可以通过定义类或者实例的方法来操作私有属性 本文就来介绍如何定义类或者实例的方法 实例方法实例的方法指的就是在类中定义的函数，实例方法的第一个参数永远都是 self ， self 是一个引用，指向调用该方法的实例对象本身，除此以外，其他参数和普通函数是完全一样的 12345class Person: def __init__(self, name): self.__name = name def getName(self): return self.__name 在上面的定义， name 是实例的私有属性，从外部是无法访问的，而 get_name(self) 就是一个实例方法，在实例方法里面是可以操作私有属性的 12p = Person(\"Anne\")print(p.getName()) 当然，实例方法并不仅仅是为私有属性服务的，我们可以把和类的实例有关的操作都抽象成实例方法 比如：打印实例的详细信息等等 12345678910class Animal: def __init__(self, name, age, location): self.name = name self.age = age self.__location = location def getInfo(self): return 'name = &#123;&#125;, age = &#123;&#125;, location = &#123;&#125;'.format(self.name, self.age, self.__location)dog = Animal('wangwang', 1, 'BeiJing')print(dog.getInfo()) 类方法为了操作实例对象的私有属性我们定义了实例方法，同样的如果需要需要操作类的私有属性则应该定义类方法 实例方法的第一个参数 self 指向调用该方法的实例对象本身 类方法的第一个参数永远都是 cls ， cls 也是一个引用，指向类本身 类方法需要使用 @classmethod 来标记为类方法 123456789101112131415class Animal: __location = 'China' def __init__(self, name, age): self.name = name self.age = age @classmethod def setLocation(cls, location): cls.__location = location @classmethod def getLocation(cls): return cls.__locationprint(Animal.getLocation())Animal.setLocation('BeiJing')print(Animal.getLocation()) 因为是在类上调用而不是在实例上调用，所以类方法无法获得任何实例变量，只能获得类的引用","tags":[]},{"title":"Python对象的属性","date":"2021-06-11T16:00:00.000Z","path":"article/20210612.html","text":"实例属性实例属性的定义在 Python类的定义和实例化 中我们已经通过Person类创建出zhangsan、lisi等实例，但是这些实例看上去并没有任何区别 在现实世界中，一个人拥有名字、性别、年龄等等的信息 在Python中，可以通过以下的方式赋予实例这些属性 123zhangsan.name = 'zhangsan'zhangsan.sex = 'boy'zhangsan.age = 18 除此以外，这些属性也可以和普通变量一样进行运算 比如zhangsan长大了一岁： 1zhangsan.age = zhangsan.age + 1 实例属性的初始化上述方式定义一个实例的属性非常方便，但如果定义属性的过程中使用了不同的属性名字(比如性别，前者使用了sex，后者使用了gender)，那对于一个类的不同实例存储同一个信息就用了不同的属性，在后面将会难以维护 在定义 Person 类时，可以为Person类添加一个特殊的 __init__() 方法，当创建实例时， __init__() 方法被自动调用，我们就能在此为每个实例都统一加上以下属性 12345class Person: def __init__(self, name, sex, age): self.name = name self.sex = sex self.age = age TIPS: 方法的第一个参数必须是 self（也可以用别的名字，但建议使用习惯用法）1234567后续参数则可以自由指定，和定义函数没有任何区别定义类后，就可以相应的实例化对象了，在实例化的时候需要提供除self以外的所有参数&#96;&#96;&#96;pythonzhangsan &#x3D; Person(&#39;zhang san&#39;, &#39;boy&#39;, 18)lisi &#x3D; Person(&#39;li si&#39;, &#39;girl&#39;, 18) 使用方法还是和上面一样 1print(zhangsan.age) 类属性类和实例对象是有区别的，类是抽象，是模板，而实例则是根据类创建的对象 比如类：动物，只是一个抽象，并没有动物的详细信息，而猫、狗等，则是具体的动物，是类的对象(实例) 实例对象绑定的属性只属于这个实例，绑定在一个实例上的属性不会影响其它实例 同样的，类也可以绑定属性，但是类的属性不属于任何一个对象，而是属于这个类 如果在类上绑定一个属性，则所有实例都可以访问类的属性，并且，所有实例访问的类属性都是同一个 也就是说，实例属性每个实例各自拥有，互相独立，而类属性有且只有一份 定义类属性可以直接在 class 中定义 比如在动物(Animal)类中，加入地域(location)的类属性： 12345class Animal: location = 'China' def __init__(self, name, age): self.name = name self.age = age 在上面的代码中，location就是属于Animal这个类的类属性 定义之后，通过Animal()实例化的所有对象都可以访问到location并且得到唯一的结果 1234dog = Animal('wangwang', 1)cat = Animal('mimi', 3)print(dog.name, dog.location)print(cat.name, cat.location) 类属性和实例属性的优先级属性可以分为类属性和实例属性，那么如果类属性和实例属性名字相同时会怎么样? 我们在 Animal 类定义的基础上，初始化一个名为 location 的实例属性 123456789101112class Animal: location = 'China' def __init__(self, name, age, location): self.name = name self.age = age self.location = locationdog = Animal('wangwang', 1, 'BeiJing')cat = Animal('mimi', 3, 'TianJing')print(dog.name, dog.location)print(cat.name, cat.location)print(Animal.location) 可见在类属性和实例属性同时存在的情况下实例属性的优先级是要高于类属性的 私有属性并不是所有的属性都可以被外部访问的，不能被外部访问的属性称为私有属性，私有属性是以双下划线 __ 开头的属性 类私有属性12class Animal: __location = 'China' 实例私有属性12345678910class Animal: def __init__(self, name, age, location): self.name = name self.age = age self.__location = locationdog = Animal('wangwang', 1, 'BeiJing')print(dog.name)print(dog.age)print(dog.__location) 私有属性是为了保护类或实例属性不被外部污染而设计的，在外部访问私有属性将会抛出异常，提示没有这个属性，如下图所示：","tags":[]},{"title":"Python类的定义和实例化","date":"2021-06-10T16:00:00.000Z","path":"article/20210611.html","text":"类的定义在Python中，通过 class 关键字后跟类名定义一个类，类名以大写字母开头，整个类的内容以 pass 关键字结束 使用示例比如我们需要定义一个人(Person)类 1class Person: pass 除此之外还有如下两种定义方式 12class Person(): passclass Person(object): pass 类的实例化定义了类之后，就可以对类进行实例化了，实例化是指把抽象的类赋予实物的过程 比如，定义好Person这个类后，就可以实例化多个Person出来了 创建实例使用类名()，类似函数调用的形式创建 使用示例123class Person: passzhangsan = Person()lisi = Person()","tags":[]},{"title":"Python面向对象编程","date":"2021-06-09T16:00:00.000Z","path":"article/20210610.html","text":"在 面向过程编程 VS 面向对象编程 中有提到什么是面向对象编程 面向对象编程是一种程序设计的范式，通过面向对象编程使得我们的代码维护性更高 面向对象编程指的是将现实世界抽象并且建立起对象模型 对象之间的关系程序指的是不同对象之间相互调用的逻辑 比如人和车都是独立的对象 但他们之间又存在某种关系，比如人驾驶车辆 什么是类将现实世界抽象并且建立起每个对象模型称为类，比如人和车 什么是类的属性对于每个对象都会有一些可以用来描述对象的性质 比如 人的姓名、性别、年龄等，车的厂商、型号、颜色等 什么是类的实例化将现实世界抽象并且建立起每个对象模型称为类，比如人和车 抽象出来的对象也可以实例化为现实世界中的具体事物，每个事物的属性值可以不同 比如姓名张三、性别男、年龄18的人，姓名李四、性别女、年龄18的人… 对象实例化后得到的具体事物称为实例","tags":[]},{"title":"Java语言程序设计架构","date":"2021-06-06T16:00:00.000Z","path":"article/20210607.html","text":"这篇文章用来记录Java语言从 面向对象编程、基于组件开发、面向切面编程 到 面向服务架构 的全过程 面向对象编程(OOP)面向对象编程(Object-Oriented Programming)是一种编程范式，指在设计程序时大量运用类实例对象的方式 在面向对象中，算法与数据结构被看做是一个整体，称作对象 现实世界中任何类的对象都具有一定的属性和操作，也总能用数据结构与算法两者合一地来描述 所以可以用下面的等式来定义对象和程序： 对象 = （算法 + 数据结构）程序 = （对象 + 对象 + ……） 从上面的等式可以看出，程序就是许多对象在计算机中相继表现自己，而对象则是一个个程序实体 过去的面向过程编程常常会导致所有的代码都包含在几个模块中，在做一些修改时常常牵一动百，使程序难以阅读和维护 使用OOP技术常常要使用许多代码模块，每个模块都只提供特定的功能，它们是彼此独立的 这样就增大了代码重用的几率，更加有利于软件的开发、维护和升级 当企业的系统很小的时候，用简单的面向对象编程，数据库+服务端+浏览器就可以满足系统需求 基于组件开发(CBD)随着系统变得越来越复杂和庞大，有很多重复功能的代码，当这些重复的功能模块有变化时代码中就有很多地方要修改 这时会想到基于组件开发(Component-Based Development)，他是一种软件工程实践，设计时通常要求组件之间高内聚，松耦合 把系统中那些重复的代码统一起来，约定好接口开发成组件，基于组件再做开发 基于组件开发时更关注系统层次、子系统边界和子系统间通讯的设计 组件比起对象的进步在于他定义了一种通用的处理方式，通用规范的引入导致组件是可以替代的 面向切面编程(AOP)再随着企业变大，基于组件开发时某些方法都会用到同一个组件，每次要用到的时候都需要写一遍调用该组件的语句或者实现接口等 这时会想到面向切面编程(Aspect-Oriented Programming)，他是指通过预编译和运行期动态代理的方式实现给程序统一添加功能的目的 把重复的代码或者通用组件调用统一写入与业务代码匹配的切面中，这样业务代码中不需要重复编写或调用组件 以后再有需要调用的功能模块，直接把这个模块配置为对应切面，该切面的所有功能都会添加到此模块 面向服务架构(SOA)后来企业变成了集团公司，上线了很多套各种各样的系统 虽然大部分系统都实现了组件化，但做为一个集团公司仍然有很多共同的业务，不同系统中有很多功能重复的模块 此时又面临一个业务需求变更可能涉及多套系统升级的问题 这时会想到面向服务架构(Service-Oriented Architecture)，他是一套软件设计的原则或方法论 架构师把各个系统功能类似的模块抽象成服务，重复的模块再也没有了，不同系统间互相调用服务接口 以前要自己写一大堆代码，现在甚至不必关心所需调用服务的实现，只要知道服务接口如何调用，直接调用另一套服务的接口就OK了 参考链接： 面向对象、面向服务、面向组件三种编程模式有什么区别？分别适用于哪些领域的开发？ - 李黄河的回答 - 知乎 面向对象编程（OOP）、面向组件编程（COP）、面向方面编程（AOP）和面向服务编程（SOP）_始则转俗成真，终乃回真向俗！-CSDN博客_面向组件编程","tags":[]},{"title":"面向过程编程 VS 面向对象编程","date":"2021-06-04T16:00:00.000Z","path":"article/20210605.html","text":"这篇文章用来区别面向过程编程(Process-Oriented Programming)和面向对象编程(Object-Oriented Programming) 面向过程编程(POP)在使用JAVA语言之前我们常用C语言，C语言是典型的面向过程的编程语言 在C语言（或者说面向过程编程语言）中，你就是上帝（主函数就是上帝意志的体现……） 你把想做的事写到一个一个函数模块，之后在主函数中通过调用不同的函数完成不同的功能，最后达到你想到的效果（得到你想要的输出） 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步步实现，使用的时候依次调用就可以了 面向对象编程(OOP)面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题步骤中的行为 JAVA是典型的面向对象编程语言之一 在JAVA（或者说面向对象编程语言）中，你还是上帝，但是你是一个“简政放权”了的上帝 你创建了一个个对象，然后这些对象干这干那的，最后达到你想到的效果（得到你想要的输出） 面向过程 VS 面向对象用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭 所谓蛋炒饭最后是要把鸡蛋放饭里翻炒均匀，盖浇饭就是在白米饭上面浇上一份盖菜 蛋炒饭的好处就是入味均匀，吃起来香 但如果恰巧你不爱吃鸡蛋，只爱吃青菜的话，那么唯一的办法就是全部倒掉，重新做一份青菜炒饭了 盖浇饭就没这么多麻烦，你只需要把上面的盖菜拨掉，更换一份盖菜就可以了 盖浇饭的缺点是入味不均，可能没有蛋炒饭那么香 到底是蛋炒饭好还是盖浇饭好呢？其实这类问题都很难回答，非要比个上下高低的话，就必须设定一个场景，否则只能说是各有所长 如果大家都不是美食家，没那么多讲究，那么从饭馆角度来讲的话，做盖浇饭显然比蛋炒饭更有优势，他可以组合出来任意多的组合，而且不会浪费 盖浇饭的好处就是”菜”“饭”分离，从而提高了制作盖浇饭的灵活性，饭不满意就换饭，菜不满意换菜 用软件工程的专业术语就是”可维护性”比较好，“饭” 和”菜”的耦合度比较低 蛋炒饭将”蛋”、“饭”炒在一起，想换”蛋”、”饭”中任何一种都很困难，耦合度很高，以至于”可维护性”比较差 软件工程追求的目标之一就是可维护性，可维护性主要表现在3个方面：可理解性、可测试性和可修改性 面向对象的好处之一就是显著的改善了软件系统的可维护性 参考链接： 从C到JAVA，从面向过程到面向对象 - 神的彬彬 - 博客园 面向对象与面向过程的本质的区别_李光 未来科技-CSDN博客_面向对象和面向过程的区别","tags":[]},{"title":"开发模型（瀑布、敏捷开发、DevOps）","date":"2021-06-02T16:00:00.000Z","path":"article/20210603.html","text":"单打独斗的程序员上个世纪40年代，世界上第一台计算机诞生 从诞生之日起，它就离不开程序（Program）的驱动，而负责编写程序的人，就被称为“程序员”（Programmer） 程序员是计算机的驾驭者，那个时候是极其稀缺的人才，只有高学历、名校出身的人，才有资格成为程序员 随着人类科技的不断发展，PC和Internet陆续问世，我们进入了全民拥抱信息化的时代 企业用户：将计算机作为办公工具，用以提升生产力 个人用户：将计算机作为娱乐工具，用以改善生活品质 于是程序逐步演进为“软件（software）”，变成了最赚钱的产品之一 而程序员有了更专业的称谓，叫做“软件开发工程师（Software Development Engineer）” 软件开发工程师的工作职责就是完成一个软件从零开始到最终交付，大概包括如下几个阶段： 起初程序比较简单工作量也不大，程序员一个人可以完成所有阶段的工作 瀑布（Waterfall）模型随着软件产业的日益发展壮大，软件的规模日益庞大，一个人已经很难集中精力完成全部交付过程 码农的队伍逐渐扩大，工种增加，除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师 软件测试工程师和软件运维工程师分担了项目构建之后的工作，软件交付过程分工如下： 分工后软件交付流程如下： 开发人员编写代码 -&gt; QA质保团队测试 -&gt; 运维团队部署 在这种流程下，我们必须要等前一个阶段的所有工作都完成了才能进入下一个阶段 我们把这种软件交付模型称为“瀑布模型” 这种模型适合用户需求非常明确、开发时间非常充足的项目，大家按部就班轮流执行自己的职责即可 敏捷开发（Agile Development）模型随着时间推移，用户对系统的需求不断增加，产品在使用过程中也是会有问题需要改进的 这个情况下，大家发现，笨重迟缓的瀑布模型已经不合时宜了，于是软件开发团队引入了“敏捷开发”的概念 敏捷开发在2000年左右开始被世人所关注，是一种以人为核心、迭代、循序渐进的开发方法，能够应对快速变化的需求 本质在说敏捷开发的本质之前我们先来解释下这里提到的一个名词——迭代（Sprint） 迭代是指把一个开发周期很长的开发任务分解为很多个小周期任务每个周期就是一次迭代的过程每一次迭代都可以生产或开发出一个可以交付的软件产品 敏捷开发的本质就是将软件项目的构建切分成多个子项目迭代进行 保证各个子项目的成果都经过测试，具备集成和可运行的特征 简单来说就是 把大项目变成小项目，把大时间点变成小时间点 特征 并不追求前期完美的设计、完美编码 力求在很短的周期内开发出产品的核心功能，尽早发布出可用的版本 在后续的生产周期内，按照新需求不断迭代升级，完善产品 名词敏捷开发最常用的一种实现方式就是Scrum方式，接下来我们会讲解Scrum方式敏捷开发的软件交付流程 在讲解交付流程之前，我们需要对该流程中所涉及的角色、工件以及会议有个大概的了解 角色 PO(Product Owner 产品负责人) 负责确定产品的功能和达到要求的标准 指定软件的发布日期和交付的内容 有权力接受或拒绝开发团队的工作成果 SM(Scrum Manager 流程管理员) 负责整个Scrum流程在项目中的顺利实施和进行 清除挡在客户和开发工作之间的沟通障碍，使得客户可以直接驱动开发 有些公司SM会由ST中的一员兼任 ST(Scrum Team 开发团队)： 软件产品在Scrum规定流程下进行开发工作，人数控制在5~10人左右 每个成员可能负责不同的技术方面（前端开发、后端开发、测试等） 要求每成员必须有很强的自我管理能力和一定的表达能力 工件 PB(Product Backlog 项目需求列表)：PO负责按优先级顺序排列的完整产品需求列表 SB(Sprint Backlog 迭代需求列表)：SM负责在SPM会议中产出的本次迭代需求列表大体框架，会后细化为更小的任务，控制任务周期在2天内 SBD(Sprint Burn Down 迭代燃尽图)：ST成员负责在DSM会议中更新自己的任务状态，整体就是整个迭代的完成状态图，又称燃尽图 会议 SPM(Sprint Plan Meeting 迭代计划会议)：根据PB讨论本次迭代需要完成的目标，控制迭代周期在1-4周，生成SB大体框架 DSM(Daily Scrum Meeting 每日站立会议)：ST成员汇报昨日工作、承诺今日工作、阐述所遇问题、更新SBD，每次会议控制在15分钟左右 Sprint Review Meeting(评审会议)：也称演示会议，ST成员向产品负责人和客户演示自己完成的软件产品 Sprint Retrospective Meeting(复盘会议)：也称为总结会议，PO、SM、ST轮流发言，总结并讨论改进的地方，放入下一轮迭代中 交付流程理清了上面这些流程中所涉及的角色、工件以及会议，我们的交付流程自然就出来了，如下图所示： 在项目启动之前，团队PO(Product Owner 产品负责人)会整理出所有的项目需求并按优先级顺序排列，为项目做出整体排期，发出PB(Product Backlog 项目需求列表) 在每一个迭代周期开始，团队PO会组织SPM(Sprint Plan Meeting 迭代计划会议)根据PB讨论本次迭代需要完成的目标，一般会将迭代周期控制在1-4周 SM(Scrum Manager 流程管理员)在SPM会后负责整理SB(Sprint Backlog 迭代需求列表)，并将需求细化成一个个小任务分配给ST(Scrum Team 开发团队)成员，一般会将任务周期控制在2天内 之后ST成员按照SB进行具体编码及测试工作 ST成员每天早晨都会进行DSM(Daily Scrum Meeting 每日站立会议)，汇报昨日工作、承诺今日工作、阐述所遇问题 根据任务完成情况更新SBD(Sprint Burn Down 迭代燃尽图) SB中所有任务完成后组织Sprint Review Meeting(评审会议)，由ST成员向PO及客户演示自己的成果 评审会议结束项目发版 发版完成后组织Sprint Retrospective Meeting(复盘会议)，PO、SM、ST轮流发言，总结并讨论改进的地方，放入下一轮迭代的产品需求中 瀑布模型和敏捷开发模型对比随着敏捷开发的推广，开发团队的工作效率逐渐变高，下面这个图看起来两者对比会更加清晰 DevOps开发模型经常发版前发现有问题需要修正，简单问题还好，加班修正后继续发版就好 如果会有复杂问题出现，发版时间又已经发出去了，只好通宵想办法解决问题 随着时间推移，软件的复杂度不断攀升，每次发版之前开发、测试、运维都捏着把汗 为了按时交付软件产品和服务，为了不在饱受通宵加班苦恼，开发和运营工作必须紧密合作，随即提出了DevOps开发模型 定义DevOps这个词，其实是Development和Operations两个词的组合。它的英文发音是 /de’vɒps/，类似于“迪沃普斯” 维基百科定义DevOps是一组过程、方法与系统的统称，用于促进开发、技术运营和质量保障（QA）部门之间的沟通、协作与整合 DevOps就是让开发人员和运维人员更好地沟通合作，通过自动化流程来使得构建、测试、发布软件的整体过程能够更加地快捷、频繁和可靠 交付流程在DevOps下，运维人员会在项目开发期间就介入到开发过程中，了解开发人员使用的系统架构和技术路线，从而制定适当的运维方案 而开发人员也会在运维的初期参与到系统部署中，并提供系统部署的优化建议 DevOps开发模型和瀑布模型、敏捷开发模型对比对比前面所说的瀑布式开发和敏捷开发，我们可以明显看出，DevOps贯穿了软件全生命周期，而不仅限于开发阶段 有两个词经常会伴随着DevOps出现，那就是CI(Continuous Integration 持续集成)和CD(Continuous Delivery 持续交付) 至于什么是持续集成、持续交付，看下面这个DevOps开发模型和瀑布模型、敏捷开发模型的对比图会更加一目了然 很多人可能会觉得，“更新版本的速度快了，风险不是更大了吗？” 敲黑板，勿忘初心啊，我们使用DevOps开发模型就是为了规避发版时的风险啊 其实，更新版本的速度变快可以帮助我们更快地发现问题，产品被更快地交付到用户手中，团队可以更快地得到用户的反馈，从而进行更快地响应 而且，DevOps更新版本的变化是比较小的，相对应发版的风险也就会更小，即使出现问题修复起来也会相对容易一些（不至于通宵加班了 真香） 技术支持想要充分落地DevOps，当然离不开软件和平台的支持，目前支持DevOps的软件实在是太多了 （现在DevOps被吹得天花乱坠肯定也有这些软件和平台的功劳，毕竟可以趁机卖钱啊） 现将工具类型及对应的不完全列举整理如下： 代码管理（SCM）：GitHub、GitLab、BitBucket、SubVersion 构建工具：Ant、Gradle、maven 自动部署：Capistrano、CodeDeploy 持续集成（CI）：Bamboo、Hudson、Jenkins 配置管理：Ansible、Chef、Puppet、SaltStack、ScriptRock GuardRail 容器：Docker、LXC、第三方厂商如AWS 编排：Kubernetes、Core、Apache Mesos、DC/OS 服务注册与发现：Zookeeper、etcd、Consul 脚本语言：python、ruby、shell 日志管理：ELK、Logentries 系统监控：Datadog、Graphite、Icinga、Nagios 性能监控：AppDynamics、New Relic、Splunk 压力测试：JMeter、Blaze Meter、loader.io 预警：PagerDuty、pingdom、厂商自带如AWS SNS HTTP加速器：Varnish 消息总线：ActiveMQ、SQS 应用服务器：Tomcat、JBoss Web服务器：Apache、Nginx、IIS 数据库：MySQL、Oracle、PostgreSQL等关系型数据库；cassandra、mongoDB、redis等NoSQL数据库 项目管理（PM）：Jira、Asana、Taiga、Trello、Basecamp、Pivotal Tracker 在工具的选择上，需要结合公司业务需求和技术团队情况而定 （注：更多关于工具的详细介绍可以参见此文：51 Best DevOps Tools for #DevOps Engineers） DevOps = Dev + Ops ？很多人可能觉得，所谓DevOps，不就是Dev+Ops嘛，直接把团队合并，或者将所有人员划归开发 这种理解完全曲解了DevOps开发模式的思想，甚至有点回到类似最初程序员单打独斗的模式了 DevOps并不仅仅是组织架构变革，更是企业文化和思想观念的变革 所以他的实现考验的也不仅是一家企业的技术（毕竟有上面那些软件和平台提供技术支持），更是管理水平和企业文化 参考链接： 什么是DevOps？ - UCloud云计算回答 - 知乎 什么是敏捷开发？_好记性不如烂笔头-CSDN博客_敏捷开发 开发模式（敏捷开发，瀑布式开发，螺旋型开发，迭代开发，devOps开发）_sinat_35566306的博客-CSDN博客_瀑布式开发 敏捷开发和DevOps - 知乎 Devops - 简书 DevOps敏捷开发架构图 | ProcessOn免费在线作图 |","tags":[]},{"title":"企业微信群机器人发送消息","date":"2021-05-31T16:00:00.000Z","path":"article/20210601.html","text":"这篇文章用来记录企业微信群机器人创建到发送消息的全过程，最后附有本文源码git地址，科学食用 创建群机器人并获取Webhook地址创建机器人的方式很简单，操作步骤及手机界面截图如下： （图1）点击进入需要创建群机器人的群聊 （图2）点击右上角查看群聊信息的按钮 （图3）点击 群机器人 选项群机器人管理页面 （图4）点击 添加机器人 按钮添加新机器人 （图5）设置机器人头像、昵称，点击 添加 按钮 （图6）点击 复制 按钮复制Webhook地址， 这个地址在之后发送请求中会用到，一定要记得复制下来哦 （图6）点击 配置说明 查看官方配置文档 （图7）点击右上角三个点打开分享框，点击 复制链接 选项， 这个地址是微信官方的群机器人配置文档，在开发过程中经常会用到，一定要记得复制下来哦 （图8）返回群聊界面可以看到提示，说明群聊机器人已经添加成功 步骤6和步骤8中我们复制了两个连接，如下： Webhook地址： https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=693a91f6-7xxx-4bc4-97a0-0ec2sifa5aaa 群机器人配置文档： https://work.weixin.qq.com/api/doc/90000/90136/91770 TIPS: Webhook地址的作用是开发者可以通过向这个地址发起POST请求来实现给该群组发送消息每个机器人的webhook地址是不一样的，一定要保护好webhook地址避免泄漏，否则坏人就可以用你的机器人来发垃圾消息了 如果刚才没有复制到Webhook地址，或者说再次开发时忘记Webhook地址，可以通过如下步骤查看群机器人的Webhook地址： （图1）点击 群机器人 选项群机器人管理页面 （图2）选择需要查看Webhook地址的机器人 （图3）找到 Webhook地址 长按-&gt;全选-&gt;复制 创建项目并引入依赖我们 使用IDEA创建Maven工程 ，项目名为“wechat-robot-demo“ 需要用到的依赖包及其所起作用如下： fastjson：处理JSON httpclient：HTTP请求调用 junit：测试 可以复制下面代码一次性引入这些依赖： pom.xml 123456789101112131415161718192021&lt;dependencies&gt; &lt;!-- 处理JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.76&lt;/version&gt; &lt;/dependency&gt; &lt;!-- HTTP请求调用 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 基础代码消息类型枚举类通过配置文档可以看出我们能够使用微信机器人去发送的消息类型主要有如下五种 我们在common包下定义一个消息类型枚举类（MsgtypeEnum.java）枚举出所有的消息类型 1234567891011121314151617181920212223242526272829303132public enum MsgtypeEnum &#123; /** * 文本类型 */ text(\"text\"), /** * markdown类型 */ markdown(\"markdown\"), /** * 图片类型 */ image(\"image\"), /** * 图文类型 */ news(\"news\"), /** * 文件类型 */ file(\"file\"); String value; MsgtypeEnum(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; 消息发送结果类在请求webhook时会返回请求结果，里面有错误编码、错误信息等信息 我们在common包下定义一个消息发送结果类（SendResult.java）来存储我们需要的请求结果信息 重写toString()方法为JSON格式，方便我们在测试时打印请求结果 123456789101112131415161718192021222324252627282930public class SendResult &#123; /** * 是否请求成功 */ private boolean isSuccess; /** * 请求错误编码 */ private String errorCode; /** * 请求错误信息 */ private String errorMsg; @Override public String toString() &#123; Map&lt;String, Object&gt; items = new HashMap&lt;String, Object&gt;(); items.put(\"errorCode\", errorCode); items.put(\"errorMsg\", errorMsg); items.put(\"isSuccess\", isSuccess); return JSON.toJSONString(items); &#125; public SendResult(boolean isSuccess, String errorCode, String errorMsg) &#123; this.isSuccess = isSuccess; this.errorCode = errorCode; this.errorMsg = errorMsg; &#125; // 省略getter&amp;setter方法&#125; 消息通用接口不同消息类型请求时数据格式是不同的，但相同点是它们都需要以JSON的格式发送Webhook请求 我们在message包下定义一个消息通用接口（Message.java） 并在消息通用接口里定义toJson()方法，保证所有实现消息通用接口的类都提供toJson()方法 12345678public interface Message &#123; /** * 返回消息的Json格式字符串 * * @return 消息的Json格式字符串 */ String toJson() throws IllegalArgumentException;&#125; 发送请求类在创建群机器人时说过我们是要通过调用群组机器人的Webhook地址发起POST请求来实现给该群组发送消息 我们在api包下定义一个消息发送结果类（WechatRobotApi.java）来完成Webhook地址的POST请求调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class WechatRobotApi &#123; /** * 发送消息 * * @param sendUrl * @param message * @return */ public static SendResult send(String sendUrl, Message message) &#123; // 判断sendUrl是否为空 if (StringUtils.isBlank(sendUrl)) &#123; return new SendResult(false, \"10000\", \"webhook地址不可为空\"); &#125; try &#123; // 发送post请求 HttpResponse response = post(sendUrl, message.toJson()); if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) &#123; String errorCode = \"10\" + response.getStatusLine().getStatusCode(); return new SendResult(false, errorCode, \"Http请求错误 错误编码为后三位\"); &#125; else &#123; String result = null; result = EntityUtils.toString(response.getEntity()); JSONObject obj = JSONObject.parseObject(result); String errorCode = obj.getString(\"errcode\"); return new SendResult(errorCode.equals(0), errorCode, obj.getString(\"errmsg\")); &#125; &#125; catch (IllegalArgumentException e) &#123; return new SendResult(false, \"10001\", e.getMessage()); &#125; catch (IOException e) &#123; return new SendResult(false, \"10002\", \"Http请求IO异常\"); &#125; &#125; /** * 发送post请求 * * @param sendUrl * @param json * @return * @throws IOException */ private static HttpResponse post(String sendUrl, String json) throws IOException &#123; HttpPost httppost = new HttpPost(sendUrl); httppost.addHeader(\"Content-Type\", \"application/json; charset=utf-8\"); StringEntity se = new StringEntity(json, \"utf-8\"); httppost.setEntity(se); HttpResponse response = HttpClients.createDefault().execute(httppost); return response; &#125;&#125; 测试Webhook配置类因为每个机器人的webhook地址是不一样的 我们在config包下定义测试Webhook配置类（WebhookConfig.java）来配置用于测试的群机器人webhook地址 123456789101112public class WebhookConfig &#123; private static final String url = \"https://qyapi.weixin.qq.com/cgi-bin/webhook/\"; private static final String send = \"send?key=\"; private static final String upload_media = \"upload_media?key=\"; //TODO 改成自己用于测试的群机器人webhook地址中key的值 private static final String key = \"693a91f6-7xxx-4bc4-97a0-0ec2sifa5aaa\"; // 消息发送URL public static final String send_url = url + send + key; // 文件上传URL（文件类型消息上传文件时需要用到的URL） public static final String upload_media_url = url + upload_media + key;&#125; 以上已经完成了基础代码，接下来争对不同消息类型进行定制开发即可 观察不同消息类型的参数数据格式可以发现第二个参数名根据消息类型均不相同，所以最外部两个参数直接用JSON封装就好 但相同信息类型第二个参数内部的数据格式是相同的，我们可以根据第二个参数内部的数据格式进行开发 文本类型文本类型数据格式如下图所示： 文本类型消息类我们在message包下定义一个文本类型消息类（TextMessage.java） 实现消息通用接口（Message.java）并完善toJson()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class TextMessage implements Message &#123; /** * 文本内容 */ private String text; /** * 是否@所有人 */ private boolean isAtAll; /** * 需要@的群成员手机号 */ private List&lt;String&gt; mentionedMobileList; /** * 返回消息的Json格式字符串 * * @return 消息的Json格式字符串 */ @Override public String toJson() throws IllegalArgumentException &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put(\"msgtype\", MsgtypeEnum.text.getValue()); Map&lt;String, Object&gt; textContent = new HashMap&lt;String, Object&gt;(); if (StringUtils.isBlank(text)) &#123; throw new IllegalArgumentException(\"文本内容不可为空\"); &#125; textContent.put(\"content\", text); if (isAtAll) &#123; if (mentionedMobileList == null) mentionedMobileList = new ArrayList&lt;String&gt;(); mentionedMobileList.add(\"@all\"); &#125; if (mentionedMobileList != null &amp;&amp; !mentionedMobileList.isEmpty()) &#123; textContent.put(\"mentioned_mobile_list\", mentionedMobileList); &#125; result.put(\"text\", textContent); return JSON.toJSONString(result); &#125; public TextMessage(String text) &#123; this.text = text; &#125; // 省略getter&amp;setter方法&#125; 文本类型消息测试类我们在test包下定义文本类型消息测试类（TextMessageTest.java）来测试文本类型消息发送 普通文本消息 1234567891011public class TextMessageTest &#123; /** * 普通文本消息 */ @Test public void testNormal() &#123; TextMessage message = new TextMessage(\"Hello World!\"); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; @群内成员的文本消息 1234567891011121314public class TextMessageTest &#123; /** * 艾特群内成员的文本消息 */ @Test public void testWithAt() &#123; TextMessage message = new TextMessage(\"你好，我是耿锐的助手\"); List&lt;String&gt; mentionedMobileList = new ArrayList&lt;String&gt;(); mentionedMobileList.add(\"13026212376\"); message.setMentionedMobileList(mentionedMobileList); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 插播一个吐槽： 什么鬼人啊啊啊啊啊，艾特了一下就把我机器人移除了2333333师父让我打他，这人高马大的，我一女孩子哪打得过啊，默默重新添加了一个机器人要注意重新添加机器人后webhook地址会变，需要修改测试Webhook配置类（WebhookConfig.java）中webhook地址 @所有人的文本消息 123456789101112public class TextMessageTest &#123; /** * 艾特所有人的文本消息 */ @Test public void testWithAtAll() &#123; TextMessage message = new TextMessage(\"大家好，我是耿锐的助手\"); message.setIsAtAll(true); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; @群内成员并且@所有人的文本消息 123456789101112131415public class TextMessageTest &#123; /** * 艾特群内成员并且艾特所有人的文本消息 */ @Test public void testWithAtAndAtAll() &#123; TextMessage message = new TextMessage(\"大家好，通报批评就是他刚才移除了我\"); List&lt;String&gt; mentionedMobileList = new ArrayList&lt;String&gt;(); mentionedMobileList.add(\"13026212376\"); message.setMentionedMobileList(mentionedMobileList); message.setIsAtAll(true); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; markdown类型markdown类型数据格式如下图所示： markdown类型消息类我们在message包下定义一个markdown类型消息类（MarkdownMessage.java） 实现消息通用接口（Message.java）并完善toJson()方法 1234567891011121314151617181920212223242526272829303132333435public class MarkdownMessage implements Message &#123; /** * markdown元素列表 每一行内容为一个元素 */ private List&lt;String&gt; items = new ArrayList&lt;String&gt;(); public void add(String text) &#123; items.add(text); &#125; /** * 返回消息的Json格式字符串 * * @return 消息的Json格式字符串 */ @Override public String toJson() throws IllegalArgumentException &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put(\"msgtype\", MsgtypeEnum.markdown.getValue()); if (items.isEmpty()) &#123; throw new IllegalArgumentException(\"markdown内容不可为空\"); &#125; StringBuffer markdownText = new StringBuffer(); for (String item : items) &#123; markdownText.append(item + \"\\n\"); &#125; Map&lt;String, Object&gt; markdown = new HashMap&lt;String, Object&gt;(); markdown.put(\"content\", markdownText.toString()); result.put(\"markdown\", markdown); return JSON.toJSONString(result); &#125;&#125; markdown字体颜色枚举类我们在utils包下定义markdown字体颜色枚举类（MarkdownColorEnum.java）枚举出markdown所支持的所有字体颜色 123456789101112131415public enum MarkdownColorEnum &#123; orange(\"warning\"), gray(\"comment\"), green(\"info\"); String value; MarkdownColorEnum(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125;&#125; markdown工具类我们在utils包下定义markdown工具类（MarkdownUtils.java）提供方法将内容转化为不同格式的markdown语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class MarkdownUtils &#123; /** * 标题 * * @param headerType 标题等级 * @param text 标题内容 * @return */ public static String getHeaderText(int headerType, String text) throws IllegalArgumentException &#123; if (headerType &lt; 1 || headerType &gt; 6) &#123; throw new IllegalArgumentException(\"标题等级必须在1-6之间\"); &#125; StringBuffer numbers = new StringBuffer(); for (int i = 0; i &lt; headerType; i++) &#123; numbers.append(\"#\"); &#125; return numbers + \" \" + text; &#125; /** * 加粗 * * @param text * @return */ public static String getBoldText(String text) &#123; return \"**\" + text + \"**\"; &#125; /** * 链接 * * @param text 连接标题 * @param href 具体链接 * @return */ public static String getLinkText(String text, String href) &#123; return \"[\" + text + \"](\" + href + \")\"; &#125; /** * 行内代码段（暂不支持跨行） * * @param text * @return */ public static String getCodeText(String text) &#123; return \"`\" + text + \"`\"; &#125; /** * 引用 * * @param text * @return */ public static String getQuoteText(String text) &#123; return \"&gt;\" + text; &#125; /** * 字体颜色（只支持3种内置颜色） * * @param markdownColorEnum * @param text * @return */ public static String getColorText(MarkdownColorEnum markdownColorEnum, String text) &#123; return \"&lt;font color=\\\"\" + markdownColorEnum.value + \"\\\"&gt;\" + text + \"&lt;/font&gt;\"; &#125; /** * 斜体 * * @param text * @return */ public static String getItalicText(String text) &#123; return \"*\" + text + \"*\"; &#125; /** * 有序列表 * * @param orderList * @return */ public static String getOrderListText(List&lt;String&gt; orderList) &#123; if (orderList.isEmpty()) &#123; return \"\"; &#125; StringBuffer sb = new StringBuffer(); for (int i = 1; i &lt;= orderList.size() - 1; i++) &#123; sb.append(String.valueOf(i) + \". \" + orderList.get(i - 1) + \"\\n\"); &#125; sb.append(String.valueOf(orderList.size()) + \". \" + orderList.get(orderList.size() - 1)); return sb.toString(); &#125; /** * 无序列表 * * @param unOrderList * @return */ public static String getUnOrderListText(List&lt;String&gt; unOrderList) &#123; if (unOrderList.isEmpty()) &#123; return \"\"; &#125; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; unOrderList.size() - 1; i++) &#123; sb.append(\"- \" + unOrderList.get(i) + \"\\n\"); &#125; sb.append(\"- \" + unOrderList.get(unOrderList.size() - 1)); return sb.toString(); &#125;&#125; markdown类型消息测试类我们在test包下定义markdown类型消息测试类（MarkdownMessageTest.java）来测试markdown类型消息发送 普通markdown消息 123456789101112public class MarkdownMessageTest &#123; /** * 普通markdown消息 */ @Test public void testNormal() &#123; MarkdownMessage message = new MarkdownMessage(); message.add(\"正常内容\"); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 带有标题的markdown消息 1234567891011121314151617181920public class MarkdownMessageTest &#123; /** * 带有标题的markdown消息 */ @Test public void testHeader() &#123; MarkdownMessage message = new MarkdownMessage(); message.add(\"普通MD消息\"); message.add(MarkdownUtils.getHeaderText(1, \"一级标题\")); message.add(MarkdownUtils.getHeaderText(2, \"二级标题\")); message.add(MarkdownUtils.getHeaderText(3, \"三级标题\")); message.add(MarkdownUtils.getHeaderText(4, \"四级标题\")); message.add(MarkdownUtils.getHeaderText(5, \"五级标题\")); message.add(MarkdownUtils.getHeaderText(6, \"六级标题\")); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 带有字体颜色（只支持3种内置颜色）的markdown消息 12345678910111213141516public class MarkdownMessageTest &#123; /** * 带有字体颜色（只支持3种内置颜色）的markdown消息 */ @Test public void testColour() &#123; MarkdownMessage message = new MarkdownMessage(); message.add(MarkdownUtils.getColorText(MarkdownColorEnum.orange, \"橙色内容\")); message.add(MarkdownUtils.getColorText(MarkdownColorEnum.gray, \"灰色内容\")); message.add(MarkdownUtils.getColorText(MarkdownColorEnum.green, \"绿色内容\")); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 带有有序、无序列表的markdown消息 12345678910111213141516171819202122public class MarkdownMessageTest &#123; /** * 带有有序、无序列表的markdown消息 */ @Test public void testList() &#123; MarkdownMessage message = new MarkdownMessage(); ArrayList&lt;String&gt; orderList = new ArrayList&lt;String&gt;(); orderList.add(\"有序列表1\"); orderList.add(\"有序列表2\"); message.add(MarkdownUtils.getOrderListText(orderList)); ArrayList&lt;String&gt; unOrderList = new ArrayList&lt;String&gt;(); unOrderList.add(\"无序列表1\"); unOrderList.add(\"无序列表2\"); message.add(MarkdownUtils.getUnOrderListText(unOrderList)); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 带有其他格式的markdown消息 123456789101112131415161718public class MarkdownMessageTest &#123; /** * 带有其他格式的markdown消息 */ @Test public void testOthers() &#123; MarkdownMessage message = new MarkdownMessage(); message.add(MarkdownUtils.getBoldText(\"加粗内容\")); message.add(MarkdownUtils.getLinkText(\"链接内容\", \"https://www.gengruiblog.cn/\")); message.add(MarkdownUtils.getCodeText(\"代码内容\")); message.add(MarkdownUtils.getQuoteText(\"引用内容\")); message.add(MarkdownUtils.getItalicText(\"斜体内容\")); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 图片类型图片类型数据格式如下图所示： 图片类型消息类我们在message包下定义一个图片类型消息类（ImageMessage.java） 实现消息通用接口（Message.java）并完善toJson()方法 1234567891011121314151617181920212223242526272829303132333435public class ImageMessage implements Message &#123; /** * 图片内容的base64编码 */ private String base64; /** * 图片内容（base64编码前）的md5值 */ private String md5; public ImageMessage(String base64, String md5) &#123; this.base64 = base64; this.md5 = md5; &#125; /** * 返回消息的Json格式字符串 * * @return 消息的Json格式字符串 */ @Override public String toJson() throws IllegalArgumentException &#123; Map&lt;String, Object&gt; items = new HashMap&lt;String, Object&gt;(); items.put(\"msgtype\", MsgtypeEnum.image.getValue()); Map&lt;String, Object&gt; textContent = new HashMap&lt;String, Object&gt;(); if (StringUtils.isBlank(base64)) &#123; throw new IllegalArgumentException(\"base64编码不可为空\"); &#125; textContent.put(\"base64\", base64); textContent.put(\"md5\", md5); items.put(\"image\", textContent); return JSON.toJSONString(items); &#125;&#125; 图片工具类我们在utils包下定义图片工具类（ImageUtils.java）提供方法将本地图片和线上图片转化为图片类型消息类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ImageUtils &#123; /** * 本地图片转换 * * @param imgFile 图片本地路径 * @return * @author yanceyzhang */ public static ImageMessage toMessageByLocal(String imgFile) &#123; byte[] data = null; try &#123; InputStream in = new FileInputStream(imgFile); data = new byte[in.available()]; in.read(data); in.close(); String base64 = Base64.getEncoder().encodeToString(data); return new ImageMessage(base64, DigestUtils.md5Hex(data)); &#125; catch (IOException e) &#123; throw new IllegalArgumentException(\"本地图片读取IO异常\"); &#125; &#125; /** * 线上图片转换 * * @param imgURL 图片线上路径 * @return * @author yanceyzhang */ public static ImageMessage toMessageByOnline(String imgURL) &#123; try &#123; ByteArrayOutputStream data = new ByteArrayOutputStream(); // 创建URL URL url = new URL(imgURL); byte[] by = new byte[1024]; // 创建链接 HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setConnectTimeout(20000); conn.setReadTimeout(20000); InputStream is = conn.getInputStream(); // 将内容读取内存中 int len = -1; while ((len = is.read(by)) != -1) &#123; data.write(by, 0, len); &#125; byte[] b = data.toByteArray(); String base64 = Base64.getEncoder().encodeToString(b); String md5 = DigestUtils.md5Hex(b); is.close(); conn.disconnect(); data.close(); return new ImageMessage(base64, md5); &#125; catch (IOException e) &#123; throw new IllegalArgumentException(\"线上图片读取IO异常\"); &#125; &#125;&#125; 图片类型消息测试类我们在test包下定义图片类型消息测试类（ImageMessageTest.java）来测试图片类型消息发送 本地图片消息 123456789101112public class ImageMessageTest &#123; /** * 本地图片消息 */ @Test public void testLocal() &#123; String urlLocal = \"D:/Blog/avatar.png\"; ImageMessage message = ImageUtils.toMessageByLocal(urlLocal); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 线上图片消息 123456789101112public class ImageMessageTest &#123; /** * 线上图片消息 */ @Test public void testOnline() throws Exception &#123; String urlOnLine = \"https://www.gengruiblog.cn/favicon.png\"; ImageMessage message = ImageUtils.toMessageByOnline(urlOnLine); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 图文类型图文类型数据格式如下图所示： 文章类由于一个图文消息支持1-8篇文章 我们先在message包下定义一个文章类（Article.java） 1234567891011121314151617181920212223242526272829public class Article &#123; /** * 标题 */ private String title; /** * 描述 * 可省略 */ private String description; /** * 点击后跳转的链接 */ private String url; /** * 图文消息的图片链接，支持JPG、PNG格式，较好的效果为大图 1068*455，小图150*150 * 可省略 */ private String picurl; public Article(String title, String description, String url, String picurl) &#123; this.title = title; this.description = description; this.url = url; this.picurl = picurl; &#125; // 省略getter&amp;setter方法&#125; 图文类型消息类之后在message包下定义一个图文类型消息类（NewsMessage.java）里面存放文章类的List 并且实现消息通用接口（Message.java）并完善toJson()方法 1234567891011121314151617181920212223242526272829303132public class NewsMessage implements Message &#123; /** * 文章列表 一个图文消息支持1-8篇文章 */ private List&lt;Article&gt; articles = new ArrayList&lt;Article&gt;(); public void addArticle(Article article) &#123; if (articles.size() &gt; 8) &#123; throw new IllegalArgumentException(\"每条图文消息所包含的文章数不可超过八个\"); &#125; articles.add(article); &#125; /** * 返回消息的Json格式字符串 * * @return 消息的Json格式字符串 */ @Override public String toJson() throws IllegalArgumentException &#123; Map&lt;String, Object&gt; items = new HashMap&lt;String, Object&gt;(); items.put(\"msgtype\", MsgtypeEnum.news.getValue()); Map&lt;String, Object&gt; news = new HashMap&lt;String, Object&gt;(); if (articles.isEmpty()) &#123; throw new IllegalArgumentException(\"图文消息中不可以没有文章\"); &#125; news.put(\"articles\", articles); items.put(\"news\", news); return JSON.toJSONString(items); &#125;&#125; 图文类型消息测试类我们在test包下定义图片类型消息测试类（NewsMessageTest.java）来测试图片类型消息发送 一条图文消息 12345678910111213public class NewsMessageTest &#123; /** * 一条图文消息 */ @Test public void testOneArticle() &#123; NewsMessage message = new NewsMessage(); message.addArticle(new Article(\"耿锐的博客\", \"欢迎的来到耿锐的技术小栈\", \"https://www.gengruiblog.cn/\", \"https://www.gengruiblog.cn/favicon.png\")); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 多条图文消息 1234567891011121314151617181920212223public class NewsMessageTest &#123; /** * 多条图文消息 */ @Test public void testMoreArticle() &#123; NewsMessage message = new NewsMessage(); message.addArticle(new Article(\"有描述有长方形图\", \"耿锐的博客 - MVC设计模式\", \"https://www.gengruiblog.cn/article/20210224.html\", \"https://www.gengruiblog.cn/picture/mvc/2.png\")); message.addArticle(new Article(\"有描述有方形图\", \"昆大圣博客 - 迷失的人迷失了，相逢的人会再相逢\", \"https://blog.ecutdl.cn/\", \"https://blog.ecutdl.cn/usr/uploads/2021/05/3275615662.png\")); message.addArticle(new Article(\"有描述无图\", \"昆大圣博客 - 留言板\", \"https://blog.ecutdl.cn/3.html\", null)); message.addArticle(new Article(\"无描述有长方形图\", null, \"https://www.baidu.com/\", \"https://dss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/logo_white-d0c9fe2af5.png\")); message.addArticle(new Article(\"无描述有方形图\", null, \"https://www.gengruiblog.cn/\", \"https://www.gengruiblog.cn/favicon.png\")); message.addArticle(new Article(\"无描述无图\", null, \"https://www.baidu.com/\", null)); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 文件类型文件类型数据格式如下图所示： 在发送文件类型消息时需要用到下图所示文件上传接口拿到media_id（三天内有效） 文件工具类我们在utils包下定义文件工具类（FileUtils.java）提供方法完成文件上传拿到media_id 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public class FileUtils &#123; /** * 文件上传得到media_id，该media_id仅三天内有效 * media_id在同一企业内应用之间可以共享 * * @param uploadMediaUrl * @param filePath * @return */ public static String upload(String uploadMediaUrl, String filePath) &#123; File file = new File(filePath); if (!file.exists() || !file.isFile()) &#123; throw new IllegalArgumentException(\"文件不存在\"); &#125; // 返回结果 String result; try &#123; // 设置边界 String boundary = \"----------\" + System.currentTimeMillis(); // 获取连接并设置请求头 HttpsURLConnection conn = getConnection(uploadMediaUrl, boundary); // 设置请求正文信息 setFileContent(conn.getOutputStream(), file, boundary); if (HttpsURLConnection.HTTP_OK != conn.getResponseCode()) &#123; throw new IllegalArgumentException(\"Http请求错误 错误编码为\" + conn.getResponseCode()); &#125; else &#123; // 获取请求结果 result = getResult(conn.getInputStream()); &#125; &#125; catch (IOException e) &#123; throw new IllegalArgumentException(\"HTTP请求IO异常\"); &#125; JSONObject jsonObject = JSONObject.parseObject(result); if (!jsonObject.getInteger(\"errcode\").equals(0)) &#123; throw new IllegalArgumentException(jsonObject.getString(\"errmsg\")); &#125; return jsonObject.getString(\"media_id\"); &#125; /** * 获取连接并设置请求头 * * POST https://qyapi.weixin.qq.com/cgi-bin/webhook/upload_media?key=693a91f6-7xxx-4bc4-97a0-0ec2sifa5aaa&amp;type=file HTTP/1.1 * Content-Type: multipart/form-data; boundary=-------------------------acebdf13572468 * Content-Length: 220 * * @param uploadMediaUrl 地址 * @param boundary 边界值 * @return * @throws IOException */ private static HttpsURLConnection getConnection(String uploadMediaUrl, String boundary) throws IOException &#123; URL url = new URL(uploadMediaUrl); HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(); conn.setRequestMethod(\"POST\");// 以POST方式提交表单 conn.setUseCaches(false);// POST方式不能使用缓存 conn.setDoInput(true); conn.setDoOutput(true); // 设置请求头信息 conn.setRequestProperty(\"Connection\", \"Keep-Alive\"); conn.setRequestProperty(\"Charset\", \"UTF-8\"); conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary); conn.setRequestProperty(\"Content-Length\", \"220\"); return conn; &#125; /** * 设置请求正文信息 * * ---------------------------acebdf13572468 * Content-Disposition: form-data; name=\"media\";filename=\"wework.txt\"; filelength=6 * Content-Type: application/octet-stream * * mytext * ---------------------------acebdf13572468-- * * @param outputStream * @param file * @param boundary * @throws IOException */ private static void setFileContent(OutputStream outputStream, File file, String boundary) throws IOException &#123; // 头部内容 StringBuilder sb = new StringBuilder(); sb.append(\"--\");// 必须多两条道 sb.append(boundary); sb.append(\"\\r\\n\"); sb.append(\"Content-Disposition: form-data;name=\\\"media\\\"; filename=\\\"\" + file.getName() + \"\\\"\\r\\n\"); sb.append(\"Content-Type:application/octet-stream\\r\\n\\r\\n\"); outputStream.write(sb.toString().getBytes(\"UTF-8\")); // 正文部分 把文件以流的方式读取后推送道URL中 DataInputStream din = new DataInputStream(new FileInputStream(file)); int bytes = 0; byte[] buffer = new byte[1024]; while ((bytes = din.read(buffer)) != -1) &#123; outputStream.write(buffer, 0, bytes); &#125; din.close(); // 尾部内容 byte[] foot = (\"\\r\\n--\" + boundary + \"--\\r\\n\").getBytes(\"UTF-8\");// 定义数据最后分割线 outputStream.write(foot); outputStream.flush(); outputStream.close(); &#125; /** * 获取请求结果 * * @param inputStream * @return * @throws IOException */ private static String getResult(InputStream inputStream) throws IOException &#123; StringBuffer strbuffer = new StringBuffer(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String lineString; while ((lineString = reader.readLine()) != null) strbuffer.append(lineString); reader.close(); return strbuffer.toString(); &#125;&#125; 文件类型消息类我们在message包下定义一个图片类型消息类（FileMessage.java） 实现消息通用接口（Message.java）并完善toJson()方法 1234567891011121314151617181920212223242526272829public class FileMessage implements Message &#123; /** * 通过文件上传接口获取的文件id 三天内有效 */ private String media_id; public FileMessage(String media_id) &#123; this.media_id = media_id; &#125; /** * 返回消息的Json格式字符串 * * @return 消息的Json格式字符串 */ @Override public String toJson() throws IllegalArgumentException &#123; Map&lt;String, Object&gt; items = new HashMap&lt;String, Object&gt;(); items.put(\"msgtype\", MsgtypeEnum.file.getValue()); Map&lt;String, Object&gt; textContent = new HashMap&lt;String, Object&gt;(); if (StringUtils.isBlank(media_id)) &#123; throw new IllegalArgumentException(\"通过文件上传接口获取的文件id不可为空\"); &#125; textContent.put(\"media_id\", media_id); items.put(\"file\", textContent); return JSON.toJSONString(items); &#125;&#125; 文件类型消息测试类我们在test包下定义文件类型消息测试类（FileMessageTest.java）来测试文件类型消息发送 普通文件消息 123456789101112public class FileMessageTest &#123; /** * 普通文件消息 */ @Test public void testNormal() &#123; String mediaId = FileUtils.upload(WebhookConfig.upload_media_url, \"D:/Work/需求调研汇总.xlsx\"); FileMessage message = new FileMessage(mediaId); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 音频文件消息 123456789101112public class FileMessageTest &#123; /** * 音频文件消息 */ @Test public void testMusic() &#123; String mediaId = FileUtils.upload(WebhookConfig.upload_media_url, \"D:/KuGou/汪苏泷 - 有点甜.mp3\"); FileMessage message = new FileMessage(mediaId); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 视频文件消息 123456789101112public class FileMessageTest &#123; /** * 视频文件消息 */ @Test public void testVideo() &#123; String mediaId = FileUtils.upload(WebhookConfig.upload_media_url, \"D:/Video/明月千古情.mp4\"); FileMessage message = new FileMessage(mediaId); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 图片文件消息 123456789101112public class FileMessageTest &#123; /** * 图片文件消息 */ @Test public void testPicture() &#123; String mediaId = FileUtils.upload(WebhookConfig.upload_media_url, \"D:/Blog/avatar.png\"); FileMessage message = new FileMessage(mediaId); SendResult result = WechatRobotApi.send(WebhookConfig.send_url, message); System.out.println(result); &#125;&#125; 本文源码如上已经完成了企业微信群机器人所提供的所有类型消息发送 GengRui01/wechat-robot-demo","tags":[]},{"title":"Python函数参数","date":"2021-05-26T16:00:00.000Z","path":"article/20210527.html","text":"函数参数是需要传递给函数内部的数据，在 Python函数的定义及调用 中我们已经简单接触了函数的参数 函数参数可以是任意的数据类型，只要函数内部逻辑可以处理即可 参数类型校验但有时候由于函数的实现关系，需要特定数据类型的参数 错误示例就比如前面实现的求绝对值的函数 myAbs() ，我们在调用时传递一个字符串，就会引起错误 代码： 1234567def myAbs(num): if num &gt;= 0: return num else: return -numabsB = myAbs(\"err\") 运行结果： 解决方案为了保证函数的正常运行，我们需要对函数入参的数据类型进行校验 Python提供了 isinstance() 函数，可以判断参数数据类型 它接收两个参数，第一个是需要判断的参数，第二个是数据类型 如果参数是指定数据类型的就返回True，如果不是就返回False 语法格式xxxxxxxxxx格式如下： 1isinstance(参数, 数据格式) 正确示例代码： 12345678910def myAbs(num): if not isinstance(num, int) or not isinstance(num, float): print('&#123;&#125;并非整数/小数数据类型'.format(num)) return None if num &gt;= 0: return num else: return -numabsB = myAbs(\"err\") 运行结果： 默认参数定义函数的时候，还可以有默认参数，默认参数的意思是 当这个参数有值传递的时候，就使用传递进来的值 当这个参数没有传递的时候，就使用定义的默认值 函数的默认参数的作用是简化调用，调用时只需要把必须的参数传进去 但是在需要的时候，又可以传入额外的参数来覆盖默认参数的值 语法格式定义函数时使用默认参数格式如下： 123def 函数名(参数1, 默认参数 = 默认值) 函数体 return 使用示例比如我们定义一个用来求num的n次方的 power 函数，n默认为2 代码： 123456789def power(num, n=2): value = 1 while n &gt; 0: value = value * num n = n - 1 return valueprint(power(4))print(power(4, 3)) 运行结果： 调用 power 函数求平方值时，我们只需要传入底数，不用传幂 但是在需要调用 power 函数求其他次方值时，又可以传入幂值 这就是函数使用默认参数的优势 TIPS: 由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面，否则将会出现错误 可变参数定义函数的时候，除了默认参数，Python函数还接收一种参数叫做可变参数 可变参数的意思是参数的数量是可变的，可变参数通常使用 *args 来表示 语法格式定义函数时使用默认参数格式如下： 123def 函数名(*args) 函数体 return 使用示例比如我们定义一个用来计算任意个数的平均值的 average 函数 代码： 1234567891011def average(*args): sum = 0 count = 0 for item in args: sum += item count += 1 avg = sum / count return avgprint(average(1, 2, 3, 4, 5))print(average(6, 7)) 运行结果： 调用 average 函数求平均值时，我们只需要传入所有值，没有数量限制 这就是函数使用可变参数的优势 TIPS: 在使用上，Python会把可变参数定义为一个Tuple所以在函数内部，把可变参数当作Tuple来使用就可以了比如可以通过位置下标取出对应的元素等 可变关键字参数可变参数在底层会把可变参数当作Tuple去处理，但Tuple在使用上有一定的局限性 比如有时候想找到特定位置的参数，只能通过下标的方式去寻找 如果顺序发生变化得时候，下标就会失效，函数逻辑就得重新修改实现 Python函数提供可变关键字参数，对于可变关键字参数，可以通过关键字的名字key找到对应的参数值 这和我们之前学习过的Dict类似，Python会把可变关键字参数定义为一个Dict 可变关键字参数通常使用 **kwargs 来表示 语法格式定义函数时使用默认参数格式如下： 123def 函数名(**kwargs) 函数体 return 使用示例比如我们定义一个用来打印同学信息的 info 函数 代码： 12345def info(**kwargs): print('姓名: &#123;&#125;, 性别: &#123;&#125;, 年龄: &#123;&#125;'.format(kwargs.get('name'), kwargs.get('gender'), kwargs.get('age')))info(name = 'Alice', gender = 'girl', age = 16)info(name = 'Alice', age = 16, gender = 'girl') 运行结果： 调用 info 打印同学信息时，传参顺序的不同对我们的打印结果没有影响 这就是函数使用可变参数的优势，他是通过 key 来拿 value 参数顺序对于一个拥有必需参数，默认参数，可变参数，可变关键字参数的函数 定义顺序是先必需参数，接着默认参数，之后可变参数，最后可变关键字参数 代码如下： 12345678def func(param1, param2, param3 = None, *args, **kwargs): print(param1) print(param2) print(param3) print(args) print(kwargs)func(100, 200, 300, 400, 500, name = 'Alice', score = 100) 运行结果： TIPS: 在实际使用上，不建议定义这么多的参数因为这么多类型的参数，很容易导致出错","tags":[]},{"title":"Python函数的定义及调用","date":"2021-05-25T16:00:00.000Z","path":"article/20210526.html","text":"什么是函数对于什么是函数，其实在前面的学习过程中我们所使用的方法就是函数 比如在set里面，使用remove()函数进行元素的删除，使用add()函数添加元素等 但是到现在我们一直都是在调用Python内置的函数，没有学习如何自己定义一个函数 在编程过程中我们经常需要用到自己定义的函数，这篇文章主要学习如何自己定义并且调用函数 定义函数在Python中，定义一个函数要使用 def 关键字， def 后写出函数名、圆括号 () 和冒号 : 传入参数或者自变量需要放在圆括号中，括号里可以用来定义参数 在缩进块中编写函数体，函数体的第一行语句可以使用文档字符串（用来存放函数说明） 用 return 语句结束函数，return 后面可以跟返回值，不带值表示返回 None 语法格式定义函数格式如下： 123456def 函数名(参数1, 参数2, ... , 参数N) \"函数说明\" ...... 函数体 ...... return 返回值1, 返回值2, ... , 返回值N 定义函数示例 - 求绝对值我们定义一个用来求绝对值的 myAbs 函数 代码： 12345def myAbs(num): if num &gt;= 0: return num else: return -num 运行结果： 可以看到运行结果并没有打出任何内容，是因为我们仅仅定义了这个函数并没有对他进行调用 函数返回值在讲调用之前我们先来讲解什么是函数的返回值 return 表示返回的意思，函数体内部的语句在执行时一旦执行到 return ，函数就执行完毕并将结果返回 因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑 分析上面函数 在参数&gt;=0时返回参数本身，在参数&lt;0时返回参数相反数 定义函数示例 - 求正方形周长面积除了返回一个值以外，函数也可以返回多个值 在函数中如果需要返回多个值，值与值之间使用逗号分隔即可，但是需要注意顺序 比如我们定义一个用来求正方形周长面积的 squareDate 函数 代码： 1234def squareDate(side): c = 4 * side s = side * side return c, s 运行结果： 可以看到运行结果并没有打出任何内容，还是因为我们没有调用函数 调用函数在本节之前的内容里我们调用了很多Python内置的函数 通过函数名后面跟圆括号，括号里传入函数需要的参数就可以完成函数的调用 需要用到函数返回值的可以直接接收返回值或者直接打印 不需要返回值或者返回值为None的可以省略函数名前的 返回值 = 语法格式调用函数格式如下： 1返回值1, 返回值2, ... , 返回值N = 函数名(参数1, 参数2, ... , 参数N) 上面我们定义了求绝对值以及求正方形周长面积两个函数，现在我们写代码来调用这两个函数 调用函数示例 - 求绝对值代码： 1234absA = myAbs(7)print(\"7的绝对值是&#123;&#125;\".format(absA))absB = myAbs(-9)print(\"-9的绝对值是&#123;&#125;\".format(absB)) 运行结果： 调用函数示例 - 求正方形周长面积代码： 1234cA, sA = squareDate(7)print(\"边长为7的正方形周长是&#123;&#125;面积是&#123;&#125;\".format(cA, sA))cB, sB = squareDate(9)print(\"边长为9的正方形周长是&#123;&#125;面积是&#123;&#125;\".format(cB, sB)) 运行结果： 函数内部调用其他函数在函数内部，还可以调用其他函数 比如求正方形周长面积函数中同时返回正方形的周长和面积 而求周长和求面积是完全独立的逻辑，可以定义成两个新的函数 然后在求正方形周长面积函数中调用这两个新函数，得到结果并返回 代码： 12345678910111213def squareS(side): return side * sidedef squareC(side): return 4 * sidedef squareDate(side): c = squareC(side) s = squareS(side) return c, sc, s = squareDate(7)print(\"边长为7的正方形周长是&#123;&#125;面积是&#123;&#125;\".format(c, s)) 运行结果： 在函数内部调用其他函数，是非常常见的 通过合理逻辑拆分可以起到降低程序复杂度的作用 递归函数在一个函数内部调用其自身，这个函数就是递归函数 语法格式定义递归函数格式如下： 12345def 函数名() ...... 函数名() ...... return 使用示例比如我们定义一个用来计算阶乘的 factorial 函数 我们先用数学方法计算 num 的阶乘 num!= 1 * 2 * 3 * … * (num-1) * num= (num-1)! * num 我们要定义的函数 factorial(num) 只有当 num=1 时需要特殊处理（返回1） 其他情况下 factorial(num) 也就等于 factorial(num-1) * num 代码： 12345678def factorial(num): if num == 1: return 1 return factorial(num - 1) * numprint(factorial(1))print(factorial(5)) print(factorial(9)) 运行结果： 递归函数的优点是定义简单，逻辑清晰 理论上所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰","tags":[]},{"title":"Python读取、新增、删除Set容器中的数据","date":"2021-05-22T16:00:00.000Z","path":"article/20210523.html","text":"这篇文章来写一下如何对Set容器中的数据进行读取、新增、删除操作 读取由于Set里面的元素是没有顺序的，因此我们不能像访问List那样通过索引来访问Set 访问Set中的某个元素实际上就是判断一个元素是否在Set中 我们可以使用in来判断某个元素是否在Set中 语法格式判断某个元素是否在Set中格式如下： 1item in set 使用示例班里有 ‘Alice’, ‘Bob’, ‘Candy’, ‘David’, ‘Ellena’ 五位学生 把他们存入Set中并且判断Candy和Frank是否在班级中 代码： 123students = set(['Alice', 'Bob', 'Candy', 'David', 'Ellena'])'Candy' in students'Frank' in students 运行结果： 新增新增单个元素Set本身提供了add方法，传入元素就可以新增到set中 语法格式格式如下： 1set.add(item) 使用示例班里有 ‘Alice’, ‘Bob’, ‘Candy’, ‘David’, ‘Ellena’ 五位学生 把他们存入Set中并且新增名为Frank的学生 代码： 1234students = set(['Alice', 'Bob', 'Candy', 'David', 'Ellena'])print(students)students.add('Frank')print(students) 运行结果： 批量新增元素有些时候需要往Set里添加多个元素，如果一个一个add是比较麻烦的 Set提供了update()方法，可以一次性给set添加多个元素 语法格式格式如下： 1set.update([item1, item2, ... , itemN]) 使用示例班里有 ‘Alice’, ‘Bob’, ‘Candy’, ‘David’, ‘Ellena’ 五位学生 把他们存入Set中并新增一批同学名字分别是 ‘Hally’, ‘Isen’, ‘Jenny’, ‘Karl’ 代码： 1234students = set(['Alice', 'Bob', 'Candy', 'David', 'Ellena'])print(students)students.update(['Hally', 'Isen', 'Jenny', 'Karl'])print(students) 运行结果： 删除删除指定元素Set本身提供了discard方法允许我们删除Set中的元素 语法格式格式如下： 1set.discard(item) 使用示例班里有 ‘Alice’, ‘Bob’, ‘Candy’, ‘David’, ‘Ellena’ 五位学生 把他们存入Set中并删除Candy 代码： 1234students = set(['Alice', 'Bob', 'Candy', 'David', 'Ellena'])print(students)students.discard('Candy')print(students) 运行结果： 清除所有元素和Dict一样，Set也提供了clear()方法，可以快速清除Set中所有的元素 语法格式格式如下： 1set.clear() 使用示例班里有 ‘Alice’, ‘Bob’, ‘Candy’, ‘David’, ‘Ellena’ 五位学生 定义一个Set存储学生姓名，之后清除Set中的所有元素 代码： 1234students = set(['Alice', 'Bob', 'Candy', 'David', 'Ellena'])print(students)students.clear()print(students) 运行结果： 判断集合是否重合需要判断两个集合是否有重合的地方，需要使用for循环一个一个的去判断，非常麻烦 Set本身提供了isdisjoint方法快速判断两个集合是否有重合，如果有重合，返回False，否则返回True 语法格式格式如下： 1set1.isdisjoint(item2) 使用示例1班里有 ‘Alice’, ‘Bob’, ‘Candy’, ‘David’, ‘Ellena’ 五位学生 2班里有 ‘David’, ‘Ellena’, ‘Frank’, ‘Green’, ‘Hally’ 五位学生 把1、2班学生分别存入两个Set中，判断是否有学生在两个班中 代码： 123students1 = set(['Alice', 'Bob', 'Candy', 'David', 'Ellena'])students2 = set(['David', 'Ellena', 'Frank', 'Green', 'Hally'])students.isdisjoint('Candy') 运行结果：","tags":[]},{"title":"Python字典(Dict)的特性","date":"2021-05-20T16:00:00.000Z","path":"article/20210521.html","text":"查找速度快字典(Dict)的第一个特点是查找速度快，无论Dict有10个元素还是10万个元素，查找速度都一样 而List的查找速度随着元素增加而逐渐下降 不过Dict的查找速度快不是没有代价的，Dict的缺点是占用内存大，还会浪费很多内容 List正好相反，占用内存小，但是查找速度慢 Python遍历Dict通过直接print(dict)打印出来的是完整的一个Dict 有时候，我们需要把Dict中满足一定条件的元素打印出来 这种时候需要使用for循环遍历Dict，并通过条件判断把满足条件的打印出来 Dict提供了items()方法，会返回Dict中所有的元素，每个元素包含key和value 语法格式遍历Dict格式如下： 12for key, value in dict.items(): for循环子分支 执行流程判断Dict中是否还有新的key-value对 有新key-value对时取新key-value对执行子逻辑分支操作 没有新key-value对结束循环 使用示例学生成绩如下： ‘Alice’: 45, ‘Bob’: 60, ‘Candy’: 75, ‘David’: 86, ‘Ellena’: 94 定义一个Dict存储学生成绩并且打印出大于70分的学生成绩 代码： 12345678910dict = &#123; 'Alice': 45, 'Bob': 60, 'Candy': 75, 'David': 86, 'Ellena': 94&#125;for key, value in dict.items(): if value &gt; 70: print(key, value) 运行结果：","tags":[]},{"title":"Python读取、新增、修改、删除Dict容器中的数据","date":"2021-05-19T16:00:00.000Z","path":"article/20210520.html","text":"这篇文章来写一下如何对Dict容器中的数据进行读取、新增、修改、删除操作 读取根据key读取valueDict本身提供了get方法，把key当作参数传递给get方法就可以获取对应的value，当key不存在时会返回None 语法格式格式如下： 1dict.get(key) 使用示例学生成绩如下： ‘Alice’: 45, ‘Bob’: 60, ‘Candy’: 75, ‘David’: 86, ‘Ellena’: 94 定义一个Dict存储学生成绩并且打印出Bob和David的成绩 代码： 123456789dict = &#123; 'Alice': 45, 'Bob': 60, 'Candy': 75, 'David': 86, 'Ellena': 94&#125;dict.get('Bob')dict.get('David') 运行结果： 读取Dict的所有keyDict本身提供了keys方法，可以返回dict中所有的key 语法格式格式如下： 1dict.keys() 使用示例学生成绩如下： ‘Alice’: 45, ‘Bob’: 60, ‘Candy’: 75, ‘David’: 86, ‘Ellena’: 94 定义一个Dict存储学生成绩并且打印出所有学生姓名 代码： 12345678dict = &#123; 'Alice': 45, 'Bob': 60, 'Candy': 75, 'David': 86, 'Ellena': 94&#125;dict.keys() 运行结果： 读取Dict的所有valueDict本身提供了values方法，可以返回dict中所有的value 语法格式格式如下： 1dict.values() 使用示例学生成绩如下： ‘Alice’: 45, ‘Bob’: 60, ‘Candy’: 75, ‘David’: 86, ‘Ellena’: 94 定义一个Dict存储学生成绩并且打印出所有学生成绩值 代码： 12345678dict = &#123; 'Alice': 45, 'Bob': 60, 'Candy': 75, 'David': 86, 'Ellena': 94&#125;dict.values() 运行结果： 新增可以使用赋值语句往Dict里面新增key-value对 语法格式格式如下： 1dict[key] = value 使用示例学生成绩如下： ‘Alice’: 45, ‘Bob’: 60, ‘Candy’: 75, ‘David’: 86, ‘Ellena’: 94 定义一个Dict存储学生成绩，添加Frank的成绩59，Green成绩100 代码： 1234567891011dict = &#123; 'Alice': 45, 'Bob': 60, 'Candy': 75, 'David': 86, 'Ellena': 94&#125;print(dict)dict['Frank'] = 59dict['Green'] = 100print(dict) 运行结果： 修改上面我们用赋值语句往Dict里面新增了新的元素 如果说使用赋值语句时传入Dict中已存在的key，就会变成修改该key对应的value值 语法格式格式如下： 1dict[key] = value 使用示例学生成绩如下： ‘Alice’: 45, ‘Bob’: 60, ‘Candy’: 75, ‘David’: 86, ‘Ellena’: 94 定义一个Dict存储学生成绩，修改Alice的成绩为73，Candy的成绩为100 代码： 1234567891011dict = &#123; 'Alice': 45, 'Bob': 60, 'Candy': 75, 'David': 86, 'Ellena': 94&#125;print(dict)dict['Alice'] = 73dict['Candy'] = 100print(dict) 运行结果： 删除删除指定元素Dict本身提供了pop方法，把key当作参数传递给pop方法就可以删除该元素并返回对应的value 语法格式格式如下： 1dict.pop(key) 使用示例学生成绩如下： ‘Alice’: 45, ‘Bob’: 60, ‘Candy’: 75, ‘David’: 86, ‘Ellena’: 94 定义一个Dict存储学生成绩，删除Candy的成绩 代码： 12345678910dict = &#123; 'Alice': 45, 'Bob': 60, 'Candy': 75, 'David': 86, 'Ellena': 94&#125;print(dict)dict.pop('Candy')print(dict) 运行结果： 清除所有元素Dict本身提供了clear方法，可以清除Dict中所有的元素 语法格式格式如下： 1dict.clear() 使用示例学生成绩如下： ‘Alice’: 45, ‘Bob’: 60, ‘Candy’: 75, ‘David’: 86, ‘Ellena’: 94 定义一个Dict存储学生成绩，之后清除Dict中的所有元素 代码： 12345678910dict = &#123; 'Alice': 45, 'Bob': 60, 'Candy': 75, 'David': 86, 'Ellena': 94&#125;print(dict)dict.clear()print(dict) 运行结果：","tags":[]},{"title":"Python访问Tuple容器的其他方法","date":"2021-05-17T16:00:00.000Z","path":"article/20210518.html","text":"由于Tuple一旦定义之后便不可修改，所以在实际编程中，Tuple经常用于存放固定不变的数据 在使用上Tuple提供了便捷的方法可以访问Tuple中的数据 count()方法count()方法用来统计tuple中某个元素出现的次数 语法格式count()方法格式如下： 1count(item) 使用示例计数 1, 1, 2, 2, 3, 3, 1, 3, 5, 7, 9 中1、5、9出现的次数 代码： 1234tuple = (1, 1, 2, 2, 3, 3, 1, 3, 5, 7, 9)tuple.count(1)tuple.count(5)tuple.count(9) 运行结果： index()方法index()方法用来返回指定元素的下标，当一个元素多次重复出现时，则返回第一次出现的下标位置 语法格式index()方法格式如下： 1index(index) 使用示例返回 1, 1, 2, 2, 3, 3, 1, 3, 5, 7, 9 中1、5、9的下标 代码： 1234tuple = (1, 1, 2, 2, 3, 3, 1, 3, 5, 7, 9)tuple.index(1)tuple.index(5)tuple.index(9) 运行结果：","tags":[]},{"title":"Python元组(Tuple)的特性","date":"2021-05-16T16:00:00.000Z","path":"article/20210517.html","text":"元组的不可变性元组(Tuple)有一个很重要的特性就是他是固定不变的，Tuple中的每一个元素都不可被改变，同时也不能再往Tuple中添加数据 也正是因为Tuple的不可变性，使得Tuple的运行性能是List的数倍 可变Tuple上面说到Tuple和List一个最大的不同点就是Tuple是不可变的 但这针对的仅仅是基础数据类型（数字类型、布尔类型、字符串类型）的数据，对于组合数据类型则不受这个约束 比如Tuple中的某个元素是List，那么该List内部的元素是可以被改变的 代码示例： 12345tuple = (1, 'CH', [3, 4])print(tuple)list = tuple[2]list[1] = 2print(tuple) 执行流程： 先定义一个tuple存放一个数字，一个字符串，一个列表 打印tuple 取tuple的第三个元素list 把列表list的第二个元素改为2 再次打印tuple 运行结果： tuple中的第三个元素已经成功被改变了，这就有悖元组的不可变性，我们来画图分析一下原因 这是因为虽然元组中的列表元素改变了，但是Tuple本身指向的List仍然是同一个List List本身并没有改变，改变的只是List里面的一个元素，这是Tuple不可变性所约束不到的范围","tags":[]},{"title":"Python二维列表","date":"2021-05-14T16:00:00.000Z","path":"article/20210515.html","text":"什么是二维列表首先来回顾一下什么时列表(List)，List本质上就是一个容器，可以存放不同类型的元素 并没有规定里面必须要放什么东西，所以可以在大容器里放小容器（小容器就是大容器的元素） 在List里面存放List，就会得到二维列表 创建二维列表如下图所示是Alice、Bob、David三人的成绩单，请把他们存入List中并顺序打印 代码： 123456aliceScore = [100, 89, 92]bobScore = [70, 65, 81]davidScore = [88, 72, 77]scoreList = [aliceScore, bobScore, davidScore]for score in scoreList: print(score) 运行结果： 访问指定位置比如说要打印出Bob的英语成绩可以这样写： 1print(scoreList[1][2]) 其中scoreList[1]得到Bob的成绩列表，再通过下标[2]得到Bob的英语成绩","tags":[]},{"title":"Python新增、修改、删除List容器中的数据","date":"2021-05-13T16:00:00.000Z","path":"article/20210514.html","text":"上篇文章记录了如何访问List容器中的数据，这篇文章来写一下如何新增、修改、删除List容器中的数据 新增元素新增元素的方式有 append 和 insert 两种： append方法新增元素append方法会把新的元素添加到现有元素之后 insert(index, item) 方法：把新的元素添加到指定位置，该位置及之后的所有元素均往后移一位 语法格式新增元素append方法格式如下： 1append(item) 使用示例原来班级里有 ‘Alice’, ‘Bob’, ‘David’, ‘Ellena’ 四名同学 现在转来一位名为 ‘Frank’ 的新同学，请把新同学添加进学生列表中 代码： 1234list = ['Alice', 'Bob', 'David', 'Ellena']print(list)list.append('Frank')print(list) 运行结果： insert方法新增元素insert方法会把新的元素添加到指定索引位置，该位置及之后的所有元素均往后移一位 语法格式新增元素insert方法格式如下： 1insert(index, item) 使用示例原来班级里有 ‘Alice’, ‘Bob’, ‘David’, ‘Ellena’, ‘Frank’ 五名同学 现在转来一位名为 ‘Candy’ 的新同学，请把新同学添加进学生列表中的第3位 代码： 1234list = ['Alice', 'Bob', 'David', 'Ellena', 'Frank']print(list)list.insert(2, 'Candy')print(list) 运行结果： 删除元素语法格式删除元素pop方法格式如下： 1pop(index) 该方法可以传入索引值作为参数，也可以不传参 不传参：默认删除最后一个元素 传参：删除指定索引位置的元素，该位置之后的所有元素均往前移一位 使用示例(不传参)原来班级里有 ‘Alice’, ‘Bob’, ‘Candy’, ‘David’, ‘Ellena’, ‘Frank’ 六名同学 现在 ‘Frank’ 同学因为家庭原因需要转学，请把他从学生列表中删除 代码： 1234list = ['Alice', 'Bob', 'Candy', 'David', 'Ellena', 'Frank']print(list)list.pop()print(list) 运行结果： 使用示例(传参)原来班级里有 ‘Alice’, ‘Bob’, ‘Candy’, ‘David’, ‘Ellena’ 五名同学 现在 ‘Candy’ 同学因为家庭原因需要转学，请把他从学生列表中删除 代码： 1234list = ['Alice', 'Bob', 'Candy', 'David', 'Ellena']print(list)list.pop(2)print(list) 运行结果： 修改元素除了可以向列表添加、删除列表元素以外，列表已有的元素也是可以修改的 我们通过索引指定位置，给该位置赋值新的元素，即可替换列表中原有的元素，已达到修改元素的目的 语法格式1list[index] = newItem 使用示例原来班级里有 ‘Alice’, ‘Bob’, ‘David’, ‘Ellena’ 四名同学 现在 ‘Ellena’ 同学的名字打错了，正确的应该是 ‘Ellen’，请修改学生列表中的元素 代码： 1234list = ['Alice', 'Bob', 'David', 'Ellena']print(list)list[3] = 'Ellen'print(list) 运行结果：","tags":[]},{"title":"Python访问List容器的三种方式","date":"2021-05-12T16:00:00.000Z","path":"article/20210513.html","text":"列表(List)是一种有序的容器，放入List中的元素，将会按照一定顺序排列 我们在访问List中元素的时候有 顺序 倒序 使用索引号 三种访问方式 顺序访问List在for循环的练习中我们使用 for循环访问字符串中的每一个字符 在这里我们同样使用 for循环访问列表每一个元素 的方法，这种方式又称为 迭代 语法格式顺序访问List格式如下： 123list = [item0, item1, item2, ... , itemN]for item in list: for循环子分支 执行流程判断List中是否还有新item 有新item时取新item执行子逻辑分支操作 没有新item结束循环 使用示例学生成绩分别是 95.5, 85, 81, 78, 72, 69, 66.5, 61, 59 求学生平均分 代码： 12345678list = [95.5, 85, 81, 78, 72, 69, 66.5, 61, 59]sum = 0count = 0for item in list: sum = sum + item count = count + 1print(sum/count) 运行结果： 使用索引号访问List在List里面，每一个元素都有一个唯一的位置，我们称之为索引(index) 在字符串切片的练习中我们使用 位置取字符串中的单个字符 在这里我们同样使用 索引取List中的单个元素 的方法 语法格式使用索引号访问List格式如下： 123456list = [item0, item1, item2, ... , itemN]print(list[0])print(list[1])print(list[2])...print(list[N]) 使用示例学生成绩分别是 95.5, 85, 81, 78, 72, 69, 66.5, 61, 59 求前三名成绩 代码： 12345list = [95.5, 85, 81, 78, 72, 69, 66.5, 61, 59]for i in range(0,3): print(list[i])print(list[0:3]) 运行结果： 倒序访问ListPython的列表，除了支持正向顺序索引获取列表中的每一个元素以外，也支持倒序访问list中的每一个元素 可以使用-1来表示最后一个元素，-2表示倒数第二个元素，以此类推 语法格式倒序访问List格式如下： 123456list = [item0, item1, item2, ... , itemN]print(list[-N-1])print(list[-N])print(list[-N+1])...print(list[-1]) 使用示例学生成绩分别是 95.5, 85, 81, 78, 72, 69, 66.5, 61, 59 求前三名成绩 代码： 12345list = [95.5, 85, 81, 78, 72, 69, 66.5, 61, 59]for i in range(-9,-6): print(list[i]) print(list[-9:-6]) 运行结果：","tags":[]},{"title":"Python容器","date":"2021-05-10T16:00:00.000Z","path":"article/20210511.html","text":"什么是容器 在生活中，容器指的是可以容纳多个物品的收纳器 在程序中，容器指的是可以把多个元素放在一起的数据结构 容器中的元素可以用for循环逐个地迭代获取 还可以用in, not in等关键字来判断某个元素是否包含在容器中 因为Python是动态语言，所以容器里可以同时同时放入数字、字符串等任意类型的元素 在Python中，列表(List)、元组(Tuple)、字典(Dict)、集合(Set)都可以放入多个元素，因此都可以算作是容器 列表(List)列表(List)是一种有序的容器，放入List中的元素，将会按照一定顺序排列 定义List的方法非常简单，使用中括号[]把需要放在容器里面的元素括起来就可以定义一个列表，代码格式如下： 1list = [item0, item1, item2, ... , itemN] 元组(Tuple)元组(Tuple)和List一样，也是一个有序容器 在Tuple中，同样可以包含0个或者多个元素，并且也支持索引访问、切片等操作 定义Tuple的方式是使用小括号()将Tuple内的元素括起来，代码格式如下： 1tuple = (item0, item1, item2, ... , itemN) List和Tuple相互转换Tuple可以使用 list() 方法转换成List，代码格式如下： 1list = list(tuple) List可以使用 tuple() 方法转换成Tuple，代码格式如下： 1tuple = tuple(list) ##字典(Dict) Dict是专门保存映射的，在Dict中，每一项包含一个key和一个value，key和value是一一对应的 定义Dict的方式是使用花括号{}将Dict内的元素(key-value对)包起来，key和value之间使用冒号:分割，并且每一组key:value后用逗号,表示这一组的结束，代码格式如下： 1234567dict = &#123; 'key0': 'value0', 'key1': 'value1', 'key2': 'value2', ...... 'keyN': 'valueN'&#125; 集合(Set)Set和List类似，是可以放入一系列元素的容器，他们也有区别： Set里面的元素是不允许重复的，而List里面可以包含相同的元素 Set里面的元素是没有顺序的，而List里面的元素是有顺序的 定义Set的方法set()，并传入一个List，List的元素将会被转换成Set的元素，代码格式如下： 1set = set([item0, item1, item2, ... , itemN]) 如果传入的List中有重复的元素，转成Set后只会保留一个","tags":[]},{"title":"Python循环嵌套","date":"2021-05-07T16:00:00.000Z","path":"article/20210508.html","text":"就像多层 if-else 嵌套一样，Python语言的循环语句也支持嵌套，允许在一个循环体里面嵌入另一个循环 如果说没有break或者continue，嵌套后内循环中代码块执行次数 = 外循环执行次数 * 内循环执行次数 嵌套循环对于循环的种类没有限制，也就是说for和while可以任意组合，本文将分别举例说明 在for循环中嵌入for循环输出字符串’ABC’中每个字符和字符串’123’中每个字符的所有排列组合方式 代码： 12345str1 = 'ABC'str2 = '123'for x in str1: for y in str2: print(x + y) 运行结果： 流程分析： 在while循环中嵌入while循环输出2~100之间的素数(也称质数，指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数) 代码： 12345678910i = 2while(i &lt; 100): j = 2 while(j &lt;= (i/j)): if not(i%j): break j = j + 1 if (j &gt; i/j) : print(i) i = i + 1 运行结果： 流程分析： 在for循环中嵌入while循环打印等腰三角形 代码： 12345678910for row in range(1,6): j = 1 while j &lt;= 5-row: print(' ',end='') j+=1 k = 1 while k &lt;= 2*row-1: print('*',end='') k += 1 print() 运行结果： 流程分析： 在while循环中嵌入for循环输出99乘法表 代码： 123456789template = '&#123;&#125;*&#123;&#125;=&#123;&#125;'row = 1while row &lt; 10: for col in range(1,10): if col &gt; row: break print(template.format(row,col,row*col), end=' ') print('') row = row + 1 运行结果： 流程分析：","tags":[]},{"title":"Python跳出循环","date":"2021-05-06T16:00:00.000Z","path":"article/20210507.html","text":"循环语句中，while循环条件为真 或者 for循环序列中还有新的元素，循环就会一直进行下去 如果在循环中需要终止循环就会用到 break 语句或者 continue 语句，两者区别如下： break 语句：跳出整个循环 continue 语句：跳出本次循环，执行下次循环 break执行流程在while循环（左图）和for循环（右图）中加入 break 之后的执行流程如下图所示： 可以看到两种循环都会在 break 之后跳出整个循环 使用示例while循环代码： 123456var = 10while var &gt; 0: var = var - 1 if var == 5: break print(var) 运行结果： for循环代码： 1234for letter in 'Python': if letter == 'h': break print(letter) 运行结果： continue执行流程在while循环（左图）和for循环（右图）中加入 continue 之后的执行流程如下图所示： 可以看到两种循环都会在 continue 之后跳出本次循环，执行下次循环 使用示例while循环代码： 123456var = 10while var &gt; 0: var = var - 1 if var == 5: continue print(var) 运行结果： for循环代码： 1234for letter in 'Python': if letter == 'h': continue print(letter) 运行结果：","tags":[]},{"title":"Python循环语句","date":"2021-05-05T16:00:00.000Z","path":"article/20210506.html","text":"程序在一般情况下是按顺序执行的，在需要执行一个语句或语句组多次的场景中会用到循环语句 代码里的循环语句主要有两种，一种是while循环一种是for循环 while语法格式循环语句格式如下：1234&#96;&#96;&#96;pythonwhile 判断条件： while子逻辑分支 执行流程判断条件是否为真 判断条件为真时执行子逻辑分支操作 判断条件为假时循环结束 使用示例现在我们来写一段代码，使用while循环计算1~100的和 代码： 1234567num = 0sum = 0while num &lt; 100: num = num + 1 sum = sum + numprint(sum) 运行结果： 在上述代码中，while的判断条件是num&lt;100 也就是说，当num&lt;100时循环会继续下去，当num&gt;=100时将跳出循环 因为num在while循环里面不断加1，最终一定会大于等于100 因此while循环不会无限进行下去 for语法格式循环语句格式如下：1234&#96;&#96;&#96;pythonfor 元素 in 序列: for子逻辑分支 执行流程判断序列中是否还有新元素 有新元素时取新元素执行子逻辑分支操作 没有新元素结束循环 使用示例现在我们来写一段代码，数一数单词 sunny 中有多少个字母 代码： 123456str = 'sunny'count = 0for s in str: count = count + 1print(count) 运行结果：","tags":[]},{"title":"Python条件判断","date":"2021-05-03T16:00:00.000Z","path":"article/20210504.html","text":"市面上的软件硬件之所以能自动化的完成任务、智能的为大家服务，是因为它可以自己通过程序判断自己该执行什么操作 在代码里我们常用条件判断语句来设定程序在不同场景下应该执行的操作 if-else语句格式条件判断语句格式如下：123456&#96;&#96;&#96;pythonif 判断条件: if子逻辑分支else: else子逻辑分支 TIPS: 语句格式中需要注意的点有两个: 在if语句的最后，有一个 : 子逻辑分支代码 明显比上一行代码缩进了4个字符 是条件判断的格式，表示接下来是if模块或者else模块的子分支代码块1234567891011121314151617181920212223242526272829也正是因为是子分支代码块，所以需要缩进在Python规范中，一般使用 **1个Tab键（推荐）** 或者 4个空格键 作为缩进### 执行流程判断条件是否为真当if条件为真（True）时，执行if的子逻辑分支在if条件为假（False）时，执行else的子逻辑分支![](https:&#x2F;&#x2F;gengrui01.github.io&#x2F;picture&#x2F;python-if-else&#x2F;2.png)### 使用示例例如在满分100分的考试中，小于60分的记为不及格，大于60分的记为及格现在我们来写一段代码，在输入成绩后自动判断成绩是否及格代码：&#96;&#96;&#96;pythonscore &#x3D; 59if score &lt; 60: print(&#39;不及格&#39;)else: print(&#39;及格&#39;) 运行结果： 可以看到程序就会根据score的值判断，走不同的子分支打印出不同的内容 如果想对达到或者超过60分的学生再进行不同的分类，比如超过90分是卓越，超过80分是优秀超过70分良好 代码： 1234567891011121314score = 59if score &lt; 60: print('不及格')else: if score &lt; 70: print('及格') else: if score &lt; 80: print('良好') else: if score &lt; 90: print('优秀') else: print('卓越') 运行结果： 虽然我们得出了自己需要的结果，但是随着判断条件的增多代码缩进也越来越多，导致代码逻辑看起来也不够清晰 为了简化以上逻辑我们使用 if-elif-else 语句，其中 elif 相当于 else if 的意思 if-elif-else语句格式条件判断语句格式如下：123456789101112&#96;&#96;&#96;pythonif 条件A: if子逻辑分支elif 条件B: elif子逻辑分支1............elif 条件C: elif子逻辑分支2else: else子逻辑分支 执行流程判断条件A是否为真 条件A为真（True）时，执行if子逻辑分支 条件A为假（False）时，判断条件B是否为真 条件B为真（True）时，执行elif子逻辑分支1 条件B为假（False）时，判断条件C是否为真 条件C为真（True）时，elif子逻辑分支2 条件C为假（False）时，执行else的子逻辑分支 TIPS: 这一系列条件判断会从上到下依次判断如果某个判断为 True 就会直接执行对应的代码块后面的条件判断就忽略不再执行了 使用示例代码： 1234567891011score = 80if score &lt; 60: print('不及格')elif score &lt; 70: print('及格')elif score &lt; 80: print('良好')elif score &lt; 90: print('优秀')else: print('卓越') 运行结果：","tags":[]},{"title":"Python字符串切片","date":"2021-05-01T16:00:00.000Z","path":"article/20210502.html","text":"取字符串中的单个字符字符串由一个个字符组成，每一个字符都有一个唯一的位置 比如字符串 &#39;ABC&#39; ，第一个字符是 A ，第二个字符是 B ，第三个字符是 C 我们可以使用 [a] 按照位置的方式取出字符串中的字符 不过需要注意的是，在程序的世界中，计数是从0开始的，这里使用0来表示第一个位置 代码： 1234s = 'ABC'print(s[2])print(s[1])print(s[0]) 运行结果： 取字符串的字串按照上述方法我们可以切取出字符串中的任意一个字母，但有时候我们不止需要字符串中的一个字母，会想切取字符串的一部分（子串） 这个时候我们需要在中括号中填入两个数字用冒号分开 [a:b] ，其中a和b分别表示需要切取的开始位置和结束位置 TIPS: 这是半闭半开区间，也就是说切取出的子串会包含开始位置但不包含结束位置 代码： 12345s = 'ABCDEFGHIJK'print(s[0:4])print(s[2:6])print(s[5:10])print(s[5:11]) 运行结果：","tags":[]},{"title":"Python字符串模板化","date":"2021-04-30T16:00:00.000Z","path":"article/20210501.html","text":"简单字符串输出的内容是固定的 有时候输出的内容是有固定的模板，但具体内容是不是固定的 这个时候需要使用format来使字符串模板化 用固定的模板输出不固定的内容 字符串format创建及使用字符串format由字符串模板和模板数据内容两个部分组成，通过 { } 把模板数据内容嵌到字符串模板对应的位置 代码： 123template = 'Hello &#123;&#125;'world = 'World'print(template.format(world)) 运行结果： 字符串format包含多模板如果模板中{}比较多则容易错乱，我们在定义模板的时候可以指定模板数据内容的顺序或者数据内容名，使得在format过程更加清晰 指定模板数据顺序代码： 12template = '* &#123;0&#125; * &#123;1&#125; * &#123;2&#125; * &#123;3&#125; * &#123;4&#125; * &#123;5&#125; * &#123;6&#125; *'print(template.format('你', '是', '年', '少', '的', '欢', '喜')) 运行结果： 调整模板顺序后打印，打印时的输入顺序不变 代码： 12template = '* &#123;6&#125; * &#123;5&#125; * &#123;4&#125; * &#123;3&#125; * &#123;2&#125; * &#123;1&#125; * &#123;0&#125; *'print(template.format('你', '是', '年', '少', '的', '欢', '喜')) 运行结果： 指定模板数据名定义模板： 1template = 'Hello&#123;w&#125;\\nHello&#123;c&#125;\\nHello&#123;b&#125;' 定义数据内容： 123world = \"World!\"china = \"China!\"beijing = \"Beijing!\" 使用模板并打印： 1print(template.format(w = world, c = china, b = beijing)) 运行结果：","tags":[]},{"title":"Python字符串转义","date":"2021-04-29T16:00:00.000Z","path":"article/20210430.html","text":"之前的文章说到过，字符串可以用 &#39; &#39; 或者 &quot; &quot; 括起来表示 如果字符串本身包含 ‘ 怎么办？比如我们要表示字符串 I&#39;m OK ，这时，可以用 &quot; &quot; 括起来表示： 代码： 1print (\"I'm OK\") 运行结果： 同理，如果字符串包含 “ ，我们就可以用 &#39; &#39; 括起来表示： 代码： 1print ('Anne said \"Hello Python!\"') 运行结果： 转义字符如果字符串既包含 ‘ 又包含 “ 怎么办？ 这个时候，就需要对字符串中的某些特殊字符进行 转义 ，Python字符串用 \\ 进行转义（转义字符 \\ 不计入字符串的内容中） 比如要表示字符串 Anne said &quot;I&#39;m OK&quot; 字符串内的 &#39; 和 &quot; 会引起歧义，因此，我们在它前面插入一个 \\ 表示这是一个普通字符，不代表字符串的起始 代码： 1print ('Anne said \\\"I\\'m OK\\\"') 运行结果： 转义整个字符串（raw字符串）如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦 为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个raw字符串 raw字符串中的内容会自动转义，不需要在每个字符前加 \\ 代码： 1print (r'\\(~_~)/ \\(~_~)/') 运行结果： raw字符串也同样适用于多行字符串，在多行字符串前面添加个前缀 r ，这个多行字符串也会变成一个raw字符串 代码： 12print (r'''Anne said \"I'm OK\"\\(~_~)/ \\(~_~)/ \\(~_~)/''') 运行结果： 常用转义其他常常用到转义字符的地方还有： \\n ：换行 \\t ：制表符 \\\\ ：\\字符本身","tags":[]},{"title":"Python布尔值运算","date":"2021-04-28T16:00:00.000Z","path":"article/20210429.html","text":"布尔类型只有True和False两种值，可以用and、or和not运算（注意and,or,not都是Python语言本身的关键字） and运算（与运算）只有所有都为 True，and运算结果才是 True 代码： 1234567True and TrueTrue and FalseFalse and TrueFalse and False 运行结果： or运算（或运算）只要其中有一个为 True，or 运算结果就是 True。 代码： 1234567True or TrueTrue or FalseFalse or TrueFalse or False 运行结果： not运算（非运算）是一个单目运算符，把 True 变成 False，False 变成 True 代码： 123not Truenot False 运行结果： TIPS: not计算的优先级是高于and和or的 代码： 1True and not False 运行结果： 在上述布尔计算中，先计算not False = True，然后再计算True and True，因此得到 True 的结果 与其他数据类型运算在Python中，布尔类型还可以与其他数据类型（字符串，数字等）做与或非运算 运算时会把0、空字符串和None看成False，其他数值和非空字符串都看成True 代码： 123456789True and 0True and 99False or 990 or \"123\"99 and \"\" 运行结果： 短路计算Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了直接返回结果 a and b 如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b 如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a a or b 如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a 如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b","tags":[]},{"title":"Python数字类型运算法则","date":"2021-04-27T16:00:00.000Z","path":"article/20210428.html","text":"在Python中整数和小数（浮点数）虽然属于不同的数据类型，但是在运算上是可以一起运算的，所以经常一起称为数字类型 ti 进制转换十进制转换成二进制使用Python进行进制转换的时候，可以使用bin()函数来将十进制转换成二进制 123a = 29b = bin(a)print(b) 运行结果： 十进制转换成八进制使用Python进行进制转换的时候，oct()函数来将十进制转换成八进制 123a = 29b = oct(a)print(b) 运行结果： 十进制转换成十六进制使用Python进行进制转换的时候，hex()函数来将十进制转换成十六进制 123a = 29b = hex(a)print(b) 运行结果： 八进制转十六进制123a = 0o35b = hex(a)print(b) 运行结果： 四则运算整数和浮点数可以直接进行四则运算 加法代码： 1234num1 = 10num2 = 0.5result = num1 + num2print(result) 运行结果： 减法代码： 1234num1 = 10num2 = 0.5result = num1 - num2print(result) 运行结果： 乘法代码： 1234num1 = 10num2 = 0.5result = num1 * num2print(result) 运行结果： 除法代码： 1234num1 = 10num2 = 0.5result = num1 / num2print(result) 运行结果： TIPS: 从上面可以发现一个规律，整数和浮点数运算后，得到的结果不管小数点后是否有值，结果都变成浮点数了这是合理的，因为浮点数可以表达整数的结果，但是整数不能表达浮点数的结果 取模运算Python数字支持取模运算，使用百分号%表示取模 代码： 123print(3 % 2)print(33 % 10)print(99 % 30) 运行结果： 地板除Python除了普通除法之外，还有一个特殊的除法被称为地板除 对于地板除，得到的结果只有整数的部分会忽略纯小数 地板除使用//进行 代码： 12310//410//2.510//3 运行结果： 保留小数点位数使用Python计算小数的时候，可以使用round()函数来保留小数点后若干位 调用round函数要输入两个参数，第一个是需要保留小数点位数的数值，第二个是要保留的位数 123num = 10 / 3print(num)round(num, 2) 运行结果：","tags":[]},{"title":"Python变量命名规范及如何定义变量","date":"2021-04-26T16:00:00.000Z","path":"article/20210427.html","text":"什么是变量变量的概念基本上和初中代数的方程变量是一致的 例如，对于方程式 y=x*x ，x就是变量 在Python中，变量指的是一段数据或者一段空间的别名 变量的作用 增强程序可读性 拒绝硬编码 提高了对程序的修改效率 变量命名变量命名规则 变量名必须以字母或者下划线(_)或者汉字开头 变量名中可以包括字母、下划线(_)、数字、汉字 变量名中不能出现Python关键字和保留字 变量名中要区分大小写，即 abc 和 Abc 不是同一个变量 常用变量命名法则在学习工作中，给变量命名的最高境界是见名知意 所以汉字、汉语拼音、单个字母、个别无意义的单词不推荐作为变量名，例如：年龄、xingming、a、the…… 推荐使用英文单词或者缩写对变量命名，例如：age、name…… 当一个单词不能准确表达变量含义，变量名由多个单词构成时通常使用如下法则进行变量命名： 驼峰命名法：除第一个单词外其余首字母大写，例如：myAge、yourName…… 大驼峰命名法：所有单词的首字母均大写，例如：MyAge、YourName…… posix命名法：变量名中所有字母均小写，俩单词间用下划线链接，例如：my_age、your_name…… 在开发工程中，程序员常常默认： 驼峰命名法用来对变量进行命名 大驼峰命名法用来对类进行命名 posix命名法很少用到 定义变量定义变量的方式很简单，通过 变量名=数据 ，即可定义一个变量 例如：temp = 1 在这个例子里面，temp就是变量，它的值是整数1 例如：hello = &#39;Hello&#39; 在这个例子里面，hello就是变量，它的值是字符串’Hello’ 在Python里面，一个变量可以先后存储多种不同类型的数据，比如下面的代码： 1234temp = 1print(temp)temp = 'ABC'print(temp) 起初temp存储的是整数1，之后存储的是字符串’ABC’ 这是Python这类语言特有的特性，我们称之为动态语言，Python、Javascript等等都是动态语言 与之对应的是静态语言，Java、C、C++等等属于静态语言","tags":[]},{"title":"Python基础数据类型","date":"2021-04-25T16:00:00.000Z","path":"article/20210426.html","text":"什么是数据类型计算机顾名思义就是可以做数学计算的机器，因此计算机程序理所当然地可以处理各种数值 但是计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据 不同种类的数据，就需要定义不同的数据类型来存储，认识编程中的不同数据类型是非常有必要的 Python中能够直接处理的有 整数、浮点数、字符串、布尔类型、空值 五种数据类型 这篇文章就来讲解这五种数据类型分别用来存放什么样的数据 至于Python提供的列表、字典等多种数据类型，以及创建自定义数据类型，本文不会介绍 整数Python可以处理任意大小的整数，这里的整数和我们生活中定义的整数是一个概念，例如：1,2,3,0,-1,-2,-3 等等都是整数 对于整数，除了生活中常用的十进制以外，计算机由于使用二进制，所以，在计算机中也常用二进制或者十六进制表示整数 在Python中使用以下方式表示二进制数和十六进制数： 二进制数都是由数字0、1组成，逢2进1。在Python中，二进制整数使用前缀0b表示，例如：0b0110, 0b1100 八进制数都是由数字0~7的数字组成，逢8进1。在Python中，八进制整数使用前缀0o表示，例如：0o123, 0o657 十六进制数除了09十个数字以外，还使用af表示10~15的数字，逢16进1。在Python中，十六进制使用前缀0x，例如：0x12ef, 0xde24 十进制数、二进制数和十六进制数之间是可以相互转换的，下篇文章会讲解python中不同进制转换的函数 浮点数什么是浮点数浮点数对应我们生活的是小数，例如：0.1, 3.1415926, -0.5, -12.34 等等都是浮点数 为什么小数在计算机领域被称为浮点数？这是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的（可浮动的），例如：1.23x10^9和12.3x10^8是相等的，因此称为浮点数 浮点数可以用数学写法，例如：1.23，3.14，-9.01，但是对于很大或很小的浮点数，就必须用科学计数法表示 在Python中，把10^用e替代，例如：1.23x10^9就可写为1.23e9或者12.3e8，0.000012可以写成1.2e-5 关于浮点数运算的误差整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的，而浮点数运算可能会有四舍五入的误差 我们在Python终端中输入0.1 + 0.2，期望的结果是0.3，看看得到的真实结果： 真实结果和我们所期望的值不一样，这就是浮点数运算所带来的误差 这里的原理涉及到了科学计数法底层的运算，如果感兴趣的可以自己进一步的学习原理层面的知识 字符串字符串表示记录文本信息的一种形式，对应生活中的就是非数字类型的内容，比如一个句子，一段话在Python中就是字符串 在Python中，字符串是用单引号（’ ‘）或者双引号（” “）括起来的任意文本，例如：&#39;abc&#39;, &quot;xyz&quot;等等都是字符串 TIPS: 单双引号只是一种表示方式，不是字符串的一部分因此字符串’abc’只有a，b，c这3个字符 如果要表示多行字符串，可以直接在需要换行的地方添加 \\n 1&#39;Line 1\\nLine 2\\nLine 3&#39; 也可以用叁引号（’’’ ‘’’）括起来表示，例如： 123&#39;&#39;&#39;Line 1Line 2Line 3&#39;&#39;&#39; 布尔值布尔值对应于生活中的就是对和错 在计算机的世界里，大部分判断都是非错则对的，一个布尔值只有True、False两种值，要么是True，要么是False 在Python中，可以直接用True、False表示布尔值（请注意大小写，不需要使用字符串符号括起来） 空值空值是Python里一个特殊的值，用None表示 TIPS: None和0是不一样的，None不能理解为0，因为0是有意义的比如我有0个苹果表示我没有苹果，0表达的是数值0的意思而不能表示为我有None个苹果，None是一个特殊的空值","tags":[]},{"title":"首次编写并运行Python程序","date":"2021-04-24T16:00:00.000Z","path":"article/20210425.html","text":"编写及运行Python程序的方法有两种 控制台编写代码并运行 编写Python文件并运行 下面主要讲解这两种方式下如何编写并运行Python程序 控制台编写代码并运行进入Python运行环境在控制台输入python进入Python运行环境（正确的Python运行环境会有&gt;&gt;&gt;的提示） 输入并运行第一行Python代码输入我们的第一行Python代码 1print('Hello World') 打印出Hello World说明第一行代码运行成功 如果代码出现错误需要核实： 在Hello World前后是否都有引号 print和&gt;&gt;&gt;不可以有空格 注意所有的标点符号均为英文字符 退出Python运行环境输入Python提供的quit()函数退出Python运行环境 编写Python文件并运行编写文件要注意以下两点： 编写工具：用记事本输入 文件后缀：.py 非必须 其他后缀Python解释器也可以执行它 编写第一个Python文件新建一个txt文件名为“hello” 在该文件内输入我们的第一行Python代码 要注意最前面不能有空格 1print('Hello World') 保存好之后修改文件的后缀名为.py 如上就完成了第一个Python文件的编写 运行第一个Python文件在控制台输入 python + Python文件路径 + \\ + Python文件名 运行Python文件中的代码 打印出Hello World说明第一个Python文件运行成功","tags":[]},{"title":"Python3.8版本安装","date":"2021-04-23T16:00:00.000Z","path":"article/20210424.html","text":"下载首先进入Python官网：Welcome to Python.org 点击 DownLoads 选择自己的电脑系统 之后查看所有的版本 找到 Looking for a specific release? 选择3.8的某个版本 点击右侧的 DownLoad 按钮进入下载详情页 进入详情页后 拉到最下面选择自己的电脑系统 点击后等待下载完成 安装首先勾选 Add Python 3.8 to PATH 接下来点击 Install Now 默认安装或者点击 Customize installation 自定义安装 我们这里选择自定义安装 目的是修改安装路径 进入如下界面是用来选择要安装的其他工具，可以看到默认安装了PIP包安装器等工具，直接点击下一步即可 最后修改Python安装路径 点击安装 等待安装 出现如下界面表示安装完成 安装检测Win + R 键打开运行框，输入cmd打开控制台 输入python -V查看Python版本号 打印出如下内容说明安装成功","tags":[]},{"title":"Python简介","date":"2021-04-22T16:00:00.000Z","path":"article/20210423.html","text":"定义：Python是一门面型对象、解释型的编程语言 特点：使用缩进作为逻辑层次 读音：拍桑（美） 派森（英） Python语言的历史 1989年 由 Guido · van Rossum 写下第一行Python代码 1991年2月 诞生第一个Python解释器 1994年1月 发布 Python1.0 版本（开源后更多开发者可以加入开发此框架 进入新的开发模式） 2000年10月 发布 Python2.0 版本（更多的开发者开始使用此语言） 2008年12月 发布 Python3.0 版本（2.0和3.0不完全兼容） 2020年 宣布停止 Python2.0 版本维护 Python能做什么 系统运维 自动化运维 网络编程 爬虫 服务器编程 搜索引擎 科学计算 数据分析 大数据 教学语言 入门简单易学习 AI 图像处理 游戏 TIPS: 加粗的方向Python已经占据了很大的市场 Python的特点Python的优点 纯面向对象 免费（公司使用后不怕有法律纠纷） 移植性能好 可混合编程（胶水语言 适合快速整合其他语言开发的内容） 开发效率高 简单明了 入门难度低 Python的缺点运行效率低，运行速度确实是python的软肋 Java C/C++ Python 对比 语言 类型 运行速度 代码量 C/C++ 编译成机器码 非常快 非常多 Java 编译成字节码 快 多 Python 解释执行 慢 少 Python开发环境搭建搭建Python开发环境需要安装如下内容： Python解释器 现在大多使用Python3.X，本博客内容使用 Python3.8 版本学习 注意：Python2.X已停止维护，Python2.X 写的代码在 Python3.X 运行时会报错 点击根据攻略完成 Python3.8版本安装 包安装器 常用包安装器有pip、conda等 Python解释器安装时会帮我们自动把pip安装好","tags":[]},{"title":"内推是什么？有哪些注意事项？如何争取？","date":"2021-04-16T16:00:00.000Z","path":"article/20210417.html","text":"最近一段时间是春招的高峰期，很多同学都忙着投简历准备面试 我发现一个现象，很多应届学生开始谈论“内推”，而一些求职平台，也会发布一些“内推机会”，“免费内推群” 在朋友圈已经看到了好几个“赶快加入XX内推群”的消息，现在应届生找工作都各种内推了？ 内推是什么？内推，顾名思义，是通过公司内部人员推荐，直接给用人部门投递简历推荐应聘者 用人部门会优先考虑内推的人员，这样可以极大缩短应聘流程，成功率也较高，看上去这是一个不错的渠道 用人部门基本也会卖推荐人一个面子，仔细看一下简历（当然，这个仔细，可能也就是把原来花20秒看简历的时间，变成30秒而已） 通过“内推”途径可以避开网申筛选笔试筛选，甚至还能避开可怕的群面，直接进单面，是不是很棒？ 如果推荐成功，公司基本上还会给推荐人奖金，从几百到上万的都有 这样想起来，用人部门很快就招到了靠谱的人，推荐人拿到了奖金，而应聘者则节约了很多应聘流程，真是一个三赢的局面 应届生求职现状大家都知道，现在找工作真的一年比一年难 每年的应届毕业生都是个天文数字，同时还要算上归国的留学生，还有上一届找工作落下的 所以校招基本上是一个职位上百人在应聘，有的公司有的岗位甚至能达到上千上万人竞争的情况 能够在校招中拿到一个名企的offer，那真的是杀出来的一条血路，手下败将数以百计 应届生进入名企，最常见的就如下两种途径： 走流程的网申（简历）-笔试-群面-单面（可能1-2轮）-录用 实习转正（名额很少，有机会实习一定要好好表现） 应届生的内推可能性企业随便跑去一个学校开个宣讲会，简历都能收到成百上千份，还不包括网申的，怎么会愁选不到合适的人？ 之前听某大厂HR说招聘会一下午收到上千份简历，他们人少带不走，只从中选出几百份985的简历带走了 所以对于大厂而言，应届生是根本不会缺的，很多根本没有也不需要对外提供内推机会 就算真的有内推机会，内推应届生又不可能是经理及以上级别，没多少奖金，换位思考内推者图什么？ 大家对于“内推”信息一定要谨慎，千万不要因为找工作迫切的心情而失去理性判断 常见内推骗局 收费提供内推名额 收费人号称可以通过自己的“人脉网”帮助求职者内推，一个内推名额可以收费上千 明明该部门就这两天就能招到人，却声称整个招聘季都能提供内推名额 系列课程+内推机会 通过一个系列课程+内推机会的形式包装后收取高价，一个人有的甚至能收到上万 这类会主打教学，讲解如何通过学习获得工作技能，至于内推，只是个“机会” “机会”这个东西就比较微妙了，你怎么知道给你的这个“机会”到底推了还是没有推？ 他说给你推了，发给了某某部门的XX经理，但是人家经理觉得你的个人能力不达标，不予录用，你怎么办？ 应届生可以寻求的内推虽然上面说了，对外宣传的应届生内推大多不靠谱，收费的更是如此 但是不否认应届生确实可以通过内推获得一些不错的机会，只是这样的机会基本不是正式的offer，而是实习 应届生通过内推拿到实习机会，进而通过实习转正倒是常有发生的 从公司和实习生角度分别看待实习生内推这件事： 公司 现在的实习生实习期到了要走了或者是转正了，总要找个人续上 实习岗位也没有那么的重要（毕竟，实习生差不多就是个打杂的），不需要层层考核，即便这个实习生不行开除了也没什么损失 实习生 积累实习经验 实习表现好还有可能转正 所以“实习生内推”可以算作是很实在的内推了，其他承诺能够给应届生内推正式工作的最好留个心眼 怎么拿到实习内推 算好时间准备 一定要提前准备，在毕业前一年的4-5月了解清楚自己想去的行业和公司，选出差不多3-5个公司（不要选多了 会晕菜） 根据每个公司的不同岗位要求，学习需要的技能，针对性地修改自己的简历，尽量做到完全匹配 找到介绍人 介绍人一定要是自己相信的人，比如家人朋友等等，最好的途径是学长学姐，你们的校友关系这张感情牌一定要好好用（毕竟内推没多少钱奖金，别人不一定乐意帮你） 至于怎么找，可以问辅导员，问老师，问学生会的人，到底有谁是在你意向公司里面工作，甚至是实习过的也可以（实习过的，可能还认识里面的人，可以帮忙介绍一下里面的人） 找到过后，发短信或者加微信，或者是发邮件什么的无所谓。第一次对话一定要礼貌，先表明自己的校友身份，然后说知道师兄/师姐在XX公司，自己也很想进XX公司实习，想请教一些问题（这里要说是请教，不要直接说帮你内推） 你在了解完一些信息（招聘人数，招聘要求，工作地点等）后，你一定要表示出你的感激之情（至于怎么感激，发红包或者请吃饭都行） 在对方收了你这个红包，或者答应你请吃饭后，你再接着说帮忙看看简历，能否帮忙内推一下，经过上面的接触这个时候校友一般就不会拒绝你啦 给想要内推进大厂的应届生三条忠告 应届生内推并没有想象中的那么有用，市面上的各种推出来的内推机会只是一种敛财的手段罢了，大家要理性看待 对于应届生而言实习生内推会更为靠谱，想找这种内推需要提前准备，该打的感情牌就打不要不好意思 内推只是一种获得机会加快筛选进程的手段，想要找到一份好工作，最重要的仍然是个人能力 参考链接： 内推，真有那么神吗？","tags":[]},{"title":"如何写简历经历","date":"2021-04-10T16:00:00.000Z","path":"article/20210411.html","text":"一份简历到HR的手上一般有如下两种结果： 进垃圾桶 仔细看看，约来面试 那么，HR做出这样的判断需要多长时间呢？ 我们咨询了中国外企、垄断国企和民企的HR，他们基本表示，一天看300-400份简历是经常的，并且表示——小菜一碟 做一个简单的数学题：按照每个HR一天8小时工作不做其他事计算，平均1分钟到1分半处理一份简历——当然，没有一个HR一天只做简历处理的，所以这个时间还要缩短 1分钟就对1个读了18年书的青年做出判断，是一种负责任的态度么？ 针对应聘岗位写简历为了说明这个问题，乔布简历的创始人Rick Ma同志创造性的发明了一种理论 在阐述这个理论之前，我们先看一张图，这张图上是一只鸟。你要说出“这是一只什么鸟” 是鸭子!你用了多长时间？1秒，2秒，还是1分钟？应该是脱口而出吧。 下一个问题，为什么是鸭子呢？ 这还用问么，因为 Ta有扁扁的嘴和扁扁的脚，这都是明显鸭子的特征嘛 我们判断鸭子，就看鸭嘴和鸭掌 只要有鸭嘴鸭掌，鸭子！ 只要没有鸭嘴鸭掌，不知道是什么，反正不是鸭子。 看简历选人是同样的道理。我们管这叫 “鸭子理论” 你的简历要像那张鸭子的图片一样，迅速把你有的并且他们需要的能力（“鸭嘴”和“鸭掌”）亮出来，马上让企业知道，你就是他们要的人 面试官阅读简历的目的是根据每一段经历判断你的能力达到了什么水平 为了方便面试官迅速在我们的经历中找到他需要的能力，我们的每一段经历都要写的具体、简洁、有条理 因为不同的岗位和领域，所需要的能力是不一样的，所以我们要针对不同的应聘岗位写不同侧重点的简历 具体如果你的简历写得朦朦胧胧，面试官可能会觉得你没什么干货，所以不敢写得详细。 面试官看经历，是为了判断能力，因此经历越具体，判断就会越准确 下面介绍三个可以把经历写具体的方法： 1.动作分解把一件事情，按照它发生的顺序拆解成多个步骤，一步一步的写下来，这就是按步骤描述经历 举例用动作分解法将“他走了”3个字写成4句话： 他抬起头看了老师一眼，迟疑了一下，慢慢地站了起来 来到中间过道上，弯下腰，悄悄地朝门口走去 来到门前，将手搭在把手上向左旋转，门应声而开 走出去把门带上，头也不回地离开了 2.深入细节不够复杂不好进行动作分解的经历可以使用深入细节法，从背景、做法、结果三个角度细节描写，添加具体内容 举例有一位求职者，在大学期间曾经组织过一次游园会，虽然她只是打杂，却很积极很投入，比其他打杂的干事强很多，我们使用深入细节法把这些不同表达出来： 背景：游园会是XXX大学最有影响的传统经典活动，包括文艺巡演、围湖诗会、思源灯谜等3大部分，从每年的4月份持续到5月份。 做法：作为干事参与组织部、宣传部的工作。联系参演社团的工作人员，通知会议、做会议记录、协调排练场地。收集各社团的宣传海报，统一张贴。 结果：本届活动有大约200多名工作人员，2000多人次参加，成为最成功的一届游园会。 3.数字支撑数字可能是一种新的迷信。有数字的经历看起来更真实，数字也让我们可以横向对比，更精确的感受程度和水平。 比如上文提到的游园会经历的做法，如果把数字加进去，一切就变得更容易理解了： 联系23个参演社团的200多名工作人员，共通知了6次会议，记录会议摘要1万多字，协调排练场地34次 收集46张各社团的宣传海报，统一张贴在校内7个主要的海报栏 简洁在我们的简历里，文字要简洁，舍弃一切无助于描述客观事实的文字，排版也要简洁，每句话独立地表述一件事情，呈现一个能力 1.文字简洁描述事情、表达能力的最小单元是一个动宾结构 就像我常常在课上讲的，“我”是代词，“自行车”是名词，这两个词放在一起，没有能力 我们加上不同的动词，就会出现不同的能力，比如“我骑自行车”、“我修自行车”、“我偷自行车” 我们进一步发现，“偷自行车”和“偷汽车”所需要的能力是很不一样的，前者只是毛贼，后者就是《速度与激情》了 因此动词加上宾语，一个动宾结构就可能完整而具体地表达一个能力，简历中的文字可以多使用动宾短语 上文我们提到“动作分解”，就是要把一件事情用多个“动宾结构”表达出来，各种各样的能力就自然表达出来了 2.排版简洁排版的目的是让阅读更简单，最简单的句子就是只表达一个意思的句子 我们比较以下两段经历就明白了 上海图书馆志愿者活动 团体负责人 我在里面担任了志愿者的小组长，协助领导的工作。在工作中学会了与人相处的技能，提高了团队合作能力，尤其是在协调志愿者的过程中，锻炼了沟通的技巧。最后我们获得了“先进集体”的正好，我获得“个人优秀组织者”称号。 上海图书馆志愿者活动 团体负责人 宣传志愿活动、招募选拔组员并进行培训 处理突发事件、组织协调管理人事调动 与上图志愿者管理方协调解决志愿过程中暴露的问题 任职期间，所带团队获上图志愿“先进集体”称号，个人获“优秀组织者”称号。 条理任何一段文字内容的安排顺序，如果不符合人的思维习惯，读起来就会很吃力 对于简历中的经历而言，常用的表达顺序是“时间顺序”或“逻辑顺序” 1.时间顺序时间顺序也可以叫做流程顺序，如果是一个独立的项目，可以把先做了什么后做了什么依次写出来，如下面这段经历： 中国农业大学暑期实践团 暑期社会实践调查员 针对农民设计简单易懂的问卷，并独立走访调查 与当地政府合作，综合分析相关会议记录和政策资料 完成长达20页的报告，荣获优秀社会实践报告 2.逻辑顺序如果在一个组织中参与了多个项目，或者做了很多彼此关联度不大的事情，可以遵循一定的逻辑顺序来表述，如下面这段经历： 华东师范大学“一诺”志愿者服务队 队长 组建华东师范大学“一诺”志愿者服务队，配备5支分队，与14个社区与单位达成共建协议，吸引注册志愿者共计400余人 开展“向日葵理财计划”系列金融理财知识普及活动，培训理财志愿者70名，主编《理财行动手册》，被评为校精品活动 因成功开展“关爱智障儿童”活动，与强生、微软共同被邀请至闵行区“爱心联盟”，2008年被评为闵行区优秀志愿服务队 参考链接： “鸭子理论”：针对应聘岗位写简历 - 知乎 怎么写好经历 - 知乎","tags":[]},{"title":"HR问及职业规划相关问题如何作答","date":"2021-04-09T16:00:00.000Z","path":"article/20210410.html","text":"你的职业规划是什么？ 你为什么来这个城市工作而不回家乡？ 这篇来讲一讲遇到这一类职业规划相关问题怎样的回答才会受到HR的欣赏 你的职业规划是什么？HR想了解什么？ 了解求职者的求职动机和对自己中长期职业发展的思考 求职者的稳定性 对自己的职业定位和发展判断是否准确 面试前需要了解的内容 这个职位对面试者的关键需求是什么？主要工作内容是什么？ 职位的长期发展方向如何？类似职位的现有员工，在公司的成长经历如何？ 从此职位出发，更进一步，需要哪些方面的能力与素质？ 公司的企业文化？精神？ 自己哪些优点和特点能够和上述四个问题中的答案挂上钩？ 回答的重点要表明自己是有备而来的，有着良好的职业规划，清楚地知道未来三到五年的计划和打算，表明你是符合企业要求的稳定型员工 表达时要注意添加面试前已了解的内容，尽量让自己的优势和公司发展、职业发展相融合 你为什么来这个城市工作而不回家乡？HR想了解什么？ 考察你工作的稳定性，看你是否想把目前所在城市做为职业发展的长远目标城市，是否会长期在这里发展 是否存在还没解决的生活问题？会不会影响入职时间或者其他。比如外地实习生租房就是一个很大的难题 考察原因，你来这个城市的原因有很大的信息量。例如：男/女朋友在这个城市(因为感情结束而离职的人也不少 判定为不稳定) 回答的重点记住这五个大字 为了我自己！ 一定要体现出自己是有准备有决心有能力在外地工作生活的，请提供一些让自己看起来稳定的理由 参考回答方向1.这个城市的工作机会更多，薪资也不错，我还年轻，想给自己 几年 的时间锻炼一下2.我 一直 想来这个城市生活，大学期间就做了 很多的准备 ，打工存钱，实习等等，自己一个人生活是没有问题的3.我的亲戚/朋友在这里， 我会和他们一起住，生活上有个照顾比较方便，爸妈也放心4.我和男/女朋友恋爱多年已经 有结婚的打算 ，我们计划在这里 结婚定居 错误示例1.因为男朋友在这，我们想结束异地我就辞职过来了 点评：如果分手，是不是又要离职换地方了？如果两人还没有结婚的打算，可以换个其他的理由 2.还不确定能呆多久呢，想先来试试看在考虑要不要留下来 点评：太不稳定了，可能今天上班，明天工作的不开心就走了 3.脑袋一热，买票就来了，还没找好住的地方。先来面试吧，找到工作再说 点评：明显的没有计划，没有准备 参考链接： HR问：你的职业规划是什么？怎么回答？ 面试最容易被刷的题：你为什么来这个城市工作而不回家乡呢？","tags":[]},{"title":"大厂面试：SpringMVC面试题","date":"2021-04-04T16:00:00.000Z","path":"article/20210405.html","text":"大厂面试：SpringMVC面试题 1.MVC是什么的缩写？MVC是模型(Model)、视图(View)、控制器(Controller)的缩写 2.根据下图描述MVC模式下的请求响应流程 1） 客户端浏览器请求发送到控制器 2） 控制器调用模型层方法 3） 模型层操作数据库 4） 模型层告诉控制器操作完成 返回数据 5） 控制器调用视图层渲染页面 6） 视图层将渲染好的页面返回控制器 7） 控制器发送响应到浏览器 浏览器展示页面 3.SpringMVC基础配置内容 加载注解驱动： &lt;mvc:annotation-driven/&gt; 静态资源过滤： &lt;mvc:default-servlet-handler/&gt; 视图解析器： 1234&lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 4.web.xml文件中设置SpringMVC拦截请求时url-pattern中的内容有何含义？url-pattern中的内容是用来标识请求拦截的 / 匹配所有的请求；（不包括.jsp） /* 匹配所有的请求；（包括.jsp） 为空时所有请求都会被SpringMVC拦截 5.SpringMVC请求映射注解有哪些？ 请求映射注解 说明 类/方法 @RequestMapping 通用的请求处理 类 @GetMapping 处理 HTTP GET 请求 查询方法 @PostMapping 处理 HTTP POST 请求 新增修改方法 @PutMapping 处理 HTTP PUT 请求 新增修改方法 @PatchMapping 处理 HTTP PATCH 请求 新增修改方法 @DeleteMapping 处理 HTTP DELETE 请求 删除方法","tags":[]},{"title":"大厂面试：MyBatis面试题","date":"2021-04-03T16:00:00.000Z","path":"article/20210404.html","text":"大厂面试：MyBatis面试题 1.ORM是什么的缩写？ORM是对象(Object)、关系(Relational)、映射(Mapping)的缩写 2.ORM有什么作用？ORM会把对SQL的操作转换为对象的操作，从而让程序员使用起来更加方便和易于接受 3.Hibernate与MyBatis的区别？ Hibernate 全自动化ORM框架，数据库移植性好，基础业务几乎不需要写SQL 易学难精，上手简单但熟练使用需要阅读大量文档，框架结构复杂 MyBatis 半自动化ORM框架，数据库移植性一般，基础业务仍需写SQL，但可以通过基础Mapper来简化 易学易用，上手简单，结构精简清晰，易深入学习 4.要想使用MyBatis需要导入的包有哪些？ mysql-connector-java：MySQL驱动包 mybatis：MyBatis基础包 5.MyBatis配置用到哪些标签？ configuration 标签对应 Configuration 类，负责 MyBatis 架构中的配置部分 environment 标签对应 Environment 类，是环境变量，必须有唯一的 id transactionManager 标签对应 JdbcTransactionFactory 类，表示事务工厂，当 MyBatis 需要新建事务的时候，会通过它来新建 dataSource 标签对应 PooledDataSource 类，表示数据源，通过其构造参数，我们传入了数据库 url，数据库用户和密码等配置 6.mapper文件中常用标签 新增数据： 删除数据： 修改数据： 查询数据： 7.mapper文件中的SQL语句使用什么符号引用传入参数？mapper文件中的SQL语句使用 #{} 符号引用传入参数 8.写通过id查询表中单条数据的Dao层代码java代码： xml代码： 9.写查询表中所有数据的Dao层代码java代码： xml代码：","tags":[]},{"title":"大厂面试：Spring面试题","date":"2021-04-02T16:00:00.000Z","path":"article/20210403.html","text":"大厂面试：Spring面试题 1.Spring体系结构由哪几部分构成？ Data Access/Integration：持久层 Web：表现层 Test：测试层 中间的两部分 是Spring框架的核心功能 2.Spring有哪些核心功能？ 控制反转(IOC) 依赖注入(DI) 面向切面编程(AOP) 3.什么是控制反转(IOC)？IOC是一种设计模式，将实例化对象的控制权由手动的new变成了Spring框架通过反射机制实例化，并将对象的实例存入在容器种进行管理 什么是依赖注入(DI)？ DI是指对象中其余对象的引用通过Spring框架直接注入 5.什么是面向切面编程(AOP)？AOP指的就是通过预编译和运行期动态代理的方式实现在程序运行某个方法的时候，不修改原始执行代码逻辑，由程序动态地执行某些额外的功能，对原有的方法做增强 6.要想使用Spring需要导入的基础包有哪些？ spring-core：Core模块主要包含Spring框架基本的核心工具类，Spring的其他组件要都要使用到这个包里的类，Core模块是其他组件的基本核心 spring-beans：包含访问配置文件、创建和管理bean以及进行IOC/DI操作相关的所有类 spring-context：Spring的上下文即IOC容器，通过上下文可以获得容器中的Bean spring-expression：EL表达式语言用于在运行时查询和操纵对象 7.分析ApplicationContext执行过程1）ApplicationContext加载项目中的Spring配置 2）调用refresh方法刷新容器（bean的实例化就在这个方法中） 3）context.getBean()方法是通过配置文件中声明的bean标签id属性获取容器内的实例 8.IOC常用注解 @Component：一般用于通用组件类上使用的注解 @Service：一般用于业务逻辑层上使用的注解 @Controller：一般用于流程控制层上使用的注解 @Repository：一般用于数据持久层上使用的注解 9.DI常用注解 @Autowired：自动按照类型注入 @Qualifier：在按照类型注入的基础之上再按照Bean的id注入 @Resource：默认按照id注入找不到再按照类型注入 10.AOP常用注解 @Aspect：表明某个类为切面类 @Pointcut：声明一个切入点，表明哪些类的哪些方法需要被增强 @Before 前置通知 @AfterReturning 后置通知 @After 最终通知 @AfterThrowing 异常通知 11.什么是代理模式？代理模式是给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用 代理模式可以分为静态代理和动态代理 动态代理常用的有基于接口和基于子类两种方式","tags":[]},{"title":"for forEach 循环及Lambda表达式使用","date":"2021-03-29T16:00:00.000Z","path":"article/20210330.html","text":"for循环for循环语句是代码中常用的循环代码，相对于其他的循环语句更为简单，一般代码结构如下： 123for(初始化; 判别式; 更新) &#123; 代码语句&#125; 执行流程: 首先进行初始化 初始化之后执行判别式，如果判别式结果为真，会执行代码块内容，之后执行更新语句 更新后再次执行判别式，如果判别式结果为真，会执行代码块内容，之后执行更新语句 更新后再次执行判别式，直到判别式结果为假结束循环 以打印List中数据为例 12345678910111213141516171819public class Test &#123; private static void printFor(List&lt;String&gt; list) &#123; System.out.println(\"-----for循环开始-----\"); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; System.out.println(\"-----for循环结束-----\"); &#125; public static void main(String[] args) &#123; // 新建List 输入三个值 List&lt;String&gt; list = new ArrayList(); list.add(\"第1个值\"); list.add(\"第2个值\"); list.add(\"第3个值\"); // for循环打印List中的值 printFor(list); &#125;&#125; 执行结果： forEach循环forEach循环是java5的新特征之一，在遍历数组、集合方面，forEach为开发人员提供了极大的方便 其代码结构如下： 123for(元素类型 元素变量 : 遍历对象)&#123; 代码语句&#125; 遍历对象通常为数组或者集合 元素类型为数组或者集合中所存数据的类型 元素变量为每个元素的变量名 执行流程是循环遍历遍历对象，用元素变量获取遍历对象中的各个元素执行代码语句 以打印List中数据为例 12345678910111213141516171819public class Test &#123; private static void printForEach(List&lt;String&gt; list) &#123; System.out.println(\"-----forEach开始-----\"); for (String str : list) &#123; System.out.println(str); &#125; System.out.println(\"-----forEach结束-----\"); &#125; public static void main(String[] args) &#123; // 新建List 输入三个值 List&lt;String&gt; list = new ArrayList(); list.add(\"第1个值\"); list.add(\"第2个值\"); list.add(\"第3个值\"); // forEach打印List中的值 printForEach(list); &#125;&#125; 执行结果： forEach循环 + Lambda表达式Lambda表达式是java8的新特征之一，它使我们可以更方便地操作集合 forEach循环整合Lambda表达式后代码结构如下： 1遍历对象.forEach(元素变量 -&gt; 代码语句); 遍历对象通常为数组或者集合 元素变量为每个元素的变量名 执行流程是循环遍历遍历对象，用元素变量获取遍历对象中的各个元素执行代码语句 以打印List中数据为例 1234567891011121314151617public class Test &#123; private static void printForEachLambda(List&lt;String&gt; list) &#123; System.out.println(\"-----forEach+Lambda开始-----\"); list.forEach(str -&gt; System.out.println(str)); System.out.println(\"-----forEach+Lambda结束-----\"); &#125; public static void main(String[] args) &#123; // 新建List 输入三个值 List&lt;String&gt; list = new ArrayList(); list.add(\"第1个值\"); list.add(\"第2个值\"); list.add(\"第3个值\"); // forEach+Lambda打印List中的值 printForEachLambda(list); &#125;&#125; 执行结果： 本文源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Test &#123; /** * for循环打印List中的值 * * @param list */ private static void printFor(List&lt;String&gt; list) &#123; System.out.println(\"-----for循环开始-----\"); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; System.out.println(\"-----for循环结束-----\"); &#125; /** * forEach打印List中的值 * * @param list */ private static void printForEach(List&lt;String&gt; list) &#123; System.out.println(\"-----forEach开始-----\"); for (String str : list) &#123; System.out.println(str); &#125; System.out.println(\"-----forEach结束-----\"); &#125; /** * forEach+Lambda打印List中的值 * * @param list */ private static void printForEachLambda(List&lt;String&gt; list) &#123; System.out.println(\"-----forEach+Lambda开始-----\"); list.forEach(str -&gt; System.out.println(str)); System.out.println(\"-----forEach+Lambda结束-----\"); &#125; public static void main(String[] args) &#123; // 新建List 输入三个值 List&lt;String&gt; list = new ArrayList(); list.add(\"第1个值\"); list.add(\"第2个值\"); list.add(\"第3个值\"); // for循环打印List中的值 printFor(list); // forEach打印List中的值 printForEach(list); // forEach+Lambda打印List中的值 printForEachLambda(list); &#125;&#125;","tags":[]},{"title":"if判断和三目运算符","date":"2021-03-22T16:00:00.000Z","path":"article/20210323.html","text":"if判断if条件语句是代码中常用的判断条件的代码，相对于其他的条件判断语句更为简单，一般代码结构如下： 12345if (判别式) &#123; 代码块1&#125; else &#123; 代码块2&#125; 如果判别式结果为真，会执行代码块1，若为假执行代码块2 以取两数中最大值为例 123456789101112131415public class Test &#123; public static Integer getMaxIf(int a, int b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125; &#125; public static void main(String[] args) &#123; int a = 1; int b = 2; System.out.println(\"if 返回最大值\" + getMaxIf(a, b)); &#125;&#125; 三目运算符还有一种比if条件语句更为简单的语句就是三目运算符 但只有if语句中代码块只有一行语句时我们会使用三目运算符来代替if语句 其代码结构如下： 1判别式 ? 代码块1 : 代码块2; 如果判别式结果为真，会执行代码块1，若为假执行代码块2 以取两数中最大值为例 1234567891011121314151617/** * @ClassName Test * @Description * @Author GengRui * @Date 2021/3/23 11:58 */public class Test &#123; public static Integer getMaxTernary(int a, int b) &#123; return a &gt; b ? a : b; &#125; public static void main(String[] args) &#123; int a = 1; int b = 2; System.out.println(\"三目运算符 返回最大值\" + getMaxTernary(a, b)); &#125;&#125; if判断和三目运算符对比 比较发现三目表达式要简洁得多 但如果判断后要执行的代码块偏复杂还是用if判断比较好 本文源码1234567891011121314151617181920212223242526272829303132333435public class Test &#123; /** * if 返回最大值 * * @param a * @param b * @return 最大值 */ public static Integer getMaxIf(int a, int b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125; &#125; /** * 三目运算符 返回最大值 * * @param a * @param b * @return */ public static Integer getMaxTernary(int a, int b) &#123; return a &gt; b ? a : b; &#125; public static void main(String[] args) &#123; int a = 1; int b = 2; System.out.println(\"if 返回最大值\" + getMaxIf(a, b)); System.out.println(\"三目运算符 返回最大值\" + getMaxTernary(a, b)); &#125;&#125;","tags":[]},{"title":"SpringMVC请求映射注解","date":"2021-03-19T16:00:00.000Z","path":"article/20210320.html","text":"Spring MVC 提供了以下这些请求映射注解： 请求映射注解 说明 类/方法 @RequestMapping 通用的请求处理 类 @GetMapping 处理 HTTP GET 请求 查询方法 @PostMapping 处理 HTTP POST 请求 新增修改方法 @PutMapping 处理 HTTP PUT 请求 新增修改方法 @PatchMapping 处理 HTTP PATCH 请求 新增修改方法 @DeleteMapping 处理 HTTP DELETE 请求 删除方法 除了 @RequestMapping ，其它类型的注解本质上是 @RequestMapping 的简写形式 比如 @GetMapping 其实可以写为@RequestMapping( method = RequestMethod.GET) 建议在类级别上只使用 @RequestMapping ，用于指定基本路径 而在每个方法上根据方法功能不同使用更具体的请求映射注解","tags":[]},{"title":"SpringMVC工程搭建","date":"2021-03-18T16:00:00.000Z","path":"article/20210319.html","text":"创建项目 使用IDEA创建Maven工程 IDEA配置Maven 我们新建Maven项目名为“springmvc-demo“，设置好Maven版本、配置文件以及Maven仓库 由于SpringMVC在 MVC设计模式 中是作为控制器负责前后端代码的连接，我们首先需要添加WEB文件夹用来存放前端代码 添加web右键我们的项目名 -&gt; 选择“Add Framework Support” 选择WebApplication 核实版本号 核实是否会自动创建web.xml 添加好后会出现如下文件夹 搭建配置SpringMVC引入依赖 spring-webmvc：基于Spring功能之上添加的Web框架 javax.servlet-api：提供编写servlet时要用到的HttpServletRequest和HttpServletResponse对象 junit：单元测试框架 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 测试包 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 刷新maven等待自动下载 libraries中有了所有导入的包表示依赖引入完成 配置静态资源导出1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Spring核心配置文件SpringMVC是Spring体系的一部分，我们需要添加Spring框架的核心配置文件 文件路径为\\src\\main\\resources文件名为applicationContext.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd \"&gt; &lt;!-- bean definitions here --&gt;&lt;/beans&gt; 添加SpringMVC配置内容我们直接在Spring的配置文件中配置MVC即可 加载注解驱动 在spring中一般采用 SpringMVC请求映射注解 来完成映射关系 要想使请求映射注解生效必须注册DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter实例 annotation-driven配置就是帮助我们自动完成上述两个实例的注入 12&lt;!-- 1加载注解驱动 --&gt;&lt;mvc:annotation-driven/&gt; 静态资源过滤 目的是让SpringMVC不处理静态资源 例如：.css .js .html .mp3 …… 12&lt;!-- 2静态资源过滤 --&gt;&lt;mvc:default-servlet-handler/&gt; 视图解析器 确定视图文件位置，自动给视图文件添加前后缀 12345&lt;!-- 3视图解析器 --&gt;&lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 编写代码测试编写Controller层controller包下新建HelloController类 1234567891011121314package controller;@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello(Model model)&#123; // Model 封装数据 model.addAttribute(\"msg\",\"HELLO MY FIRST SPRING MVC PROJECT\"); // 返回的字符串就是视图的名字 会被视图解析器处理 return \"hello\"; &#125;&#125; 配置Spring容器自动扫描包将Controller对象放进Spring容器 Spring核心配置文件：applicationContext.xml 12&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;&lt;context:component-scan base-package=\"controller\"/&gt; 编写jspWEB-INF包下新建jsp包，jsp包下新建hello.jsp文件 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 编写web.xml 配置前端控制器 12345&lt;!-- 配置前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt; 配置初始化参数 在服务器启动时 加载spring的核心配置文件applicationContext.xml 配置初始化参数的代码写在前端控制器内 12345&lt;!-- 配置初始化参数 --&gt;&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/init-param&gt; 设置启动级别 设置启动级别的代码也写在前端控制器内，数字越小启动越早 12&lt;!-- 设置启动级别 --&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 设置SpringMVC拦截请求 12345&lt;!-- 设置SpringMVC拦截请求 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 用url-pattern中的内容来标识请求拦截： / 匹配所有的请求；（不包括.jsp） /* 匹配所有的请求；（包括.jsp） 为空时所有请求都会被SpringMVC拦截 配置中文乱码过滤器 12345678910111213&lt;!-- 乱码过滤 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 运行web项目打包file -&gt; Project Structure 打开项目构建管理框 首先删除默认打好的包 添加WAR包 点击 + 号 -&gt; Web Application:Exploded -&gt; From Modules… 会弹出如下框依次点击“OK”即可 配置TomCat点击 Add Configuration… 进入运行配置框 点击 + 号 -&gt; Tomcat Server -&gt; Local 点击 Configure 选择我们自己的TomCat 点击 Deployment -&gt; + 号 -&gt; Artifact 会自动加入我们刚才打好的包 Application context 改成/是为了方便在浏览器输入路径 如果你写的是/test，那么在浏览器访问首页的时候需要输入的就是：http://localhost:8080/test 运行TomCat点击绿色的小三角运行TomCat，出现如下内容表示运行成功 在浏览器输入 http://localhost:8080/hello 可以看到页面打印出了我们设置好的值 本文源码GengRui01/springmvc-demo","tags":[]},{"title":"MyBatis操作数据库","date":"2021-03-13T16:00:00.000Z","path":"article/20210314.html","text":"在MyBatis工程搭建 中我们主要讲解的是 MyBatis 如何连接数据库，具体执行 SQL 语句使用的是 JDBC 方式 在MyBatis实现Mapper配置并查询数据 中我们主要讲解的是如何使用MyBatis完成查询数据的操作 相比较查询而言，增加修改删除数据会简单一些，本章节我们会一起学习如何操作数据库 创建项目使用IDEA创建Maven工程 IDEA配置Maven 我们新建Maven项目名为“mybatis-operate-database“，设置好Maven版本、配置文件以及Maven仓库 准备数据源因为MyBatis是一个持久层框架，所以我们在使用之前需要执行如下SQL语句准备好数据源 12345678910111213141516171819202122# 删除mybatis_demo数据库drop database if exists mybatis_demo;# 创建mybatis_demo数据库create database mybatis_demo;# 使用mybatis_demo数据库use mybatis_demo;# 创建account表Proxy Patterncreate table user ( id int auto_increment primary key, username varchar(20), age int, score int);# 新增数据insert into user (id, username, age, score) values(1,'peter', 18, 100), (2,'pedro', 24, 200),(3,'jerry', 28, 500), (4,'mike', 12, 300),(5,'tom', 27, 1000); select单条数据要想使用MyBatis首先需要导入MySQL驱动包、MyBatis框架基础包并且添加MyBatis核心配置文件 首先复习下上个章节的内容 代码实现在entity包下创建User实体类：User.java 12345678910package entity;public class User &#123; private Integer id; private String username; private Integer age; private Integer score; // 省略getter&amp;setter方法 // 省略toString方法&#125; 在dao包下创建User模块Dao层：UserDao.java 1234567891011package dao;public interface UserDao &#123; /** * 通过用户id查询用户信息 * * @param id * @return */ User selectUserById(Integer id);&#125; 在mybatis-config.xml配置文件中添加上对应的mapper配置 1234&lt;!-- mapper配置 --&gt;&lt;mappers&gt; &lt;mapper class=\"dao.UserDao\"/&gt;&lt;/mappers&gt; 在resources文件夹下新建dao包，并在其下新建User模块Dao层配置文件：UserDao.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"dao.UserDao\"&gt; &lt;select id=\"selectUserById\" resultType=\"entity.User\"&gt; SELEspring-aopCT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 新建User模块测试类：UserTest.java 123456789101112131415161718@SuppressWarnings(&#123;\"Duplicates\"&#125;)public class UserTest &#123; public static void main(String[] args) throws IOException, SQLException &#123; // 读取配置文件 InputStream configuration = Resources.getResourceAsStream(\"mybatis-config.xml\"); // 得到 SqlSessionFactory 核心类 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); // 开始一个 sql 会话 SqlSession session = sqlSessionFactory.openSession(); // 得到 Dao UserDao dao = session.getMapper(UserDao.class); // 调用通过用户id查询用户信息的方法 User user = dao.selectUserById(1); System.out.println(user); // 关闭会话 session.close(); &#125;&#125; 执行结果 表示dao已经通过注解的方式搭建好了Java方法和SQL语句之间的桥梁，并且查询出了所需要的一条数据 select多条数据代码实现但是在实际使用时我们常常需要一次性查询多条数据，例如：SELECT * FROM user User模块Dao层配置文件：UserDao.xml 123&lt;select id=\"selectUserList\" resultType=\"entity.User\"&gt; SELECT * FROM user&lt;/select&gt; 这时要用到List集合装对象来完成多条数据的查询工作，User模块Dao层：UserDao.java 123456/** * 查询所有用户信息 * * @return */List&lt;User&gt; selectUserList(); User模块测试类：UserTest.java 123// 调用查询所有用户信息的方法List&lt;User&gt; userList = dao.selectUserList();userList.forEach(u -&gt; System.out.println(u)); TIPS: 对于userList.forEach(u -&gt; System.out.println(u));不理解的需要复习一下for forEach 循环及Lambda表达式使用 执行结果 表示dao已经查询出了所有用户信息存到了List里 insert数据代码实现User模块Dao层：UserDao.java 1234567/** * 新增用户信息 * * @param user * @return */int insertUser(User user); User模块Dao层配置文件：UserDao.xml 123&lt;insert id=\"insertUser\" parameterType=\"entity.User\"&gt; INSERT INTO user VALUES (#&#123;id&#125;,#&#123;username&#125;,#&#123;age&#125;,#&#123;score&#125;)&lt;/insert&gt; User模块测试类：UserTest.java 1234567891011121314// 调用查询所有用户信息的方法List&lt;User&gt; userListBefore = dao.selectUserList();userListBefore.forEach(u -&gt; System.out.println(u));// 创建一个要新增的对象并赋值User insertUser = new User();insertUser.setId(6);insertUser.setUsername(\"anne\");insertUser.setAge(18);insertUser.setScore(600);// 调用新增用户信息的方法int count = dao.insertUser(insertUser);// 调用查询所有用户信息的方法List&lt;User&gt; userListAfter = dao.selectUserList();userListAfter.forEach(u -&gt; System.out.println(u)); 执行结果 新增前后表中数据多了一条表示新增成功 查看数据库发现并没有新增成功 因为MyBatis把事务抽象到了TransactionManager中，而事务默认开启，所以我们只需要使用sqlSession.commit()和rollback()方法，因为在sqlSession中，实际上调用的是transactionManager来完成的具体的事务提交和回滚操作 我们在测试类代码最后加上session的提交 12// 提交sessionsession.commit(); 执行后刷新数据库发现新增了一条id为6的用户信息 update数据代码实现User模块Dao层：UserDao.java 1234567/** * 修改用户信息 * * @param user * @return */int updateUserById(User user); User模块Dao层配置文件：UserDao.xml 1234567&lt;update id=\"updateUserById\" parameterType=\"entity.User\"&gt; UPDATE user SET age = #&#123;age&#125;, username = #&#123;username&#125;, score = #&#123;score&#125; WHERE id = #&#123;id&#125;&lt;/update&gt; User模块测试类：UserTest.java 12345678910// 调用通过用户id查询用户信息的方法User userBefore = dao.selectUserById(6);System.out.println(userBefore);// 把成绩改为900userBefore.setScore(900);// 调用修改用户信息的方法dao.updateUserById(userBefore);// 调用通过用户id查询用户信息的方法User userAfter = dao.selectUserById(6);System.out.println(userAfter); 执行结果控制台打印结果如下图所示 数据库执行前后结果如下图所示 delete数据代码实现User模块Dao层：UserDao.java 1234567/** * 删除用户信息 * * @param id * @return */int deleteUserById(Integer id); User模块Dao层配置文件：UserDao.xml 123&lt;delete id=\"deleteUserById\"&gt; DELETE FROM user WHERE id = #&#123;id&#125;&lt;/delete&gt; User模块测试类：UserTest.java 12345678// 调用查询所有用户信息的方法List&lt;User&gt; userListBefore = dao.selectUserList();userListBefore.forEach(u -&gt; System.out.println(u));// 调用删除用户信息的方法int count = dao.deleteUserById(6);// 调用查询所有用户信息的方法List&lt;User&gt; userListAfter = dao.selectUserList();userListAfter.forEach(u -&gt; System.out.println(u)); 执行结果控制台打印结果如下图所示 数据库执行前后结果如下图所示 本文源码GengRui01/mybatis-operate-database","tags":[]},{"title":"MyBatis实现Mapper配置并查询数据","date":"2021-03-12T16:00:00.000Z","path":"article/20210313.html","text":"什么是Mapper在MyBatis工程搭建 中我们主要讲解的是 MyBatis 如何连接数据库，具体执行 SQL 语句使用的是 JDBC 方式 但在实际应用中是不会选择 JDBC 来执行 SQL 的，MyBatis 提供了 Mapper 作为 Java 方法和 SQL 语句之间的桥梁，来帮助我们更好地去使用 SQL Java 接口方法与 SQL 语句以及 mapper 之间的关系如下图所示： 我们新建Maven项目名为“mybatis-mapper“，设置好Maven版本、配置文件以及Maven仓库 以查询User数据为例感受Mapper引入后和JDBC执行SQL有什么区别 准备数据源因为MyBatis是一个持久层框架，所以我们在使用之前需要执行如下SQL语句备好数据源 12345678910111213141516171819202122# 删除mybatis_demo数据库drop database if exists mybatis_demo;# 创建mybatis_demo数据库create database mybatis_demo;# 使用mybatis_demo数据库use mybatis_demo;# 创建account表create table user ( id int auto_increment primary key, username varchar(20), age int, score int);# 新增数据insert into user (id, username, age, score) values(1,'peter', 18, 100), (2,'pedro', 24, 200),(3,'jerry', 28, 500), (4,'mike', 12, 300),(5,'tom', 27, 1000); 我们以查询User数据为例感受Mapper引入后和JDBC执行SQL有什么区别 MyBatis 提供了注解和XML两种方式来连接Java方法和SQL语句，首先学习注解方式使用Mapper 注解方式使用Mapper代码实现要想使用MyBatis首先需要导入MySQL驱动包、MyBatis框架基础包并且添加MyBatis核心配置文件 在mybatis-config.xml配置文件中添加上对应的mapper配置 1234&lt;!-- mapper配置 --&gt;&lt;mappers&gt; &lt;mapper class=\"mapper.UserMapper\"/&gt;&lt;/mappers&gt; 新建mapper包，并在其下新建UserMapper.java类 User模块Mapper层：UserMapper.java 1234567891011package mapper;public interface UserMapper &#123; /** * 通过用户id查询用户名称 * * @param id 用户id * @return 用户名称 */ String selectUsernameById(Integer id);&#125; 有了方法定义后，我们再通过注解为该方法添加上对应的SQL语句 1@Select(\"SELECT username FROM user WHERE id = #&#123;id&#125;\") User模块测试类：UserTest.java 123456789101112131415161718@SuppressWarnings(&#123;\"Duplicates\"&#125;)public class UserTest &#123; public static void main(String[] args) throws IOException, SQLException &#123; // 读取配置文件 InputStream configuration = Resources.getResourceAsStream(\"mybatis-config.xml\"); // 得到 SqlSessionFactory 核心类 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); // 开始一个 sql 会话 SqlSession session = sqlSessionFactory.openSession(); // 得到 mapper UserMapper mapper = session.getMapper(UserMapper.class); // 调用注解的SQL String username = mapper.selectUsernameById(1); System.out.println(\"username: \" + username); // 关闭会话 session.close(); &#125;&#125; 测试结果测试结果如下图所示： 表示mapper已经通过注解的方式搭建好了Java方法和SQL语句之间的桥梁，并且查询出了所需要的数据 XML方式使用MapperXML方式是更加强大的一种使用方式，虽然它没有注解那么方便，但是功能更强、更易维护，是 MyBatis 官方推荐的一种方式 代码实现因为我们在mybatis-config.xml配置文件中已经添加过了mapper配置，所以说不需要在配置文件中添加额外的配置 在 UserMapper 接口中，我们再新增一个方法selectUserAgeById，该方法的作用是通过用户id查询用户年龄 User模块Mapper层：UserMapper.java 1234567/** * 通过用户id查询用户年龄 * * @param id 用户id * @return 用户年龄 */Integer selectUserAgeById(Integer id); 这次使用XML的方式添加SQL语句，首先在资源文件夹下新建mapper包，并在其下新建名为UserMapper的XML文件 User模块Mapper层配置文件：UserMapper.xml 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"mapper.UserMapper\"&gt;&lt;/mapper&gt; namespace命名空间是每一个mapper的唯一标识，也是XML文件和Java接口类连接的标识 有了XML文件后，我们使用&lt;select&gt;&lt;/select&gt;标签给查询年龄的方法添加上对应的SQL语句 123&lt;select id=\"selectUserAgeById\" resultType=\"java.lang.Integer\"&gt; SELECT age FROM user WHERE id = #&#123;id&#125;&lt;/select&gt; select 标签中有两个必填属性： id：对应接口的方法名，即 selectUserAgeById，通过它 MyBatis 才能将二者对应起来 resultType：对应 SQL 语句的返回类型，与接口方法的返回值相同，有时会用到resultMap 测试类添加代码调用XML的SQL User模块测试类：UserTest.java 123// 调用XML的SQLInteger age = mapper.selectUserAgeById(1);System.out.println(\"age: \" + age); 测试结果测试结果如下图所示： 表示mapper已经通过XML的方式搭建好了Java方法和SQL语句之间的桥梁，并且查询出了所需要的数据 select-resultType代码实现在UserMapper.xml文件中，我们新增 selectUserById 标签，该 select 标签的作用是：通过id查询用户 123&lt;select id=\"selectUserById\" resultType=\"\"&gt; SELECT * FROM user WHERE id = #&#123;id&#125;&lt;/select&gt; 上面的内容返回的是所有字段值，我们需要自己创建实体类来存储查出来的值 在entity包下创建User实体类：User.java 12345678910package entity;public class User &#123; private Integer id; private String username; private Integer age; private Integer score; // 省略getter&amp;setter方法 // 省略toString方法&#125; 把UserMapper.xml文件中selectUserById标签的返回类型改为上面创建的实体类 1resultType=\"entity.User\" User模块Mapper层：UserMapper.java 1234567/** * 通过用户id查询用户信息 * * @param id * @return */User selectUserById(Integer id); User模块测试类：UserTest.java 123// 调用通过用户id查询用户信息的方法User user = mapper.selectUserById(1);System.out.println(user); 测试结果 在上面这段select标签中，SQL语句返回的是一个复杂对象，即resultType上指定的 User select-resultMapMyBatis自动帮助我们映射数据库数据和Java对象，其实这是MyBatis在幕后帮我们创建了resultMap对象，我们也可手动定义 代码实现User模块Mapper层配置文件：UserMapper.xml 123456&lt;resultMap id=\"userMap\" type=\"entity.User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"age\" column=\"age\"/&gt; &lt;result property=\"score\" column=\"score\"/&gt;&lt;/resultMap&gt; 上标签中有和两个子标签 其中标签是主键，其它字段均使用 result 标签来映射 标签有property和column两个属性 其中 property 是 Java 对象中的属性名称，column 是数据表与之对应的字段名称 把UserMapper.xml文件中selectUserById标签的返回类型改为上面创建的resultMap 1resultMap=\"userMap\" 测试结果 测试结果和修改前一样，说明MyBatis确实自动帮助我们做了数据映射，但是对于复杂的对象，比如字段名和属性名不同的情况下，我们就必须自定义resultMap了 本文源码GengRui01/mybatis-mapper","tags":[]},{"title":"MyBatis工程搭建","date":"2021-03-08T16:00:00.000Z","path":"article/20210309.html","text":"创建项目使用IDEA创建Maven工程 IDEA配置Maven 我们新建Maven项目名为“mybatis-demo“，设置好Maven版本、配置文件以及Maven仓库 准备数据源因为MyBatis是一个持久层框架，所以我们在配置及使用之前需要执行如下SQL语句先准备好数据源 12345678910111213141516171819202122# 删除mybatis_demo数据库drop database if exists mybatis_demo;# 创建mybatis_demo数据库create database mybatis_demo;# 使用mybatis_demo数据库use mybatis_demo;# 创建account表create table user ( id int auto_increment primary key, username varchar(20), age int, score int);# 新增数据insert into user (id, username, age, score) values(1,'peter', 18, 100), (2,'pedro', 24, 200),(3,'jerry', 28, 500), (4,'mike', 12, 300),(5,'tom', 27, 1000); JDBC连接及操作数据库引入MySQL驱动包12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 刷新maven等待自动下载 libraries中有了导入的包表示依赖引入完成 代码实现12345678910111213141516171819202122public class JDBCDemo &#123; public static void main(String[] args) throws Exception &#123; //1.注册驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //2.获取连接 Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mybatis_demo\", \"root\", \"root\"); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from user WHERE id = ?\"); preparedStatement.setInt(1, 1); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(\"username: \" + resultSet.getString(\"username\")); System.out.println(\"age: \" + resultSet.getString(\"age\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125; 执行结果控制台打印结果如下图所示，表示我们已经成功连接数据库并查出了需要的值 步骤总结 注册驱动 获取连接 获取statement对象 执行SQL语句返回结果集 遍历结果集 关闭连接释放资源 引入MyBatis依赖maven仓库查询网址：MavenRepository mybatis：MyBatis基础包 logback-classic：日志依赖 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.3.0-alpha5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 刷新maven等待自动下载 libraries中有了所有导入的包表示依赖引入完成 编程式配置方法MyBatis官方文档中并未详细的介绍如何编程式使用MyBatis，因为编程式配置方法代码有点复杂 但是大家没必要被代码吓退，因为在实际的开发中几乎没有机会去写这段代码，一般都是通过配置文件来拿到配置然后开启会话的 我们之所以讲解编程式配置方法，是因为使用配置文件配置时屏蔽了太多的细节 为了层层递进的介绍MyBatis的基础用法，使大家熟悉MyBatis整体结构，我们需要讲解编程式配置方法 代码实现删除JDBC连接及操作数据库：JDBCDemo.java 新建编程式配置文件：StartNoXml.java 123456789101112131415161718192021222324252627282930313233343536@SuppressWarnings(&#123;\"SqlResolve\", \"SqlNoDataSourceInspection\", \"Duplicates\"&#125;)public class StartNoXml &#123; public static void main(String[] args) throws SQLException &#123; // 准备jdbc事务类 JdbcTransactionFactory jdbcTransactionFactory = new JdbcTransactionFactory(); // 配置数据源 PooledDataSource dataSource = new PooledDataSource( \"com.mysql.cj.jdbc.Driver\", \"jdbc:mysql://localhost:3306/mybatis_demo?useSSL=false\", \"root\", \"root\"); // 配置环境，向环境中指定环境id、事务和数据源 Environment environment = new Environment.Builder(\"development\") .transactionFactory(jdbcTransactionFactory) .dataSource(dataSource).build(); // 新建 MyBatis 配置类 Configuration configuration = new Configuration(environment); // 得到 SqlSessionFactory 核心类 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); // 开始一个 sql 会话 SqlSession session = sqlSessionFactory.openSession(); // 得到 sql 连接并运行 sql 语句 PreparedStatement preStatement = session .getConnection() .prepareStatement(\"SELECT * FROM user WHERE id = ?\"); preStatement.setInt(1, 1); ResultSet result = preStatement.executeQuery(); // 验证结果 while (result.next()) &#123; System.out.println(\"username: \" + result.getString(\"username\")); System.out.println(\"age: \" + result.getString(\"age\")); &#125; // 关闭会话 session.close(); &#125;&#125; 执行结果控制台打印结果如下图所示，表示我们已经成功连接数据库并查出了需要的值 步骤总结 得到 MyBatis 配置信息，即代码中的Configuration类 JdbcTransactionFactory 表示事务工厂，当 MyBatis 需要新建事务的时候，会通过它来新建 PooledDataSource 表示数据源，通过其构造参数，我们传入了数据库 url，数据库用户和密码等配置 Configuration 负责 MyBatis 架构中的配置部分，可以有多个 Environment 每个 Environment 都必须有唯一的 id，即代码中的 development 通过 Configuration 来创建 SqlSessionFactory MyBatis 是通过会话的方式来执行 SQL 的，因为我们必须拥有一个会话创建器，即会话工厂 新建 SqlSession 来执行 SQL 有了 SqlSessionFactory 后，我们就可以方便地新建会话，并通过会话来执行 SQL 了 而PreparedStatement及以下的内容，其实并不属于 MyBatis，它们是 JDBC 提供的，在实际的 MyBatis 开发中，你也不会这样去执行 SQL，在这里我们只是为了测试是否配置成功，并且展示 MyBatis 和 JDBC 的关系。 缺点分析可以看到，编程式使用 MyBatis 其实是比较复杂，需要开发人员十分熟悉 MyBatis 的 API，所以绝大多数资料都推荐配置的方式使用 MyBatis 配置文件配置MyBatis代码实现在resources文件夹下新建配置文件：mybatis-config.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 环境变量 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 事务管理器 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 数据源 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis_demo?useSSL=false\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 有了上面编程式 API 的使用经验，那么你一定可以轻松的看懂配置项： configuration 标签对应 Configuration 类 environment 标签对应 Environment 类 transactionManager 标签对应 JdbcTransactionFactory 类 dataSource 标签对应 PooledDataSource 类 启动类：StartWithXml.java 修改类名为StartWithXml 读取配置文件 1InputStream configuration = Resources.getResourceAsStream(\"mybatis-config.xml\"); 执行结果控制台打印结果如下图所示，表示我们已经成功连接数据库并查出了需要的值 步骤总结 读取配置文件，即 mybatis-config.xml 通过配置文件来创建 SqlSessionFactory 新建 SqlSession 来执行 SQL 本文源码GengRui01/mybatis-demo","tags":[]},{"title":"代理模式","date":"2021-03-05T16:00:00.000Z","path":"article/20210306.html","text":"什么是代理模式这里提到了动态代理的概念，首先解释一下代理模式，代理模式是给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用 通俗来说就是委托人将整栋楼的空房间委托给代理商管理，代理商在不改变房屋架构的基础上二次装修，打造为青年公寓出租给有租房需求的客户 空房间就是原代码，二次装修就是给源代码统一添加功能，租房动作就是对源代码的引用 代理模式的意义 中间隔离作用：在一些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起媒介作用，其特征是代理类和委托类实现相同的接口 增加功能：给代理类增加额外的功能可以用来扩展委托类的功能，这样做只需要修改代理类而不需要再修改委托类 委托类和代理类的功能 委托类实现真正的业务功能 代理类 负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等 代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务 例如将项目加入缓存、日志这些功能就可以使用代理类来完成，没必要打开已经封装好的委托类 静态代理 &amp; 动态代理代理模式可以分为静态代理和动态代理： 静态代理静态代理是由程序员创建或特定工具自动生成源代码，在程序运行之前，代理类就已经编译生成了.class文件。 静态代理的优点是可以在符合开闭原则的情况下对目标对象进行功能扩展，缺点则是开发人员需要为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改 动态代理动态代理是在程序运行时通过反射机制动态创建的，随用随加载。动态代理常用的有基于接口和基于子类两种方式 基于接口的动态代理指的是由JDK官方提供的Proxy类，要求被代理类最少实现一个接口，这种方式大大减少了开发人员的开发任务，减少了对业务接口的依赖，降低了耦合度，缺点就是注定有一个共同的父类叫Proxy，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通 基于子类的动态代理指的是由第三方提供的CGLib，CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以要求被代理类不能用final修饰，即不能是最终类","tags":[]},{"title":"SpringAOP","date":"2021-03-04T16:00:00.000Z","path":"article/20210305.html","text":"Spring的核心特性就是IOC和AOP，之前整理了SpringIOC，这篇文章就来写一下SpringAOP（Aspect Oriented Programming），即：面向切面编程 面向切面编程是指通过预编译和运行期动态代理的方式实现在不修改源代码的情况下给程序动态统一添加功能的一种技术 在学习SpringAOP之前我们需要了解什么是代理模式 文中提到的基于接口的JDK动态代理与基于子类的CGLib动态代理两种动态代理的方式都是实现SpringAOP的基础 在spring中，虽然引入了AspectJ的语法，但是他本质上使用的是动态代理的方式，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式 如果目标对象有接口，优先使用JDK 动态代理，如果目标对象没有接口，则使用CGLib动态代理 简单转账功能我们新建Maven项目名为“spring-aop“，设置好Maven版本、配置文件以及Maven仓库 准备数据12345678910111213141516171819# 删除spring_aop数据库drop database if exists spring_aop;# 创建spring_aop数据库create database spring_aop;# 使用spring_aop数据库use spring_aop;# 创建account表create table account ( id int(11) auto_increment primary key, accountNum varchar(20) default NULL, money int(8) default 0);# 新增数据insert into account (accountNum, money) values(\"622200001\",1000),(\"622200002\",1000); 导包 导入Spring基础包 导入操作数据库、连接数据库、测试需要的包 1234567891011121314151617181920212223242526272829303132&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 核心配置文件 配置自动扫包 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd \"&gt; &lt;!-- bean definitions here --&gt; &lt;context:component-scan base-package=\"dao\"/&gt; &lt;context:component-scan base-package=\"services\"/&gt; &lt;context:component-scan base-package=\"utils\"/&gt;&lt;/beans&gt; 配置数据源 12345678910&lt;!--配置QueryRunner--&gt;&lt;bean id=\"queryRunner\" class=\"org.apache.commons.dbutils.QueryRunner\" scope=\"prototype\"/&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!--连接数据库的必备信息--&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring_aop\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 代码编写数据库连接工具类：ConnectionUtils.java 12345678910111213141516171819202122232425262728293031323334353637package utils;@Componentpublic class ConnectionUtils &#123; private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;(); @Autowired private ComboPooledDataSource dataSource; /** * 获得当前线程绑定的连接 * * @return */ public Connection getThreadConnection() &#123; try &#123; // 看线程是否绑了连接 Connection conn = tl.get(); if (conn == null) &#123; // 从数据源获取一个连接 conn = dataSource.getConnection(); // 和线程局部变量 绑定 tl.set(conn); &#125; // 返回线程连接 return tl.get(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 把连接和当前线程进行解绑 */ public void remove() &#123; tl.remove(); &#125;&#125; Account模块实体类：Account.java 12345678package entity;public class Account &#123; private Integer id; private String accountNum; private Integer money; // 省略getter&amp;setter方法&#125; Account模块Dao层：AccountDao.java 123456789101112131415161718package dao;public interface AccountDao &#123; /** * 更新 * * @param account */ void updateAccount(Account account); /** * 根据编号查询账户 * * @param accountNum * @return 如果没有结果就返回null，如果结果集超过一个就抛异常，如果有唯一的一个结果就返回 */ Account findAccountByNum(String accountNum);&#125; Account模块Dao层实现类：AccountDaoImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package dao.impl;@Repository(\"accountDao\")public class AccountDaoImpl implements AccountDao &#123; // 数据库查询工具类 @Autowired private QueryRunner runner; // 数据库连接工具类 @Autowired private ConnectionUtils connectionUtils; /** * 更新 * * @param account */ public void updateAccount(Account account) &#123; try &#123; runner.update(connectionUtils.getThreadConnection(), \"update account set accountNum=?,money=? where id=?\", account.getAccountNum(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 根据编号查询账户 * * @param accountNum * @return 如果没有结果就返回null，如果结果集超过一个就抛异常，如果有唯一的一个结果就返回 */ public Account findAccountByNum(String accountNum) &#123; List&lt;Account&gt; accounts = null; try &#123; accounts = runner.query(connectionUtils.getThreadConnection(), \"select * from account where accountNum = ? \", new BeanListHandler&lt;Account&gt;(Account.class), accountNum); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; if (accounts == null || accounts.size() == 0) &#123; // 如果没有结果就返回null return null; &#125; else if (accounts.size() &gt; 1) &#123; // 如果结果集超过一个就抛异常 throw new RuntimeException(\"结果集不唯一，数据有问题\"); &#125; else &#123; // 如果有唯一的一个结果就返回 return accounts.get(0); &#125; &#125;&#125; Account模块Service层：AccountService.java 123456789101112package services;public interface AccountService &#123; /** * 转账 * * @param sourceAccount 转出账户 * @param targetAccount 转入账户 * @param money 转账金额 */ void transfer(String sourceAccount, String targetAccount, Integer money);&#125; Account模块Service层实现类：AccountServiceImpl.java 12345678910111213141516171819202122232425262728293031package services.impl;@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; /** * 转账 * * @param sourceAccount 转出账户 * @param targetAccount 转入账户 * @param money 转账金额 */ public void transfer(String sourceAccount, String targetAccount, Integer money) &#123; // 查询原始账户 Account source = accountDao.findAccountByNum(sourceAccount); // 查询目标账户 Account target = accountDao.findAccountByNum(targetAccount); // 原始账号减钱 source.setMoney(source.getMoney() - money); // 目标账号加钱 target.setMoney(target.getMoney() + money); // 更新原始账号 accountDao.updateAccount(source); // 更新目标账号 accountDao.updateAccount(target); System.out.println(\"转账完毕\"); &#125;&#125; Account模块测试类：AccountTest.java 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class AccountTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() &#123; accountService.transfer(\"622200001\", \"622200002\", 100); &#125;&#125; 执行结果 控制台打印结果 修改前数据库中值 修改后数据库中值 可以看到：两个账号的数据已经发生了改变，证明转账的动作确实已经完成 缺点分析在业务层的代码加入一行异常代码 如下图所示： 12// 造异常int i = 1 / 0; 异常代码加在了出账账户金额修改之后，入账账户金额修改之前 执行报ArithmeticException错，如下图所示： 查看数据库中数据发现出账账户money的列值由原来的900变成了800，说明存款确实减少了100 但是由于在代码执行的过程中，出现了异常，导致入账账户并没有增加100 这就出现了数据的事务问题，破坏了数据的原子性和一致性 引入代理模式解决事务实现思路介绍 创建一个工具类，目的是用于管理数据库的事务，提供事务的开启，提交，回滚等操作； 创建一个代理处理器类，目的是生成转账实现类的代理对象，对转账的业务方法提供增强，主要是在数据操作之前，和操作之后干点事； 在 Spring 的配置文件中，通过 xml 文件的标签实例化管理事务的工具类和生成代理对象的处理器类。 代码实现事务管理器：TransactionManager.java 此工具类主要作用是对数据库连接实现事务的开启，提交以及回滚 至于何时开启、提交、回滚事务，根据业务场景需要调用该类的方法即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package transaction;@Componentpublic class TransactionManager &#123; // 数据库连接工具类 @Autowired private ConnectionUtils connectionUtils; /** * 开启事务 */ public void beginTransaction() &#123; try &#123; System.out.println(\"开启事务\"); connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 提交事务 */ public void commit() &#123; try &#123; System.out.println(\"提交事务\"); connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 回滚事务 */ public void rollback() &#123; try &#123; System.out.println(\"回滚事务\"); connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 释放连接 */ public void release() &#123; try &#123; System.out.println(\"释放连接\"); connectionUtils.getThreadConnection().close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; connectionUtils.removeConnection(); &#125;&#125; 事务代理工具类：TransactionProxyUtils 此类的核心代码是getAccountService方法，该方法返回代理业务类示例 在代理对象的invoke方法内部，实现对原始被代理对象的增强 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package utils;@Componentpublic class TransactionProxyUtils &#123; //被代理的业务类接口 @Autowired private AccountService accountService; //提供事务管理的工具类 @Autowired private TransactionManager transactionManager; /** * 获取AccountService代理对象 * * @return */ public AccountService getAccountService() &#123; return (AccountService) Proxy.newProxyInstance( accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 添加事务的支持 * * @param proxy 被代理的对象实例本身 * @param method 被代理对象正在执行的方法对象 * @param args 正在访问的方法参数对象 * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // Object rtValue = null; try &#123; // 执行操作前开启事务 transactionManager.beginTransaction(); // 执行操作 rtValue = method.invoke(accountService, args); // 执行操作后提交事务 transactionManager.commit(); // 返回结果 return rtValue; &#125; catch (Exception e) &#123; // 捕捉到异常执行回滚操作 transactionManager.rollback(); throw new RuntimeException(e); &#125; finally &#123; // 最终释放连接 transactionManager.release(); &#125; &#125; &#125;); &#125;&#125; 核心配置文件：applicationContext.xml 添加事务管理bean 1&lt;context:component-scan base-package=\"transaction\"/&gt; 配置代理Service 12&lt;!--配置代理的service--&gt;&lt;bean id=\"transactionProxyAccountService\" factory-bean=\"transactionProxyUtils\" factory-method=\"getAccountService\"/&gt; Account模块测试类：AccountTest.java 将原本引入的AccountService实例改为AccountService的事务代理对象 1@Qualifier(\"transactionProxyAccountService\") 执行结果首先将数据库中两账户余额都改为1000 1update account set money = 1000; 控制台打印结果 可以看到：在转账前后由开启、提交事务，最后有释放连接 表示事务代理已经对在不改变源代码的基础上对其做了增强 修改前数据库中值 修改后数据库中值 可以看到：两个账号的数据已经发生了改变，证明转账的动作确实已经完成 再次在出账账户金额修改之后，入账账户金额修改之前添加异常代码，如下图所示 可以看到：在捕捉到异常后进行了事务的回滚 查看数据库中数据发现并没有改变 说明引入代理模式解决了事务问题，保证了数据的原子性和一致性 缺点分析 自定义代理模式代码编写过于臃肿 侵入性比较强，代码不够优雅 控制事务的实现过于繁琐 引入AOP(XML)相关概念使用Spring的AOP替代代理类。先回顾下AOP的概念 AOP是一种编程设计模式，是一种编程技术，使用AOP后通过修改配置即可实现增加或者去除某些附加功能 学习AOP中的常用术语： Join point（连接点） 所谓连接点是指那些可以被拦截到的点 在Spring中这些点指的是方法，可以看作正在访问的，或者等待访问的那些需要被增强功能的方法 Spring只支持方法类型的连接点 Pointcut（切入点） 切入点是一个规则，定义了我们要对哪些Joinpoint进行拦截 因为在一个程序中会存在很多的类，每个类又存在很多的方法，Pointcut来标记哪些方法会应用AOP对该方法做功能增强 Advice（通知） 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。也就是对方法做的增强功能。通知分为如下几类： 前置通知：在连接点之前运行的通知类型，它不会阻止流程进行到连接点，只是在到达连接点之前运行该通知内的行为 后置通知：在连接点正常完成后要运行的通知，正常的连接点逻辑执行完，会运行该通知 最终通知：无论连接点执行后的结果如何，正常还是异常，都会执行的通知 异常通知：如果连接点执行因抛出异常而退出，则执行此通知 环绕通知：环绕通知可以在方法调用之前和之后执行自定义行为 Target（目标） Target指的是代理的目标对象，更通俗的解释就是：AOP对连接点方法做增强，底层是代理模式生成连接点所在类的代理对象，那么连接点所在的类，就是被代理的类称呼为Target Aspect（切面） 切面本质是一个类，只不过是个功能类，作为整合AOP的切入点和通知。 一般来讲，需要在Spring的配置文件中配置，或者通过注解来配置 Weaving（织入） 织入是一种动作的描述，在程序运行时将增强的功能代码也就是通知，根据通知的类型（前缀后缀等…）放到对应的位置，生成代理对象 Proxy（代理） 一个类被AOP织入增强后，产生的结果就是代理类 代码实现在执行原始业务类前对方法增强也就是SpringAOP中所谓的前置通知，对原始业务类中的方法执行之后的增强行为就是后置通知 而一旦出现异常，那么所做的动作就是异常通知。本案例使用几种通知，来实现事务的控制。 删除事务代理工具类：TransactionProxyUtils.java 导入aspectjweaver包 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt;&lt;/dependency&gt; 配置文件中添加 AOP 的相关配置 在配置文件中添加aop的基础配置 1xmlns:aop=\"http://www.springframework.org/schema/aop\" 12http://www.springframework.org/schema/aophttps://www.springframework.org/schema/aop/spring-aop.xsd 在配置文件中配置aop节点 123456789101112&lt;!-- aop相关的节点配置 --&gt;&lt;aop:config&gt; &lt;!-- 切入点 表示哪些类的哪些方法在执行的时候会应用Spring配置的通知进行增强 --&gt; &lt;aop:pointcut expression=\"execution ( * services.*.*(..))\" id=\"pc\"/&gt; &lt;!-- 配置切面类的节点 作用主要就是整合通知和切入点 --&gt; &lt;aop:aspect ref=\"transactionManager\"&gt; &lt;aop:before method=\"beginTransaction\" pointcut-ref=\"pc\"/&gt; &lt;aop:after-returning method=\"commit\" pointcut-ref=\"pc\"/&gt; &lt;aop:after method=\"release\" pointcut-ref=\"pc\"/&gt; &lt;aop:after-throwing method=\"rollback\" pointcut-ref=\"pc\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 修改测试类代码 执行结果 控制台打印结果 可以看到：在转账前后由开启、提交事务，最后有释放连接 表示SpringAOP已经在不改变源代码的基础上对其做了增强 修改前数据库中值 修改后数据库中值 可以看到：两个账号的数据已经发生了改变，证明转账的动作确实已经完成 再次在出账账户金额修改之后，入账账户金额修改之前添加异常代码，如下图所示 可以看到：在捕捉到异常后进行了事务的回滚 查看数据库中数据发现并没有改变 说明SpringAOP配置的事务管理同样也解决了事务问题，保证了数据的原子性和一致性 通过在xml文件中配置SpringAOP相关配置，就可以实现对我们业务类中的方法实现了增强，无需自定义对业务类做代理实现 XML改注解(AOP)使用注解介绍 @Aspect 此注解用于表明某个类为切面类，而切面类的作用我们之前也解释过，用于整合切入点和通知 @Pointcut 此注解用于声明一个切入点，表明哪些类的哪些方法需要被增强 @Before 前置通知 在连接点之前运行的通知类型，它不会阻止流程进行到连接点，只是在到达连接点之前运行该通知内的行为 @AfterReturning 后置通知 在连接点正常完成后要运行的通知，正常的连接点逻辑执行完，会运行该通知 @After 最终通知 无论连接点执行后的结果如何，正常还是异常，都会执行的通知 @AfterThrowing 异常通知 如果连接点执行因抛出异常而退出，则执行此通知 代码实现 删除XML中的AOPXML配置并注解代理模式 12&lt;!-- 注解 开启代理模式 --&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 注释事务管理器类：TransactionManager.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package transaction;@Component@Aspectpublic class TransactionManager &#123; // 数据库连接工具类 @Autowired private ConnectionUtils connectionUtils; @Pointcut(\"execution(* services.*.*(..))\") private void transactionPointcut() &#123; &#125; /** * 开启事务 */ @Before(\"transactionPointcut()\") public void beginTransaction() &#123; try &#123; System.out.println(\"开启事务\"); connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 提交事务 */ @AfterReturning(\"transactionPointcut()\") public void commit() &#123; try &#123; System.out.println(\"提交事务\"); connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 回滚事务 */ @AfterThrowing(\"transactionPointcut()\") public void rollback() &#123; try &#123; System.out.println(\"回滚事务\"); connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 释放连接 */ @After(\"transactionPointcut()\") public void release() &#123; try &#123; System.out.println(\"释放连接\"); connectionUtils.getThreadConnection().close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; connectionUtils.removeConnection(); &#125;&#125; 执行结果 控制台打印结果 可以看到：在转账前后由开启、提交事务，最后有释放连接 表示SpringAOP已经在不改变源代码的基础上对其做了增强 修改前数据库中值 修改后数据库中值 可以看到：两个账号的数据已经发生了改变，证明转账的动作确实已经完成 再次在出账账户金额修改之后，入账账户金额修改之前添加异常代码，如下图所示 可以看到：在捕捉到异常后进行了事务的回滚 查看数据库中数据发现并没有改变 说明SpringAOP注释的事务管理类同样也解决了事务问题，保证了数据的原子性和一致性 通过注解完成SpringAOP相关配置，就可以实现对我们业务类中的方法实现了增强 总结SpringAOP的作用就是把程序中重复的代码抽取出来，在需要执行的时候，使用动态代理技术，在不修改源码的基础上，对已有方法进行增强 优势就是减少了重复代码，提高代码复用性，提高开发效率，使得代码的维护更加方便 在开发时通常将日志记录，数据库连接池的管理，系统统一的认证、权限管理等用面向切面的方式开发 本文源码GengRui01/spring-aop","tags":[]},{"title":"项目常用后端代码结构","date":"2021-03-03T16:00:00.000Z","path":"article/20210304.html","text":"常用后端代码结构项目常用后端代码结构也就是Controller+Service+Dao，如下图所示： 接下来主要讲这三层的功能划分 Controller层（流程控制层）主要负责具体的业务模块流程的控制 Service层（业务逻辑层）主要负责业务模块的逻辑应用设计 DAO层（数据操作层）主要负责与数据库进行联络的一些任务 总结这三者，通过例子来解释： Controller像是服务员，顾客点什么菜，菜上给几号桌，都是他的职责 Service是厨师，菜单上的菜全是他做的 Dao是厨房的小工，和原材料打交道的事情全是他管 为了方便后端与前端、后端与数据库的数据传输引入了一些定义类，如entity、vo、dto、po、jo等，常用的就是entity和vo vo为视图类，传递和接收前端的数据，与前端所需字段一一对应 entity为实体类，与数据库表一一对应 方法调用流程以查询操作为例数据流动方向如下图所示： Dao层去数据库查询基础数据，查到的基础数据用entity实体类存储 Service层调用Dao层方法拿取基础数据加工处理，加工好的数据用vo视图类存储 Controller层调用Service层方法拿取数据给前端","tags":[]},{"title":"Spring IOC & DI","date":"2021-03-02T16:00:00.000Z","path":"article/20210303.html","text":"什么是IOC &amp; DIIOC（Inversion of Control 控制反转）是面向对象编程中的一种设计模式 其最常见的方式叫做DI（Dependency Injection 依赖注入） 通过控制反转，将实例化对象的控制权，由手动的new变成了Spring框架通过反射机制实例化 需要使用的时候，依赖通过配置文件以及注解的方式注入到对象中 项目常用后端代码结构 如下图所示： 我们新建Maven项目名为“spring-ioc“，设置好Maven版本、配置文件以及Maven仓库 以查询User数据为例对比IOC的引入前后程序耦合性 引入IOC之前代码实现User模块实体类：User.java 12345678package entity;public class User &#123; private Integer id; private String name; private Integer gender; // 省略getter&amp;setter方法&#125; User模块视图类：UserVo.java 1234567891011121314151617package vo;public class UserVo &#123; private Integer id; private String name; private Integer gender; private String genderName; // 省略getter&amp;setter方法 public UserVo() &#123; &#125; public UserVo(User user) &#123; this.id = user.getId(); this.name = user.getName(); this.gender = user.getGender(); &#125; // 省略toString方法&#125; User模块Dao层：UserDao.java 12345package dao;public interface UserDao &#123; User getEntity(Integer id);&#125; User模块Dao层实现类：UserDaoImpl.java 123456789101112package dao.impl;public class UserDaoImpl implements UserDao &#123; public User getEntity(Integer id) &#123; // 此处应该从数据库查询值 方便起见直接返回一个固定对象 User user = new User(); user.setId(1); user.setName(\"Anne\"); user.setGender(0); return user; &#125;&#125; User模块Service层：UserService.java 12345package services;public interface UserService &#123; UserVo getVo(Integer id);&#125; User模块Service层实现类：UserServiceImpl.java 12345678910111213141516package services.impl;public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserVo getVo(Integer id) &#123; // 手动实例化Dao userDao = new UserDaoImpl(); // 执行Dao层方法 User user = userDao.getEntity(id); // 省略业务逻辑处理。。。 UserVo userVo = new UserVo(user); userVo.setGenderName(userVo.getGender() == 0 ? \"female\" : \"male\"); return userVo; &#125;&#125; TIPS: 对于userVo.getGender() == 0 ? &quot;female&quot; : &quot;male&quot;不理解的需要复习一下if判断和三目运算符 User模块Controller层：UserController.java 123456789101112package controller;public class UserController &#123; private UserService userService; public UserVo getVo(Integer id) &#123; // 手动实例化Service userService = new UserServiceImpl(); // 执行Service层方法并返回 return userService.getVo(id); &#125;&#125; User模块测试类：UserTest.java 123456789public class UserTest &#123; public static void main(String[] args) &#123; // 手动实例化Controller UserController userController = new UserController(); // 执行Controller层方法 UserVo userVo = userController.getVo(1); System.out.println(userVo); &#125;&#125; 测试结果测试结果如下图所示： 表示Dao层数据已经一层层传到Controller层并展示了出来 缺点分析1.代码耦合性太强 不利于程序的测试2. 代码也不利于扩展 解决方式：Spring的IOC完美的解决了这一点 对象的实例化由Spring框架加载实现，放到Spring容器中管理，避免了我们手动new对象 有需要用到对象实例依赖，直接向Spring容器要，让他注入即可 而一旦涉及到对象的实例修改，那么只需更改Spring加载实例化对象的地方，程序代码无需改动 从而降低耦合，提升扩展性 引入IOC(XML)代码实现要想使用SpringIOC首先需要导入Spring框架基础包并且添加Spring核心配置文件 将依赖交给Spring的beanFactory管理 123&lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\"/&gt;&lt;bean id=\"userService\" class=\"services.impl.UserServiceImpl\"/&gt;&lt;bean id=\"userController\" class=\"controller.UserController\"/&gt; User模块测试类：UserTest.java 读取配置文件刷新Spring容器 Controller由手动实例化改为从Spring容器拿取 把ApplicationContext传到Controller层继续使用 1234567891011public class UserTest &#123; public static void main(String[] args) &#123; // 读取配置文件刷新Spring容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\"); // 从Spring容器拿Controller UserController userController = (UserController) context.getBean(\"userController\"); // 执行Controller层方法，因为之后还需要用到context对象，故下传 UserVo userVo = userController.getVo(1, context); System.out.println(userVo); &#125;&#125; User模块Controller层：UserController.java Service由手动实例化改为从Spring容器拿取 把ApplicationContext传到Service层继续使用 123456789101112package controller;public class UserController &#123; private UserService userService; public UserVo getVo(Integer id, ApplicationContext context) &#123; // 从Spring容器拿Service userService = (UserService) context.getBean(\"userService\"); // 执行Service层方法，因为之后还需要用到context对象，故下传 return userService.getVo(id, context); &#125;&#125; User模块Service层实现类：UserServiceImpl.java Dao由手动实例化改为从Spring容器拿取 12345678910111213141516package services.impl;public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserVo getVo(Integer id, ApplicationContext context) &#123; // 从Spring容器拿Dao userDao = (UserDao) context.getBean(\"userDao\"); // 执行Dao层方法 User user = userDao.getEntity(id); // 省略业务逻辑处理。。。 UserVo userVo = new UserVo(user); userVo.setGenderName(userVo.getGender() == 0 ? \"female\" : \"male\"); return userVo; &#125;&#125; 测试结果测试结果如下图所示： 表示已经将所有的依赖由手动实例化改为从Spring容器拿取 缺点分析因为每一个类的实例化都需要一个bean标签，一个大型工程有很多类，配置文件的内容未免过于臃肿，维护成本高 解决方式使用注解形式实现SpringIOC XML改注解(IOC)核心配置文件修改context-component-scan标签Spring框架自定义的xml标签，通过base-package属性指明需要被自动扫描实例化的类所在位置 如下代码所示，我们在dao、services、controller下的类是需要扫描自动注入容器的 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd \"&gt; &lt;!-- bean definitions here --&gt; &lt;context:component-scan base-package=\"dao\"/&gt; &lt;context:component-scan base-package=\"services\"/&gt; &lt;context:component-scan base-package=\"controller\"/&gt;&lt;/beans&gt; 修改好后运行项目发现context.getBean()代码报错 说明不是在base-package下的所有类都会自动注入到容器，而是要搭配注解使用 常用注解介绍 @Component：一般用于通用组件类上使用的注解 @Service：一般用于业务逻辑层上使用的注解 @Controller：一般用于流程控制层上使用的注解 @Repository：一般用于数据持久层上使用的注解 依次添加注解，添加之后运行再次报错找不到bean 其实我们在添加注解后，Spring会默认给每个bean设置id，值为类名首字母改为小写 这次报错原因就是找不到名为”userService“的bean 解决办法就是在注解时设置bean的id，保证可以找到bean 测试结果测试结果如下图所示： 表示已经使用注解方式将对象放入Spring容器中 引入DI上面所有的内容都是将对象放入Spring容器中 那么放入之后的使用呢，目前都是使用ApplicationContext拿取容器中的对象 接下来讲解如何使用注解实现依赖注入 常用注解介绍@Autowired注解自动按照类型注入 会从容器中寻找符合依赖类型的实例，但是也有缺点： 因为时按照类型匹配，如果找不到匹配的实例也会抛出异常 如果容器中有多个匹配的类型也会抛出异常，需要指定引入的实例id @Qualifier注解作用是在按照类型注入的基础之上，再按照Bean的id注入。所以如果是使用了@Autowire注解自动注入，但是容器中却有多个匹配的实例，可以搭配此注解，指定需要注入的实例id @Resource注解作用是指定依赖按照id注入，还是按照类型注入。当只使用注解但是不指定注入方式的时候，默认按照id注入，找不到再按照类型注入。 代码实现User模块Controller层：UserController.java 12345678910111213package controller;@Controllerpublic class UserController &#123; // 改为自动注入 @Autowired private UserService userService; public UserVo getVo(Integer id, ApplicationContext context) &#123; // 执行Service层方法，因为之后还需要用到context对象，故下传 return userService.getVo(id, context); &#125;&#125; User模块Dao层实现类：UserDaoImpl.java 去除指定bean id，改为默认bean id（userDaoImpl） 1234567891011121314package dao.impl;// 改为默认bean id“userDaoImpl”@Repositorypublic class UserDaoImpl implements UserDao &#123; public User getEntity(Integer id) &#123; // 此处应该从数据库查询值 方便起见直接返回一个固定对象 User user = new User(); user.setId(1); user.setName(\"Anne\"); user.setGender(0); return user; &#125;&#125; User模块Service层实现类：UserServiceImpl.java 改为自动注入并指定需要注入的实例id 123456789101112131415161718package services.impl;@Service(\"userService\")public class UserServiceImpl implements UserService &#123; // 改为自动注入并指定需要注入的实例id @Autowired @Qualifier(\"userDaoImpl\") private UserDao userDao; public UserVo getVo(Integer id) &#123; // 执行Dao层方法 User user = userDao.getEntity(id); // 省略业务逻辑处理。。。 UserVo userVo = new UserVo(user); userVo.setGenderName(userVo.getGender() == 0 ? \"female\" : \"male\"); return userVo; &#125;&#125; 测试结果测试结果如下图所示： 表示 @Autowired注解已将UserService依赖自动注入UserController @Qualifier注解已指定UserDao依赖的bean id，并使用@Autowired注解自动注入UserServiceImpl 本文源码GengRui01/spring-ioc","tags":[]},{"title":"Spring工程搭建","date":"2021-03-01T16:00:00.000Z","path":"article/20210302.html","text":"创建项目 使用IDEA创建Maven工程 IDEA配置Maven 我们新建Maven项目名为“spring-demo“，设置好Maven版本、配置文件以及Maven仓库 搭建配置Spring引入依赖maven仓库查询网址：MavenRepository spring基础包： spring-core：Core模块主要包含Spring框架基本的核心工具类，Spring的其他组件要都要使用到这个包里的类，Core模块是其他组件的基本核心 spring-beans：包含访问配置文件、创建和管理bean以及进行IOC/DI操作相关的所有类 spring-context：Spring的上下文即IOC容器，通过上下文可以获得容器中的Bean spring-expression：EL表达式语言用于在运行时查询和操纵对象 1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 刷新maven等待自动下载 libraries中有了所有导入的包表示依赖引入完成 核心配置文件框架是一个半成品，已经封装好了很多功能提供我们使用，而我们如何让他们工作呢？ 这里需要创建一个配置文件和Spirng框架通信，文件路径为\\src\\main\\resources文件名为applicationContext.xml 官方给出的配置文件内容如下： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd \"&gt; &lt;!-- bean definitions here --&gt;&lt;/beans&gt; 把他复制到我们的配置文件后左上角会提示“Application context not configured for this file”，点击“Configure application context”，点击OK 编写代码测试接口类新建接口类 编写接口类 12345package services;public interface UserService &#123; public void saveUser();&#125; 实现类新建实现类 实现接口并使用快捷键添加接口方法实现 编写实现方法 123456789package services.impl;import services.UserService;public class UserServiceImpl implements UserService &#123; public void saveUser() &#123; System.out.println(\"service的save方法执行了\"); &#125;&#125; 补充配置文件将我们自定义的实现类交给Spring的容器管理 12&lt;!-- 此标签的作用是利用反射机制将UserServiceImpl类的实例交给Spring容器 --&gt;&lt;bean id=\"userService\" class=\"services.impl.UserServiceImpl\"/&gt; 测试类新建测试类 编写测试类main方法 1234567public class DemoTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\"); UserService service = (UserService) context.getBean(\"userService\"); service.saveUser(); &#125;&#125; Alt+Enter键导包 测试结果 可以看到控制台打印输出 证明确实从容器中获取到了userService实例 执行过程分析BeanFactoryBeanFactory是基础类型的IOC容器，是管理bean容器的根接口，并提供了完整的IOC服务支持 简单来说BeanFactory就是一个管理Bean的工厂，它主要负责初始化各种Bean、调用生命周期等方法 ApplicationContextApplicationContext被称为应用上下文，是BeanFactory接口的子接口，在其基础上提供了其他的附加功能，扩展了BeanFactory接口 ClassPathXmlApplicationContextClassPathXmlApplicationContext是ApplicationContext的实现类，也在其基础上加了许多附加功能 该类从类路径ClassPath中寻找指定的XML配置文件，找到并完成对象实例化工作 其构造器源码如下： 1234567891011121314151617public ClassPathXmlApplicationContext(String configLocation) throws BeansException &#123; this(new String[] &#123;configLocation&#125;, true, null);&#125;public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException &#123; super(parent); // 加载项目中的Spring配置文件 setConfigLocations(configLocations); if (refresh) &#123; // 刷新容器 refresh(); &#125;&#125; 构造器的作用： 调用setConfigLocations方法加载项目中的Spring配置文件 调用refresh方法刷新容器（bean的实例化就在这个方法中） refresh方法源码如下： 1234567891011121314151617181920212223242526272829public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. // 准备容器刷新 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 准备bean工厂对象 prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. // 加载配置文件中的所有bean标签 postProcessBeanFactory(beanFactory); ...... ...... // Instantiate all remaining (non-lazy-init) singletons. // 完成此上下文的bean工厂初始化，初始化所有剩余的单例bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. // 完成容器刷新 finishRefresh(); &#125; catch (BeansException ex) &#123; ...... &#125; finally &#123; ...... &#125; &#125;&#125; refresh方法的作用： 准备容器刷新 准备bean工厂对象 加载配置文件中的所有bean标签 完成bean工厂实例化 完成容器刷新 context.getBean()context.getBean()方法是通过配置文件中声明的bean标签id属性获取容器内的实例 本文源码GengRui01/spring-demo","tags":[]},{"title":"IDEA配置Maven","date":"2021-02-28T16:00:00.000Z","path":"article/20210301.html","text":"File-Setting打开设置页 搜索maven 修改maven home directory为maven安装路径 勾选“Override”将setting文件位置及仓库位置改为自配置 修改setting文件位置为 maven安装路径\\conf\\setting.xml 修改仓库位置为 maven安装路径\\repository","tags":[]},{"title":"使用IDEA创建Maven工程","date":"2021-02-27T16:00:00.000Z","path":"article/20210228.html","text":"打开开发工具IDEA，点击创建新项目 核实项目所使用的JDK是否是已经安装好的JDK 选择Maven工程 点击下一步 输入项目名spring-demo可以看到存储位置有自动追加spring-demo 将存储位置改为任意盘下 groupID一般是公司域名，我们可以使用com.自己的姓名全拼作为练习 版本默认即可 点击完成","tags":[]},{"title":"MyBatis简介","date":"2021-02-26T16:00:00.000Z","path":"article/20210227.html","text":"概念MyBatis 是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射 与其它ORM框架不同，MyBatis没有将Java对象与数据表关联起来，而是作为Java方法和SQL语句的桥梁，我们一般称它为半ORM框架 功能 方便地定制化SQL，操作数据库对象 使用简单的XML或注解来配置和映射原生类、接口和Java的POJO为数据库中的记录 提供强大的动态SQL功能，可以更加灵活地使用SQL语句 提供插件增强机制，可以轻松集成其它插件 Hibernate与MyBatis对比 Hibernate 全自动化ORM框架，数据库移植性好，基础业务几乎不需要写SQL 易学难精，上手简单但熟练使用需要阅读大量文档，框架结构复杂 MyBatis 半自动化ORM框架，数据库移植性一般，基础业务仍需写SQL，但可以通过基础Mapper来简化 易学易用，上手简单，结构精简清晰，易深入学习 对比结果： Hibernate适合在需求明确、业务固定的项目中使用，如OA、ERP项目 MyBatis适合在需求多变，快速迭代的项目中使用，如互联网的电商项目","tags":[]},{"title":"ORM程序技术","date":"2021-02-25T16:00:00.000Z","path":"article/20210226.html","text":"JDBC操作数据库步骤JDBC连接及操作数据库 注册驱动 获取连接 获取statement对象 执行SQL语句返回结果集 遍历结果集 关闭连接释放资源 原生JDBC连接及操作数据库有几个缺点： 某条语句执行失败时的处理逻辑非常复杂 要对其中某些业务逻辑做修改，改动代码量较大 概念ORM是对象(Object)、关系(Relational)、映射(Mapping)的缩写，是一种用于实现面向对象编程语言里不同类型系统的数据之间转换的程序技术 作用Java是一门面向对象语言，几乎所有的程序中都存在对象和关系数据库 当对象信息发生变化的时候，我们需要去改数据库中的数据 ORM会把对SQL的操作转换为对象的操作，从而让程序员使用起来更加方便和易于接受 一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段 12345678class Person&#123; Integer id; String name; Integer gender; Date birthday; ...... ......&#125; id name gender birthday 1 Anne 0 1999-01-01 2 Bob 1 1998-08-21 由于类和表之间、属性和字段之间建立起了映射关系，所以SQL对表的操作就可以转换为对象的操作 程序员从此无需编写SQL语句，由框架根据对象的变化及映射关系自动生成SQL语句，这就是ORM的作用 优势 提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 ORM提供了对数据库的映射，不用SQL直接编码，能够像操作对象一样从数据库获取数据","tags":[]},{"title":"SpringMVC简介","date":"2021-02-24T16:00:00.000Z","path":"article/20210225.html","text":"概念SpringMVC是Spring生态圈中的WEB-MVC框架 SpringMVC和Spring的关系由于Spring的概念有狭义广义两种理解方式，SpringMVC和Spring的关系可以从如下两个角度理解： 水平角度：SpringMVC是Spring生态圈中的一个功能模块，两者是包含与被包含的关系； 垂直角度：SpringMVC是建立在Spring核心功能之上的一个WEB-MVC框架，是Spring核心功能的延伸和扩展。 Struts2与SpringMVC对比 Struts2很多功能也需要借助于Spring实现，SpringMVC和Spring有直属血缘的关系，两者吻合度更高 使用SpringMVC时所需要的其他逻辑组件都经由IOC创建Spring容器管理，可根据组件特性保证其线程安全性 SpringMVC利用DI功能，能轻松地装配好各组件之间的依赖，开发者只需要关注编写自己的业务逻辑便可","tags":[]},{"title":"MVC设计模式","date":"2021-02-23T16:00:00.000Z","path":"article/20210224.html","text":"WEB应用WEB应用程序的主流开发技术有 3 种： Servlet PHP .net Servlet是基于Java语言的动态WEB开发技术，Servlet指的是J2EE中所提出来的企业级服务器开发规范。 理论上讲，每一次不同的http请求需要一个Servlet组件来响应，当请求类型比较多时，Servlet就会相应增加，也意味着每一个Servlet都可以成为进入服务器的入口。 原生Servlet构建的MVC开发模式有几个缺点： Servlet本身采用单例设计模式，生命周期由服务器维护，存在线程安全隐患的问题； 随着Servlet数量的增加，对服务器的存储空间也会产生压力； 使用Servlet响应用户请求时，每一个响应逻辑都需要开发者不厌其烦地做些重复的事情，如，解析请求包中的数据、构建响应包、设置页面跳转等等。 概念MVC是模型(Model)、视图(View)、控制器(Controller)的缩写，是一种分离显示业务逻辑、数据和界面的设计模式 组件关系 模型（Model）表示应用程序核心，是应用程序中用于处理应用程序数据逻辑的部分，通常负责在数据库中存取数据。 视图（View）用来显示数据，是应用程序中处理数据显示的部分，通常View是依据Model的数据而创建的。 控制器（Controller）用来处理用户输入并调用模型和视图来满足用户的需求，是应用程序中处理用户交互的部分，通常Controller负责从View读取数据，控制用户输入，并向Model发送数据。 请求响应流程 优势 低耦合性：MVC的视图层和业务层是分离的，如果项目的业务流程或业务规则有所更改，只需要更改MVC的Model层，不需要重新更改编译View和Controller的代码内容。 高可重用性：MVC模式允许不同类型的View访问相同的服务器端代码，多个View可以共享一个Model，它包括任何WEB浏览器(HTTP)或无线浏览器(WAP)，因为这些表示所需要改变的只有View层的实现方式，Model层和Controller层不需要做任何改变。 低生命周期成本：MVC降低了用户界面开发和维护的技术需求，从而降低了生命周期成本 快速部署：使用MVC模式可以大大缩短开发时间，允许后端开发人员只关注业务逻辑，而前端开发人员只需要关注页面的表现形式。 高可维护性：前后端分离使得WEB应用程序更易于维护和修改。","tags":[]},{"title":"Spring简介","date":"2021-02-22T16:00:00.000Z","path":"article/20210223.html","text":"为什么使用Spring？Spring官网 Spring官网首页滚动显示如下内容： Spring makes Java simple. Spring makes Java modern. Spring makes Java productive. Spring makes Java reactive. Spring makes Java cloud-ready. Spring使Java简单易用、紧跟时代、复用性强、快速响应、云就绪。 体系结构介绍 结构图阐释： Data Access/Integration：持久层 是Spring对数据持久化、事务管理的支持。SpringDataJpa就是其中的一种 Web：表现层 是Spring对表现层数据的处理部分的支持。SpirngMVC就是其中的一种 Test：测试层 是Spring对项目提供的一个完整测试环境 中间的两部分 是Spring框架的核心功能 概念Spring刚出世时，仅提供了一些核心功能模块 其中IOC&amp;DI和AOP两大两大核心模块对企业项目开发过程产生了巨大的影响 后来，Spring在核心功能的的基础之上，延伸出更多的功能模块 由这些功能模块为企业项目开发提供了较完整的、全方位的解决方案 所以Spring概念在狭义及广义角度理解不同： 狭义角度：Spring指的是Spring框架核心功能模块 广义角度：Spring是一个提供了众多功能模块的生态圈 核心功能控制反转(IOC) &amp; 依赖注入(DI)控制反转(IOC)简单理解IOC是一种设计模式，将实例化对象的控制权由手动的new变成了Spring框架通过反射机制实例化，并将对象的实例存入在容器种进行管理 依赖注入(DI)IOC是将对象实例化的动作交由了Spring框架，它的作用是降低了程序的耦合，不需要我们手动的创建对象，但是程序的耦合性还是存在 对象中肯定会有一些其余对象的引用，那么这种引用就称为对象的依赖 如果一个类中的某个属性是另一个类，该属性无需手动赋值，通过Spring的配置文件或者注解，通过Spring框架可以实现直接注入属性 IOC &amp; DI 关系未引入Spring框架B类中需要使用A类时 12345class B&#123; A a = new A(); ...... ......&#125; 引入Spring框架后，IOC容器在运行期间Spring动态地将B对象某种依赖关系（A对象）注入到B对象之中 面向切面编程(AOP)首先理解切面，切面是数学中的一个概念，和球面只有一个交点的平面称作球的切面，而接触点称作切点 在Spring中，切面编程指的就是通过预编译和运行期动态代理的方式实现在程序运行某个方法的时候，不修改原始执行代码逻辑，由程序动态地执行某些额外的功能，对原有的方法做增强，这就叫做面向切面编程，那个被监测的执行方法，称呼为切入点。 优势Spring框架以控制反转(IOC)和面向切面编程(AOP)为内核，提供了展现层(SpringMVC)、持久层(SpringJDBC)、业务层事务管理等众多的企业级应用技术，还能整合其他第三方开源框架和类库。 对于对象的实例管理更加方便，代码编写更加优雅，降低代码的耦合性，提升代码的可扩展性。","tags":[]},{"title":"SSH和SSM的区别","date":"2021-02-21T16:00:00.000Z","path":"article/20210222.html","text":"SSH &amp; SSMSSH是Spring+Struts2+Hibernate的缩写，是一种较主流的Java企业级应用框架。 SSM是Spring+SpringMVC+MyBatis的缩写，是继SSH之后，目前比较主流的Java企业级应用框架。 本质上都是Spring框架+MVC模式框架+ORM技术框架 SpringSpring简介 Struts2简介Struts2是一个基于 MVC设计模式 的表现层框架，Struts2作为控制器来建立模型与视图的数据交互。 缺点 校验较繁琐，多字段时出错返回不同。 安全性太低。 获取传参时较麻烦 SpringMVCSpringMVC简介 Hibernate简介Hibernate是一个基于 ORM程序技术 的持久层框架，与各种数据库，SQL语句打交道，是数据持久化的一种解决方案。 缺点 持久层封装过于完整，导致开发人员无法对SQL进行优化，无法灵活应用原生SQL 批量数据处理能力较弱势 导致配置过于复杂，遇到大项目，维护和问题不断 MyBatisMyBatis简介","tags":[]},{"title":"安装破解Navicat并连接本地数据库(for MySQL)","date":"2021-02-20T16:00:00.000Z","path":"article/20210221.html","text":"本篇文章为安装破解教程 鼓励大家支持正版 正版安装包下载链接如下 Navicat中文网站-Navicat Mysql数据库管理工具下载 下载安装包百度网盘下载链接 提取码:x4s8 提取后有两个文件，其中一个是安装包，一个是破解文件 安装 双击安装包（navicat_trial.exe）点击下一步 同意协议，再次点击下一步 点击“浏览”修改安装路径，也可以直接使用默认安装路径，点击下一步 点击下一步 点击下一步 点击“安装”开始安装 等待安装完成 出现这个界面表示安装完成，点击“完成” 破解 双击破解文件（PatchNavicat.exe） 在安装目录下找到“navicat.exe”文件，选中后点击“打开” 出现如下界面表示破解完成，点击确定 连接本地数据库 新建MySQL连接 出现下图所示弹框 输入连接名和密码 点击连接测试 连接名随便输入即可 密码一定要和MySQL的root用户密码一致 如果出现下图所示提示框表示密码输入错误，可点击确定后重新输入密码 出现下图所示提示框表示连接成功，点击确定建立连接 双击自己设置的连接名，出现如下列表表示连接建立完成","tags":[]},{"title":"安装MySQL并配置环境变量(以MySQL8为例)","date":"2021-02-19T16:00:00.000Z","path":"article/20210220.html","text":"下载官方下载地址：MySQL :: MySQL Downloads 这是MySQL的官方下载页面，我们安装社区版的MySQL，页面下拉点击“MySQL Community (GPL) Downloads”按钮 接下来跳转到这个页面，点击下载社区版的服务器 确认我们的电脑系统，下载免安装版 此时需要注册用户并登录，我们可以点击下方的“No thanks, just start my download.”按钮跳过登录直接下载 等待压缩包下载完成即可 把下载完成的压缩包解压到指定目录下，要注意路径中不能有中文 配置初始化的my.ini文件在解压后的目录下自行创建my.ini配置文件，使用记事本打开后写入如下配置： 其中安装目录和数据库的数据的存放目录需要根据自己的安装目录进行调整，要和解压后的文件夹目录一致 12345678910111213141516171819202122232425[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=解压后的文件夹目录 例如：D:\\\\software\\mysql-8.0.23-winx64# 设置mysql数据库的数据的存放目录datadir=解压后的文件夹目录后加“\\Data” 例如：D:\\\\software\\mysql-8.0.23-winx64\\Data# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为utf8mb4character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8mb4 这里需要注意我们的数据存放目录为“安装目录\\Data”，Data文件夹不需要自己创建 安装服务并初始化虽然我我们下载的是免安装版，还是要用命令安装MySQL服务并且初始化MySQL 以管理员身份打开控制台，一定要是管理员身份，否则后续部分命令会出现权限错误，点此链接查看如何以管理员身份打开CMD控制台（详解-百度经验） 安装服务转到mysql安装目录的bin目录下 使用.\\mysqld --install命令安装MySQL服务 初始化MySQL使用.\\mysqld --initialize --console命令初始化MySQL 初始化会产生一个随机密码，需要复制下来，后面第一次登录会用到 启动服务使用net start mysql命令开启mysql的服务 使用MySQL登录命令mysql -u root -p随机密码，出现如下界面表示安装成功 修改密码使用如下SQL语句修改root用户密码 1alter user \"root\"@\"localhost\" identified by \"新的密码\"; 提示“Query OK”表示命令执行成功 退出登陆后使用新密码登录，验证密码是否修改成功 关闭控制台 环境变量配置环境变量复制MySQL安装目录下bin目录绝对路径 鼠标右键我的电脑-属性 会进入到可以查看计算机基本信息的系统页 点击左侧“高级系统设置” 会弹出“系统属性”对话框 之后点击“环境变量” 会弹出“环境变量”对话框 选中用户变量下的PATH变量，点击“编辑” 弹出“编辑环境变量”对话框，点击新建，粘贴刚才复制的MySQL安装目录下bin目录绝对路径，点击确定 依次点击“环境变量”对话框和“系统属性”对话框中的确定按钮，完成MySQL环境变量配置 检测环境变量是否配置成功WIN+R键打开运行框，输入cmd点击确定打开控制台 输入mysql -u root -p自设密码验证是否可直接登录，登录成功表示配置成功","tags":[]},{"title":"git的安装与配置","date":"2021-02-18T16:00:00.000Z","path":"article/20210219.html","text":"下载并安装官方下载地址：Git-Downloads 安装方法：无特殊需求直接下一步即可 配置git设置Git的用户名和邮件地址（邮箱就是注册Github时候的邮箱） 12$ git config --global user.name \"gengrui01\"$ git config --global user.email \"12******09@qq.com\" Git-GitHub建立联系（SSH）删除原有SSH配置检查电脑是否有ssh配置 1$ ls -al ~/.ssh 出现下面提示表示无ssh配置 1ls: cannot access '/c/Users/HUAWEI/.ssh': No such file or directory 如果未提示上述内容表示已经有ssh配置，需要删除用户文件夹下.ssh文件夹中的所有文件 生成SSH密钥键入命令，注意这里需要输入注册Github时候的邮箱地址，停顿的地方一路回车 1$ ssh-keygen -t rsa -C \"12******09@qq.com\" 之后键入命令 12$ ssh-agent -s$ ssh-add ~/.ssh/id_rsa 如果出现如下错误 1Could not open a connection to your authentication agent. 先执行命令 1$ ssh-agent bash 再重新执行 1$ ssh-add ~/.ssh/id_rsa 添加SSH密钥到GitHub账户执行如下命令复制密钥 1$ clip &lt; ~/.ssh/id_rsa.pub 之后打开GitHubhttps://github.com/GengRui01 ，其中“GengRui01”为用户名 按下图步骤打开设置页 单击左边标签栏中的 SSH and GPG keys 打开密钥管理页 单击 New SSH key 添加SSH密钥 title可以随意输入，key直接粘贴刚才复制好的密钥即可 最后点击添加按钮完成SSH密钥添加","tags":[]},{"title":"IDEA安装破解教程(转发)","date":"2021-02-17T16:00:00.000Z","path":"article/20210218.html","text":"此文章为转载文章 原文作者：诸葛借剑 原文平台：博客园 原文链接：IDEA安装破解教程 如下是正文内容： 一、 下载安装包1.1 方式1 百度网盘链接链接：单击此处百度网盘下载 提取码：68m8 1.2 方式2 官网下载单击此处官网下载 二、 安装IDEA 双击 ideaIU-2020.1.exe 跟着图片走 安装完毕 三、 破解IDEA 在IDEA的安装路径旁 新创建一个文件夹，不要有中文。将第一步骤下载的 其他三个文件 移动到 这个新创建的文件夹中 进入启动页，把jetbrains-agent-latest.jar拖入到启动页 点击【为IDEA安装】 跟着图片走 破解完成 此文章为转载文章 原文作者：诸葛借剑 原文平台：博客园 原文链接：IDEA安装破解教程","tags":[]},{"title":"安装JDK并配置环境变量(以Java8为例)","date":"2021-02-16T16:00:00.000Z","path":"article/20210217.html","text":"下载官方下载地址：JavaSE-Downloads 这是所有版本JDK的下载页面，我们安装Java8版本，往下拉找到JavaSE8，单击JDK Download 在Java SE Development Kit 8u281中找到自己的电脑版本，点击右侧下载按钮 勾选接受协议，点击下载 此时需要注册用户并登录 登录成功后会自动下载，等待安装包下载完成 安装双击打开下载好的安装包，点击下一步即可 点击“更改”可以修改安装路径，修改时要注意路径中不能有中文 也可以使用默认路径不做修改（要记住这个路径，之后配置环境变量会用到） 我们安装的JDK中已经包含了JRE，所以不需要安装“公共JRE” 点击“公共JRE”前面的下拉框，选择第三项“此功能将不可用” 选择好后如下图所示，“公共JRE”前面会变成红色的“X”，之后点击下一步 之后等待安装 安装完成会弹出如下页面，点击关闭 环境变量新建JAVA_HOME环境变量鼠标右键我的电脑-属性 会进入到可以查看计算机基本信息的系统页 点击左侧“高级系统设置” 会弹出“系统属性”对话框 之后点击“环境变量” 会弹出“环境变量”对话框 在用户变量下点击“新增” 新建一个用户变量，变量名为 JAVA_HOME ，变量值为刚才的安装路径，之后点击确定 编辑PATH变量选中PATH变量，点击“编辑” 弹出“编辑环境变量”对话框 新建两个PATH变量分别是%JAVA_HOME%\\bin和%JAVA_HOME%\\jre\\bin 两个PATH变量都新建好后点击确定 新建JAVA_HOME环境变量继续在“环境变量”对话框中的用户变量下点击“新增” 输入变量名CLASSPATH，变量值.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar;，点击确定 依次点击“环境变量”对话框和“系统属性”对话框中的确定按钮，完成JDK环境变量配置 检测环境变量是否配置成功WIN+R键打开运行框，输入cmd点击确定打开控制台 分别输入java -version和javac -version查看JDK版本，结果如图所示表示安装及配置成功","tags":[]},{"title":"博客改版","date":"2020-07-17T16:00:00.000Z","path":"article/20200718.html","text":"改版计划及目前进度博客改版开始啦，这次的改版主要将博客主题修改为简洁轻量的BlueLake主题 博客部署在每次完成文档修改后执行如下指令完成部署（先生成后上传） 12$ hexo generate$ hexo deploy 备份每次部署完成后执行如下指令完成备份 123$ git add .$ git commit -m \"...\"$ git push 更换开发环境备份的目的是满足异地工作的需求，更换开发环境时只需要安装git和node，执行如下操作即可 安装IDEA IDEA的安装及破解方法见往期文章IDEA的安装与破解 安装git 配置git git的安装及配置方法见往期文章git的安装与配置 idea拉取Hexo-admin备份文件 安装hexo 12345$ cd Hexo-admin$ npm install -g hexo-cli$ npm install hexo$ npm install$ npm install hexo-deployer-git --save","tags":[]},{"title":"JDBC连接及操作数据库","date":"2018-10-24T16:00:00.000Z","path":"article/20181025.html","text":"连接数据库步骤第一步：注册驱动 第二步：获取连接 第三步：获取statement对象 第四步：执行SQL语句返回结果集 第五步：遍历结果集 第六步：关闭连接释放资源 传统方式连接数据库123456789101112131415161718192021222324public class JDBCDemo &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2.获取连接 Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/ssm\", \"root\", \"root\"); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from tb_user\"); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(\"username\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125; 用这种方式连接数据库存在一个重要的问题： 注册驱动时，当前类和MySQL的驱动类有很强的依赖关系。 当我们没有驱动类的时候，连编译都不能通过。 这种调用者与被调用者之间的依赖关系，就叫做程序的耦合，耦合分为高耦合（紧密联系）和低耦合（松散联系） 我们在开发中，理想的状态应该是编译时不依赖，运行时才依赖。 要做到编译时不依赖，就需要使用反射来创建类对象。 即将注册驱动部分的代码稍作修改如下： 编译时不依赖的数据库连接12345678910111213141516171819202122232425public class JDBCDemo &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接 Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/ssm\", \"root\", \"root\"); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from tb_user\"); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(\"username\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125; 这样做的好处是，我们的类中不再依赖具体的驱动类，此时就算删除mysql的驱动jar包依然可以通过编译，只不过因为没有驱动类所以不能运行罢了。 不过，此处还有一个问题，就是我们反射类对象的全限定类名称是在java类中写死的，数据库的端口号、用户名密码也是写死的，一旦要修改就等于是要修改源码。自己小打小闹写的代码改源码什么的还好说，但如果是上线项目，改源码势必要停服务器重新编运行。 这么看来这个问题造成的后果很严重，其实它的解决方法也很简单，使用配置文件配置数据库连接信息就可以啦。 使用配置文件连接数据库配置文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.username=rootjdbc.password=root 代码实现12345678910111213141516171819202122232425262728293031323334public class JDBCDemoPro &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //读取配置文件db.properties Properties prop = new Properties(); prop.load(new FileInputStream(\"db.properties\")); //获取配置文件中的相关参数值 String driver = prop.getProperty(\"jdbc.driver\"); String url = prop.getProperty(\"jdbc.url\"); String user = prop.getProperty(\"jdbc.username\"); String password = prop.getProperty(\"jdbc.password\"); //1.注册驱动 Class.forName(driver); //2.获取连接 Connection connection = DriverManager.getConnection(url, user, password); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from tb_user\"); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(\"username\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125;","tags":[]},{"title":"类加载机制","date":"2018-07-17T16:00:00.000Z","path":"article/20180718.html","text":"类的生命周期 加载 找到类文件（通过类的全限定名来获取定义此类的二进制字节流） 放入方法区（将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构） 开个入口（生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口） 连接 校验（检查Class文件的字节流中包含的信息是否符合当前虚拟机的要求） 准备（为静态变量和静态常量分配内存，并给静态常量赋设定值，静态变量赋初始值） 解析（jvm将常量池的符号引用替换为直接引用） 初始化(为静态变量赋程序设定的初值，类只有在如下五种情况下会初始化) 使用new关键字创建类的实例，或读取或设置一个静态字段的值，或调用静态方法的时候 通过java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要首先进行初始化 当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化 当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类 使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REFgetStatic、REFputStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化 使用 卸载 类加载器 启动类加载器(BootStrapClassLoader) 负责加载Java的核心库 是用原生代码来实现的 并不继承自java.lang.ClassLoader 扩展类加载器(ExtClassLoader) 负责加载Java的扩展库 在虚拟机实现时提供的扩展库目录里面查找并加载Java类 应用程序类加载器(AppClassLoader) 负责加载classpath路径下的Java类 一般来说 Java应用的类都是由它来完成加载的 可以通过ClassLoader.getSystemClassLoader()来获取它 用户自定义类加载器 用户根据自定义需求，自由的定制加载的逻辑 一般都继承AppClassLoader，仅仅覆盖findClass()方法，继续遵守双亲委派模型 如上四种类加载器之间存在继承关系，除了引导类加载器外，其他的加载器都可以用getParent()方法获取父类加载器 类加载机制类的加载机制是双亲委派机制，工作过程如下： 当前加载器从自己的缓存中查询是否此类已经加载，有就返回加载好的类（每个类加载器都有自己的加载缓存，已经加载的类都会放入缓存中） 当前加载器的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到启动类加载器 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回 双亲委派的优点是： 保证 Java 程序安全稳定运行，Java 核心 API 定义类型不会被随意替换。比如自己写的String.class类就不会被加载 通过带有优先级的层级关可以避免类的重复加载","tags":[]}]