[{"title":"for forEach 循环及Lambda表达式使用","date":"2021-03-29T16:00:00.000Z","path":"article/20210330.html","text":"for循环for循环语句是代码中常用的循环代码，相对于其他的循环语句更为简单，一般代码结构如下： 123for(初始化; 判别式; 更新) &#123; 代码语句&#125; 执行流程: 首先进行初始化 初始化之后执行判别式，如果判别式结果为真，会执行代码块内容，之后执行更新语句 更新后再次执行判别式，如果判别式结果为真，会执行代码块内容，之后执行更新语句 更新后再次执行判别式，直到判别式结果为假结束循环 以打印List中数据为例 12345678910111213141516171819public class Test &#123; private static void printFor(List&lt;String&gt; list) &#123; System.out.println(\"-----for循环开始-----\"); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; System.out.println(\"-----for循环结束-----\"); &#125; public static void main(String[] args) &#123; // 新建List 输入三个值 List&lt;String&gt; list = new ArrayList(); list.add(\"第1个值\"); list.add(\"第2个值\"); list.add(\"第3个值\"); // for循环打印List中的值 printFor(list); &#125;&#125; 执行结果： forEach循环forEach循环是java5的新特征之一，在遍历数组、集合方面，forEach为开发人员提供了极大的方便 其代码结构如下： 123for(元素类型 元素变量 : 遍历对象)&#123; 代码语句&#125; 遍历对象通常为数组或者集合 元素类型为数组或者集合中所存数据的类型 元素变量为每个元素的变量名 执行流程是循环遍历遍历对象，用元素变量获取遍历对象中的各个元素执行代码语句 以打印List中数据为例 12345678910111213141516171819public class Test &#123; private static void printForEach(List&lt;String&gt; list) &#123; System.out.println(\"-----forEach开始-----\"); for (String str : list) &#123; System.out.println(str); &#125; System.out.println(\"-----forEach结束-----\"); &#125; public static void main(String[] args) &#123; // 新建List 输入三个值 List&lt;String&gt; list = new ArrayList(); list.add(\"第1个值\"); list.add(\"第2个值\"); list.add(\"第3个值\"); // forEach打印List中的值 printForEach(list); &#125;&#125; 执行结果： forEach循环 + Lambda表达式Lambda表达式是java8的新特征之一，它使我们可以更方便地操作集合 forEach循环整合Lambda表达式后代码结构如下： 1遍历对象.forEach(元素变量 -&gt; 代码语句); 遍历对象通常为数组或者集合 元素变量为每个元素的变量名 执行流程是循环遍历遍历对象，用元素变量获取遍历对象中的各个元素执行代码语句 以打印List中数据为例 1234567891011121314151617public class Test &#123; private static void printForEachLambda(List&lt;String&gt; list) &#123; System.out.println(\"-----forEach+Lambda开始-----\"); list.forEach(str -&gt; System.out.println(str)); System.out.println(\"-----forEach+Lambda结束-----\"); &#125; public static void main(String[] args) &#123; // 新建List 输入三个值 List&lt;String&gt; list = new ArrayList(); list.add(\"第1个值\"); list.add(\"第2个值\"); list.add(\"第3个值\"); // forEach+Lambda打印List中的值 printForEachLambda(list); &#125;&#125; 执行结果： 本文源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Test &#123; /** * for循环打印List中的值 * * @param list */ private static void printFor(List&lt;String&gt; list) &#123; System.out.println(\"-----for循环开始-----\"); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; System.out.println(\"-----for循环结束-----\"); &#125; /** * forEach打印List中的值 * * @param list */ private static void printForEach(List&lt;String&gt; list) &#123; System.out.println(\"-----forEach开始-----\"); for (String str : list) &#123; System.out.println(str); &#125; System.out.println(\"-----forEach结束-----\"); &#125; /** * forEach+Lambda打印List中的值 * * @param list */ private static void printForEachLambda(List&lt;String&gt; list) &#123; System.out.println(\"-----forEach+Lambda开始-----\"); list.forEach(str -&gt; System.out.println(str)); System.out.println(\"-----forEach+Lambda结束-----\"); &#125; public static void main(String[] args) &#123; // 新建List 输入三个值 List&lt;String&gt; list = new ArrayList(); list.add(\"第1个值\"); list.add(\"第2个值\"); list.add(\"第3个值\"); // for循环打印List中的值 printFor(list); // forEach打印List中的值 printForEach(list); // forEach+Lambda打印List中的值 printForEachLambda(list); &#125;&#125;","tags":[]},{"title":"if判断和三目运算符","date":"2021-03-22T16:00:00.000Z","path":"article/20210323.html","text":"if判断if条件语句是代码中常用的判断条件的代码，相对于其他的条件判断语句更为简单，一般代码结构如下： 12345if (判别式) &#123; 代码块1&#125; else &#123; 代码块2&#125; 如果判别式结果为真，会执行代码块1，若为假执行代码块2 以取两数中最大值为例 123456789101112131415public class Test &#123; public static Integer getMaxIf(int a, int b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125; &#125; public static void main(String[] args) &#123; int a = 1; int b = 2; System.out.println(\"if 返回最大值\" + getMaxIf(a, b)); &#125;&#125; 三目运算符还有一种比if条件语句更为简单的语句就是三目运算符 但只有if语句中代码块只有一行语句时我们会使用三目运算符来代替if语句 其代码结构如下： 1判别式 ? 代码块1 : 代码块2; 如果判别式结果为真，会执行代码块1，若为假执行代码块2 以取两数中最大值为例 1234567891011121314151617/** * @ClassName Test * @Description * @Author GengRui * @Date 2021/3/23 11:58 */public class Test &#123; public static Integer getMaxTernary(int a, int b) &#123; return a &gt; b ? a : b; &#125; public static void main(String[] args) &#123; int a = 1; int b = 2; System.out.println(\"三目运算符 返回最大值\" + getMaxTernary(a, b)); &#125;&#125; if判断和三目运算符对比 比较发现三目表达式要简洁得多 但如果判断后要执行的代码块偏复杂还是用if判断比较好 本文源码1234567891011121314151617181920212223242526272829303132333435public class Test &#123; /** * if 返回最大值 * * @param a * @param b * @return 最大值 */ public static Integer getMaxIf(int a, int b) &#123; if (a &gt; b) &#123; return a; &#125; else &#123; return b; &#125; &#125; /** * 三目运算符 返回最大值 * * @param a * @param b * @return */ public static Integer getMaxTernary(int a, int b) &#123; return a &gt; b ? a : b; &#125; public static void main(String[] args) &#123; int a = 1; int b = 2; System.out.println(\"if 返回最大值\" + getMaxIf(a, b)); System.out.println(\"三目运算符 返回最大值\" + getMaxTernary(a, b)); &#125;&#125;","tags":[]},{"title":"SpringMVC请求映射注解","date":"2021-03-19T16:00:00.000Z","path":"article/20210320.html","text":"Spring MVC 提供了以下这些请求映射注解： 请求映射注解 说明 类/方法 @RequestMapping 通用的请求处理 类 @GetMapping 处理 HTTP GET 请求 查询方法 @PostMapping 处理 HTTP POST 请求 新增修改方法 @PutMapping 处理 HTTP PUT 请求 新增修改方法 @PatchMapping 处理 HTTP PATCH 请求 新增修改方法 @DeleteMapping 处理 HTTP DELETE 请求 删除方法 除了 @RequestMapping ，其它类型的注解本质上是 @RequestMapping 的简写形式 比如 @GetMapping 其实可以写为@RequestMapping( method = RequestMethod.GET) 建议在类级别上只使用 @RequestMapping ，用于指定基本路径 而在每个方法上根据方法功能不同使用更具体的请求映射注解","tags":[]},{"title":"SpringMVC工程搭建","date":"2021-03-18T16:00:00.000Z","path":"article/20210319.html","text":"创建项目 使用IDEA创建Maven工程 IDEA配置Maven 我们新建Maven项目名为“springmvc-demo“，设置好Maven版本、配置文件以及Maven仓库 由于SpringMVC在 MVC设计模式 中是作为控制器负责前后端代码的连接，我们首先需要添加WEB文件夹用来存放前端代码 添加web右键我们的项目名 -&gt; 选择“Add Framework Support” 选择WebApplication 核实版本号 核实是否会自动创建web.xml 添加好后会出现如下文件夹 搭建配置SpringMVC引入依赖123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 刷新maven等待自动下载 libraries中有了所有导入的包表示依赖引入完成 配置静态资源导出1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Spring核心配置文件SpringMVC是Spring体系的一部分，我们需要添加Spring框架的核心配置文件 文件路径为\\src\\main\\resources文件名为applicationContext.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd \"&gt; &lt;!-- bean definitions here --&gt;&lt;/beans&gt; 添加SpringMVC配置内容我们直接在Spring的配置文件中配置MVC即可 加载注解驱动 在spring中一般采用 SpringMVC请求映射注解 来完成映射关系 要想使请求映射注解生效必须注册DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter实例 annotation-driven配置就是帮助我们自动完成上述两个实例的注入 12&lt;!-- 1加载注解驱动 --&gt;&lt;mvc:annotation-driven/&gt; 静态资源过滤 目的是让SpringMVC不处理静态资源 例如：.css .js .html .mp3 …… 12&lt;!-- 2静态资源过滤 --&gt;&lt;mvc:default-servlet-handler/&gt; 视图解析器 确定视图文件位置，自动给视图文件添加前后缀 12345&lt;!-- 3视图解析器 --&gt;&lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 编写代码测试编写Controller层controller包下新建HelloController类 1234567891011121314package controller;@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello(Model model)&#123; // Model 封装数据 model.addAttribute(\"msg\",\"HELLO MY FIRST SPRING MVC PROJECT\"); // 返回的字符串就是视图的名字 会被视图解析器处理 return \"hello\"; &#125;&#125; 配置Spring容器自动扫描包将Controller对象放进Spring容器 Spring核心配置文件：applicationContext.xml 12&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;&lt;context:component-scan base-package=\"controller\"/&gt; 编写jspWEB-INF包下新建jsp包，jsp包下新建hello.jsp文件 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 编写web.xml 配置前端控制器 12345&lt;!-- 配置前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt; 配置初始化参数 在服务器启动时 加载spring的核心配置文件applicationContext.xml 配置初始化参数的代码写在前端控制器内 12345&lt;!-- 配置初始化参数 --&gt;&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/init-param&gt; 设置启动级别 设置启动级别的代码也写在前端控制器内，数字越小启动越早 12&lt;!-- 设置启动级别 --&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 设置SpringMVC拦截请求 12345&lt;!-- 设置SpringMVC拦截请求 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 用url-pattern中的内容来标识请求拦截： / 匹配所有的请求；（不包括.jsp） /* 匹配所有的请求；（包括.jsp） 为空时所有请求都会被SpringMVC拦截 配置中文乱码过滤器 12345678910111213&lt;!-- 乱码过滤 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 运行web项目打包file -&gt; Project Structure 打开项目构建管理框 首先删除默认打好的包 添加WAR包 点击 + 号 -&gt; Web Application:Exploded -&gt; From Modules… 会弹出如下框依次点击“OK”即可 配置TomCat点击 Add Configuration… 进入运行配置框 点击 + 号 -&gt; Tomcat Server -&gt; Local 点击 Configure 选择我们自己的TomCat 点击 Deployment -&gt; + 号 -&gt; Artifact 会自动加入我们刚才打好的包 Application context 改成/是为了方便在浏览器输入路径 如果你写的是/test，那么在浏览器访问首页的时候需要输入的就是：http://localhost:8080/test 运行TomCat点击绿色的小三角运行TomCat，出现如下内容表示运行成功 在浏览器输入 http://localhost:8080/hello 可以看到页面打印出了我们设置好的值 本文源码GengRui01/springmvc-demo","tags":[]},{"title":"MyBatis操作数据库","date":"2021-03-13T16:00:00.000Z","path":"article/20210314.html","text":"在MyBatis工程搭建 中我们主要讲解的是 MyBatis 如何连接数据库，具体执行 SQL 语句使用的是 JDBC 方式 在MyBatis实现Mapper配置并查询数据 中我们主要讲解的是如何使用MyBatis完成查询数据的操作 相比较查询而言，增加修改删除数据会简单一些，本章节我们会一起学习如何操作数据库 我们新建Maven项目名为“mybatis-operate-database“，设置好Maven版本、配置文件以及Maven仓库 准备数据源因为MyBatis是一个持久层框架，所以我们在使用之前需要准备好数据源 12345678910111213141516171819202122# 删除mybatis_demo数据库drop database if exists mybatis_demo;# 创建mybatis_demo数据库create database mybatis_demo;# 使用mybatis_demo数据库use mybatis_demo;# 创建account表Proxy Patterncreate table user ( id int auto_increment primary key, username varchar(20), age int, score int);# 新增数据insert into user (id, username, age, score) values(1,'peter', 18, 100), (2,'pedro', 24, 200),(3,'jerry', 28, 500), (4,'mike', 12, 300),(5,'tom', 27, 1000); select单条数据要想使用MyBatis首先需要导入MySQL驱动包、MyBatis框架基础包并且添加MyBatis核心配置文件 首先复习下上个章节的内容 代码实现在entity包下创建User实体类：User.java 12345678910package entity;public class User &#123; private Integer id; private String username; private Integer age; private Integer score; // 省略getter&amp;setter方法 // 省略toString方法&#125; 在dao包下创建User模块Dao层：UserDao.java 1234567891011package dao;public interface UserDao &#123; /** * 通过用户id查询用户信息 * * @param id * @return */ User selectUserById(Integer id);&#125; 在资源文件夹下新建dao包，并在其下新建User模块Dao层配置文件：UserDao.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"dao.UserDao\"&gt; &lt;select id=\"selectUserById\" resultType=\"entity.User\"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 新建User模块测试类：UserTest.java 123456789101112131415161718@SuppressWarnings(&#123;\"Duplicates\"&#125;)public class UserTest &#123; public static void main(String[] args) throws IOException, SQLException &#123; // 读取配置文件 InputStream configuration = Resources.getResourceAsStream(\"mybatis-config.xml\"); // 得到 SqlSessionFactory 核心类 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); // 开始一个 sql 会话 SqlSession session = sqlSessionFactory.openSession(); // 得到 Dao UserDao dao = session.getMapper(UserDao.class); // 调用通过用户id查询用户信息的方法 User user = dao.selectUserById(1); System.out.println(user); // 关闭会话 session.close(); &#125;&#125; 执行结果 表示dao已经通过注解的方式搭建好了Java方法和SQL语句之间的桥梁，并且查询出了所需要的一条数据 select多条数据代码实现但是在实际使用时我们常常需要一次性查询多条数据，例如：SELECT * FROM user User模块Dao层配置文件：UserDao.xml 123&lt;select id=\"selectUserList\" resultType=\"entity.User\"&gt; SELECT * FROM user&lt;/select&gt; 这时要用到List集合装对象来完成多条数据的查询工作，User模块Dao层：UserDao.java 123456/** * 查询所有用户信息 * * @return */List&lt;User&gt; selectUserList(); User模块测试类：UserTest.java 123// 调用查询所有用户信息的方法List&lt;User&gt; userList = dao.selectUserList();userList.forEach(u -&gt; System.out.println(u)); TIPS: 对于userList.forEach(u -&gt; System.out.println(u));不理解的需要复习一下for forEach 循环及Lambda表达式使用 执行结果 表示dao已经查询出了所有用户信息存到了List里 insert数据代码实现User模块Dao层：UserDao.java 1234567/** * 新增用户信息 * * @param user * @return */int insertUser(User user); User模块Dao层配置文件：UserDao.xml 123&lt;insert id=\"insertUser\" parameterType=\"entity.User\"&gt; INSERT INTO user VALUES (#&#123;id&#125;,#&#123;username&#125;,#&#123;age&#125;,#&#123;score&#125;)&lt;/insert&gt; User模块测试类：UserTest.java 1234567891011121314// 调用查询所有用户信息的方法List&lt;User&gt; userListBefore = dao.selectUserList();userListBefore.forEach(u -&gt; System.out.println(u));// 创建一个要新增的对象并赋值User insertUser = new User();insertUser.setId(6);insertUser.setUsername(\"anne\");insertUser.setAge(18);insertUser.setScore(600);// 调用新增用户信息的方法int count = dao.insertUser(insertUser);// 调用查询所有用户信息的方法List&lt;User&gt; userListAfter = dao.selectUserList();userListAfter.forEach(u -&gt; System.out.println(u)); 执行结果 新增前后表中数据多了一条表示新增成功 查看数据库发现并没有新增成功 因为MyBatis把事务抽象到了TransactionManager中，而事务默认开启，所以我们只需要使用sqlSession.commit()和rollback()方法，因为在sqlSession中，实际上调用的是transactionManager来完成的具体的事务提交和回滚操作 我们在测试类代码最后加上session的提交 12// 提交sessionsession.commit(); 执行后刷新数据库发现新增了一条id为6的用户信息 update数据代码实现User模块Dao层：UserDao.java 1234567/** * 修改用户信息 * * @param user * @return */int updateUserById(User user); User模块Dao层配置文件：UserDao.xml 1234567&lt;update id=\"updateUserById\" parameterType=\"entity.User\"&gt; UPDATE user SET age = #&#123;age&#125;, username = #&#123;username&#125;, score = #&#123;score&#125; WHERE id = #&#123;id&#125;&lt;/update&gt; User模块测试类：UserTest.java 12345678910// 调用通过用户id查询用户信息的方法User userBefore = dao.selectUserById(6);System.out.println(userBefore);// 把成绩改为900userBefore.setScore(900);// 调用修改用户信息的方法dao.updateUserById(userBefore);// 调用通过用户id查询用户信息的方法User userAfter = dao.selectUserById(6);System.out.println(userAfter); 执行结果控制台打印结果如下图所示 数据库执行前后结果如下图所示 delete数据代码实现User模块Dao层：UserDao.java 1234567/** * 删除用户信息 * * @param id * @return */int deleteUserById(Integer id); User模块Dao层配置文件：UserDao.xml 123&lt;delete id=\"deleteUserById\"&gt; DELETE FROM user WHERE id = #&#123;id&#125;&lt;/delete&gt; User模块测试类：UserTest.java 12345678// 调用查询所有用户信息的方法List&lt;User&gt; userListBefore = dao.selectUserList();userListBefore.forEach(u -&gt; System.out.println(u));// 调用删除用户信息的方法int count = dao.deleteUserById(6);// 调用查询所有用户信息的方法List&lt;User&gt; userListAfter = dao.selectUserList();userListAfter.forEach(u -&gt; System.out.println(u)); 执行结果控制台打印结果如下图所示 数据库执行前后结果如下图所示 本文源码GengRui01/mybatis-operate-database","tags":[]},{"title":"MyBatis实现Mapper配置并查询数据","date":"2021-03-12T16:00:00.000Z","path":"article/20210313.html","text":"什么是Mapper在MyBatis工程搭建 中我们主要讲解的是 MyBatis 如何连接数据库，具体执行 SQL 语句使用的是 JDBC 方式 但在实际应用中是不会选择 JDBC 来执行 SQL 的，MyBatis 提供了 Mapper 作为 Java 方法和 SQL 语句之间的桥梁，来帮助我们更好地去使用 SQL Java 接口方法与 SQL 语句以及 mapper 之间的关系如下图所示： 我们新建Maven项目名为“mybatis-mapper“，设置好Maven版本、配置文件以及Maven仓库 以查询User数据为例感受Mapper引入后和JDBC执行SQL有什么区别 准备数据源因为MyBatis是一个持久层框架，所以我们在使用之前需要准备好数据源 12345678910111213141516171819202122# 删除mybatis_demo数据库drop database if exists mybatis_demo;# 创建mybatis_demo数据库create database mybatis_demo;# 使用mybatis_demo数据库use mybatis_demo;# 创建account表create table user ( id int auto_increment primary key, username varchar(20), age int, score int);# 新增数据insert into user (id, username, age, score) values(1,'peter', 18, 100), (2,'pedro', 24, 200),(3,'jerry', 28, 500), (4,'mike', 12, 300),(5,'tom', 27, 1000); 我们以查询User数据为例感受Mapper引入后和JDBC执行SQL有什么区别 MyBatis 提供了注解和XML两种方式来连接Java方法和SQL语句，首先学习注解方式使用Mapper 注解方式使用Mapper代码实现要想使用MyBatis首先需要导入MySQL驱动包、MyBatis框架基础包并且添加MyBatis核心配置文件 在mybatis-config.xml配置文件中添加上对应的mapper配置 1234&lt;!-- mapper配置 --&gt;&lt;mappers&gt; &lt;mapper class=\"mapper.UserMapper\"/&gt;&lt;/mappers&gt; 新建mapper包，并在其下新建UserMapper.java类 User模块Mapper层：UserMapper.java 1234567891011package mapper;public interface UserMapper &#123; /** * 通过用户id查询用户名称 * * @param id 用户id * @return 用户名称 */ String selectUsernameById(Integer id);&#125; 有了方法定义后，我们再通过注解为该方法添加上对应的SQL语句 1@Select(\"SELECT username FROM user WHERE id = #&#123;id&#125;\") User模块测试类：UserTest.java 123456789101112131415161718@SuppressWarnings(&#123;\"Duplicates\"&#125;)public class UserTest &#123; public static void main(String[] args) throws IOException, SQLException &#123; // 读取配置文件 InputStream configuration = Resources.getResourceAsStream(\"mybatis-config.xml\"); // 得到 SqlSessionFactory 核心类 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); // 开始一个 sql 会话 SqlSession session = sqlSessionFactory.openSession(); // 得到 mapper UserMapper mapper = session.getMapper(UserMapper.class); // 调用注解的SQL String username = mapper.selectUsernameById(1); System.out.println(\"username: \" + username); // 关闭会话 session.close(); &#125;&#125; 测试结果测试结果如下图所示： 表示mapper已经通过注解的方式搭建好了Java方法和SQL语句之间的桥梁，并且查询出了所需要的数据 XML方式使用MapperXML方式是更加强大的一种使用方式，虽然它没有注解那么方便，但是功能更强、更易维护，是 MyBatis 官方推荐的一种方式 代码实现因为我们在mybatis-config.xml配置文件中已经添加过了mapper配置，所以说不需要在配置文件中添加额外的配置 在 UserMapper 接口中，我们再新增一个方法selectUserAgeById，该方法的作用是通过用户id查询用户年龄 User模块Mapper层：UserMapper.java 1234567/** * 通过用户id查询用户年龄 * * @param id 用户id * @return 用户年龄 */Integer selectUserAgeById(Integer id); 这次使用XML的方式添加SQL语句，首先在资源文件夹下新建mapper包，并在其下新建名为UserMapper的XML文件 User模块Mapper层配置文件：UserMapper.xml 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"mapper.UserMapper\"&gt;&lt;/mapper&gt; namespace命名空间是每一个mapper的唯一标识，也是XML文件和Java接口类连接的标识 有了XML文件后，我们使用&lt;select&gt;&lt;/select&gt;标签给查询年龄的方法添加上对应的SQL语句 123&lt;select id=\"selectUserAgeById\" resultType=\"java.lang.Integer\"&gt; SELECT age FROM user WHERE id = #&#123;id&#125;&lt;/select&gt; select 标签中有两个必填属性： id：对应接口的方法名，即 selectUserAgeById，通过它 MyBatis 才能将二者对应起来 resultType：对应 SQL 语句的返回类型，与接口方法的返回值相同，有时会用到resultMap 测试类添加代码调用XML的SQL User模块测试类：UserTest.java 123// 调用XML的SQLInteger age = mapper.selectUserAgeById(1);System.out.println(\"age: \" + age); 测试结果测试结果如下图所示： 表示mapper已经通过XML的方式搭建好了Java方法和SQL语句之间的桥梁，并且查询出了所需要的数据 select-resultType代码实现在UserMapper.xml文件中，我们新增 selectUserById 标签，该 select 标签的作用是：通过id查询用户 123&lt;select id=\"selectUserById\" resultType=\"\"&gt; SELECT * FROM user WHERE id = #&#123;id&#125;&lt;/select&gt; 上面的内容返回的是所有字段值，我们需要自己创建实体类来存储查出来的值 在entity包下创建User实体类：User.java 12345678910package entity;public class User &#123; private Integer id; private String username; private Integer age; private Integer score; // 省略getter&amp;setter方法 // 省略toString方法&#125; 把UserMapper.xml文件中selectUserById标签的返回类型改为上面创建的实体类 1resultType=\"entity.User\" User模块Mapper层：UserMapper.java 1234567/** * 通过用户id查询用户信息 * * @param id * @return */User selectUserById(Integer id); User模块测试类：UserTest.java 123// 调用通过用户id查询用户信息的方法User user = mapper.selectUserById(1);System.out.println(user); 测试结果 在上面这段select标签中，SQL语句返回的是一个复杂对象，即resultType上指定的 User select-resultMapMyBatis自动帮助我们映射数据库数据和Java对象，其实这是MyBatis在幕后帮我们创建了resultMap对象，我们也可手动定义 代码实现User模块Mapper层配置文件：UserMapper.xml 123456&lt;resultMap id=\"userMap\" type=\"entity.User\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"username\" column=\"username\"/&gt; &lt;result property=\"age\" column=\"age\"/&gt; &lt;result property=\"score\" column=\"score\"/&gt;&lt;/resultMap&gt; 上标签中有和两个子标签 其中标签是主键，其它字段均使用 result 标签来映射 标签有property和column两个属性 其中 property 是 Java 对象中的属性名称，column 是数据表与之对应的字段名称 把UserMapper.xml文件中selectUserById标签的返回类型改为上面创建的resultMap 1resultMap=\"userMap\" 测试结果 测试结果和修改前一样，说明MyBatis确实自动帮助我们做了数据映射，但是对于复杂的对象，比如字段名和属性名不同的情况下，我们就必须自定义resultMap了 本文源码GengRui01/mybatis-mapper","tags":[]},{"title":"MyBatis工程搭建","date":"2021-03-08T16:00:00.000Z","path":"article/20210309.html","text":"创建项目使用IDEA创建Maven工程 IDEA配置Maven 我们新建Maven项目名为“mybatis-demo“，设置好Maven版本、配置文件以及Maven仓库 准备数据源因为MyBatis是一个持久层框架，所以我们在配置及使用之前需要先准备好数据源 12345678910111213141516171819202122# 删除mybatis_demo数据库drop database if exists mybatis_demo;# 创建mybatis_demo数据库create database mybatis_demo;# 使用mybatis_demo数据库use mybatis_demo;# 创建account表create table user ( id int auto_increment primary key, username varchar(20), age int, score int);# 新增数据insert into user (id, username, age, score) values(1,'peter', 18, 100), (2,'pedro', 24, 200),(3,'jerry', 28, 500), (4,'mike', 12, 300),(5,'tom', 27, 1000); JDBC连接及操作数据库引入MySQL驱动包12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 刷新maven等待自动下载 libraries中有了导入的包表示依赖引入完成 代码实现12345678910111213141516171819202122public class JDBCDemo &#123; public static void main(String[] args) throws Exception &#123; //1.注册驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //2.获取连接 Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mybatis_demo\", \"root\", \"root\"); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from user WHERE id = ?\"); preparedStatement.setInt(1, 1); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(\"username: \" + resultSet.getString(\"username\")); System.out.println(\"age: \" + resultSet.getString(\"age\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125; 执行结果控制台打印结果如下图所示，表示我们已经成功连接数据库并查出了需要的值 步骤总结 注册驱动 获取连接 获取statement对象 执行SQL语句返回结果集 遍历结果集 关闭连接释放资源 引入MyBatis依赖maven仓库查询网址：MavenRepository mybatis：MyBatis基础包 logback-classic：日志依赖 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.3.0-alpha5&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 刷新maven等待自动下载 libraries中有了所有导入的包表示依赖引入完成 编程式配置方法MyBatis官方文档中并未详细的介绍如何编程式使用MyBatis，因为编程式配置方法代码有点复杂 但是大家没必要被代码吓退，因为在实际的开发中几乎没有机会去写这段代码，一般都是通过配置文件来拿到配置然后开启会话的 我们之所以讲解编程式配置方法，是因为使用配置文件配置时屏蔽了太多的细节 为了层层递进的介绍MyBatis的基础用法，使大家熟悉MyBatis整体结构，我们需要讲解编程式配置方法 代码实现删除JDBC连接及操作数据库：JDBCDemo.java 新建编程式配置文件：StartNoXml.java 123456789101112131415161718192021222324252627282930313233343536@SuppressWarnings(&#123;\"SqlResolve\", \"SqlNoDataSourceInspection\", \"Duplicates\"&#125;)public class StartNoXml &#123; public static void main(String[] args) throws SQLException &#123; // 准备jdbc事务类 JdbcTransactionFactory jdbcTransactionFactory = new JdbcTransactionFactory(); // 配置数据源 PooledDataSource dataSource = new PooledDataSource( \"com.mysql.cj.jdbc.Driver\", \"jdbc:mysql://localhost:3306/mybatis_demo?useSSL=false\", \"root\", \"root\"); // 配置环境，向环境中指定环境id、事务和数据源 Environment environment = new Environment.Builder(\"development\") .transactionFactory(jdbcTransactionFactory) .dataSource(dataSource).build(); // 新建 MyBatis 配置类 Configuration configuration = new Configuration(environment); // 得到 SqlSessionFactory 核心类 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); // 开始一个 sql 会话 SqlSession session = sqlSessionFactory.openSession(); // 得到 sql 连接并运行 sql 语句 PreparedStatement preStatement = session .getConnection() .prepareStatement(\"SELECT * FROM user WHERE id = ?\"); preStatement.setInt(1, 1); ResultSet result = preStatement.executeQuery(); // 验证结果 while (result.next()) &#123; System.out.println(\"username: \" + result.getString(\"username\")); System.out.println(\"age: \" + result.getString(\"age\")); &#125; // 关闭会话 session.close(); &#125;&#125; 执行结果控制台打印结果如下图所示，表示我们已经成功连接数据库并查出了需要的值 步骤总结 得到 MyBatis 配置信息，即代码中的Configuration类 JdbcTransactionFactory 表示事务工厂，当 MyBatis 需要新建事务的时候，会通过它来新建 PooledDataSource 表示数据源，通过其构造参数，我们传入了数据库 url，数据库用户和密码等配置 Configuration 负责 MyBatis 架构中的配置部分，可以有多个 Environment 每个 Environment 都必须有唯一的 id，即代码中的 development 通过 Configuration 来创建 SqlSessionFactory MyBatis 是通过会话的方式来执行 SQL 的，因为我们必须拥有一个会话创建器，即会话工厂 新建 SqlSession 来执行 SQL 有了 SqlSessionFactory 后，我们就可以方便地新建会话，并通过会话来执行 SQL 了 而PreparedStatement及以下的内容，其实并不属于 MyBatis，它们是 JDBC 提供的，在实际的 MyBatis 开发中，你也不会这样去执行 SQL，在这里我们只是为了测试是否配置成功，并且展示 MyBatis 和 JDBC 的关系。 缺点分析可以看到，编程式使用 MyBatis 其实是比较复杂，需要开发人员十分熟悉 MyBatis 的 API，所以绝大多数资料都推荐配置的方式使用 MyBatis 配置文件配置MyBatis代码实现在resources文件夹下新建配置文件：mybatis-config.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 环境变量 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 事务管理器 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- 数据源 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis_demo?useSSL=false\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 有了上面编程式 API 的使用经验，那么你一定可以轻松的看懂配置项： configuration 标签对应 Configuration 类 environment 标签对应 Environment 类 transactionManager 标签对应 JdbcTransactionFactory 类 dataSource 标签对应 PooledDataSource 类 启动类：StartWithXml.java 修改类名为StartWithXml 读取配置文件 1InputStream configuration = Resources.getResourceAsStream(\"mybatis-config.xml\"); 执行结果控制台打印结果如下图所示，表示我们已经成功连接数据库并查出了需要的值 步骤总结 读取配置文件，即 mybatis-config.xml 通过配置文件来创建 SqlSessionFactory 新建 SqlSession 来执行 SQL 本文源码GengRui01/mybatis-demo","tags":[]},{"title":"代理模式","date":"2021-03-05T16:00:00.000Z","path":"article/20210306.html","text":"什么是代理模式这里提到了动态代理的概念，首先解释一下代理模式，代理模式是给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用 通俗来说就是委托人将整栋楼的空房间委托给代理商管理，代理商在不改变房屋架构的基础上二次装修，打造为青年公寓出租给有租房需求的客户 空房间就是原代码，二次装修就是给源代码统一添加功能，租房动作就是对源代码的引用 代理模式的意义 中间隔离作用：在一些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起媒介作用，其特征是代理类和委托类实现相同的接口 增加功能：给代理类增加额外的功能可以用来扩展委托类的功能，这样做只需要修改代理类而不需要再修改委托类 委托类和代理类的功能 委托类实现真正的业务功能 代理类 负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等 代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务 例如将项目加入缓存、日志这些功能就可以使用代理类来完成，没必要打开已经封装好的委托类 静态代理 &amp; 动态代理代理模式可以分为静态代理和动态代理： 静态代理静态代理是由程序员创建或特定工具自动生成源代码，在程序运行之前，代理类就已经编译生成了.class文件。 静态代理的优点是可以在符合开闭原则的情况下对目标对象进行功能扩展，缺点则是开发人员需要为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改 动态代理动态代理是在程序运行时通过反射机制动态创建的，随用随加载。动态代理常用的有基于接口和基于子类两种方式 基于接口的动态代理指的是由JDK官方提供的Proxy类，要求被代理类最少实现一个接口，这种方式大大减少了开发人员的开发任务，减少了对业务接口的依赖，降低了耦合度，缺点就是注定有一个共同的父类叫Proxy，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通 基于子类的动态代理指的是由第三方提供的CGLib，CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以要求被代理类不能用final修饰，即不能是最终类","tags":[]},{"title":"SpringAOP","date":"2021-03-04T16:00:00.000Z","path":"article/20210305.html","text":"Spring的核心特性就是IOC和AOP，之前整理了SpringIOC，这篇文章就来写一下SpringAOP（Aspect Oriented Programming），即：面向切面编程 面向切面编程是指通过预编译和运行期动态代理的方式实现在不修改源代码的情况下给程序动态统一添加功能的一种技术 在学习SpringAOP之前我们需要了解什么是代理模式 文中提到的基于接口的JDK动态代理与基于子类的CGLib动态代理两种动态代理的方式都是实现SpringAOP的基础 在spring中，虽然引入了AspectJ的语法，但是他本质上使用的是动态代理的方式，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式 如果目标对象有接口，优先使用JDK 动态代理，如果目标对象没有接口，则使用CGLib动态代理 简单转账功能我们新建Maven项目名为“spring-aop“，设置好Maven版本、配置文件以及Maven仓库 准备数据12345678910111213141516171819# 删除spring_aop数据库drop database if exists spring_aop;# 创建spring_aop数据库create database spring_aop;# 使用spring_aop数据库use spring_aop;# 创建account表create table account ( id int(11) auto_increment primary key, accountNum varchar(20) default NULL, money int(8) default 0);# 新增数据insert into account (accountNum, money) values(\"622200001\",1000),(\"622200002\",1000); 导包 导入Spring基础包 导入操作数据库、连接数据库、测试需要的包 1234567891011121314151617181920212223242526272829303132&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-dbutils/commons-dbutils --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 核心配置文件 配置自动扫包 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd \"&gt; &lt;!-- bean definitions here --&gt; &lt;context:component-scan base-package=\"dao\"/&gt; &lt;context:component-scan base-package=\"services\"/&gt; &lt;context:component-scan base-package=\"utils\"/&gt;&lt;/beans&gt; 配置数据源 12345678910&lt;!--配置QueryRunner--&gt;&lt;bean id=\"queryRunner\" class=\"org.apache.commons.dbutils.QueryRunner\" scope=\"prototype\"/&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!--连接数据库的必备信息--&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/spring_aop\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"root\"&gt;&lt;/property&gt;&lt;/bean&gt; 代码编写数据库连接工具类：ConnectionUtils.java 12345678910111213141516171819202122232425262728293031323334353637package utils;@Componentpublic class ConnectionUtils &#123; private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;(); @Autowired private ComboPooledDataSource dataSource; /** * 获得当前线程绑定的连接 * * @return */ public Connection getThreadConnection() &#123; try &#123; // 看线程是否绑了连接 Connection conn = tl.get(); if (conn == null) &#123; // 从数据源获取一个连接 conn = dataSource.getConnection(); // 和线程局部变量 绑定 tl.set(conn); &#125; // 返回线程连接 return tl.get(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 把连接和当前线程进行解绑 */ public void remove() &#123; tl.remove(); &#125;&#125; Account模块实体类：Account.java 12345678package entity;public class Account &#123; private Integer id; private String accountNum; private Integer money; // 省略getter&amp;setter方法&#125; Account模块Dao层：AccountDao.java 123456789101112131415161718package dao;public interface AccountDao &#123; /** * 更新 * * @param account */ void updateAccount(Account account); /** * 根据编号查询账户 * * @param accountNum * @return 如果没有结果就返回null，如果结果集超过一个就抛异常，如果有唯一的一个结果就返回 */ Account findAccountByNum(String accountNum);&#125; Account模块Dao层实现类：AccountDaoImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package dao.impl;@Repository(\"accountDao\")public class AccountDaoImpl implements AccountDao &#123; // 数据库查询工具类 @Autowired private QueryRunner runner; // 数据库连接工具类 @Autowired private ConnectionUtils connectionUtils; /** * 更新 * * @param account */ public void updateAccount(Account account) &#123; try &#123; runner.update(connectionUtils.getThreadConnection(), \"update account set accountNum=?,money=? where id=?\", account.getAccountNum(), account.getMoney(), account.getId()); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 根据编号查询账户 * * @param accountNum * @return 如果没有结果就返回null，如果结果集超过一个就抛异常，如果有唯一的一个结果就返回 */ public Account findAccountByNum(String accountNum) &#123; List&lt;Account&gt; accounts = null; try &#123; accounts = runner.query(connectionUtils.getThreadConnection(), \"select * from account where accountNum = ? \", new BeanListHandler&lt;Account&gt;(Account.class), accountNum); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; if (accounts == null || accounts.size() == 0) &#123; // 如果没有结果就返回null return null; &#125; else if (accounts.size() &gt; 1) &#123; // 如果结果集超过一个就抛异常 throw new RuntimeException(\"结果集不唯一，数据有问题\"); &#125; else &#123; // 如果有唯一的一个结果就返回 return accounts.get(0); &#125; &#125;&#125; Account模块Service层：AccountService.java 123456789101112package services;public interface AccountService &#123; /** * 转账 * * @param sourceAccount 转出账户 * @param targetAccount 转入账户 * @param money 转账金额 */ void transfer(String sourceAccount, String targetAccount, Integer money);&#125; Account模块Service层实现类：AccountServiceImpl.java 12345678910111213141516171819202122232425262728293031package services.impl;@Service(\"accountService\")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; /** * 转账 * * @param sourceAccount 转出账户 * @param targetAccount 转入账户 * @param money 转账金额 */ public void transfer(String sourceAccount, String targetAccount, Integer money) &#123; // 查询原始账户 Account source = accountDao.findAccountByNum(sourceAccount); // 查询目标账户 Account target = accountDao.findAccountByNum(targetAccount); // 原始账号减钱 source.setMoney(source.getMoney() - money); // 目标账号加钱 target.setMoney(target.getMoney() + money); // 更新原始账号 accountDao.updateAccount(source); // 更新目标账号 accountDao.updateAccount(target); System.out.println(\"转账完毕\"); &#125;&#125; Account模块测试类：AccountTest.java 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class AccountTest &#123; @Autowired private AccountService accountService; @Test public void testTransfer() &#123; accountService.transfer(\"622200001\", \"622200002\", 100); &#125;&#125; 执行结果 控制台打印结果 修改前数据库中值 修改后数据库中值 可以看到：两个账号的数据已经发生了改变，证明转账的动作确实已经完成 缺点分析在业务层的代码加入一行异常代码 如下图所示： 12// 造异常int i = 1 / 0; 异常代码加在了出账账户金额修改之后，入账账户金额修改之前 执行报ArithmeticException错，如下图所示： 查看数据库中数据发现出账账户money的列值由原来的900变成了800，说明存款确实减少了100 但是由于在代码执行的过程中，出现了异常，导致入账账户并没有增加100 这就出现了数据的事务问题，破坏了数据的原子性和一致性 引入代理模式解决事务实现思路介绍 创建一个工具类，目的是用于管理数据库的事务，提供事务的开启，提交，回滚等操作； 创建一个代理处理器类，目的是生成转账实现类的代理对象，对转账的业务方法提供增强，主要是在数据操作之前，和操作之后干点事，嘿嘿嘿； 在 Spring 的配置文件中，通过 xml 文件的标签实例化管理事务的工具类和生成代理对象的处理器类。 代码实现事务管理器：TransactionManager.java 此工具类主要作用是对数据库连接实现事务的开启，提交以及回滚 至于何时开启、提交、回滚事务，根据业务场景需要调用该类的方法即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package transaction;@Componentpublic class TransactionManager &#123; // 数据库连接工具类 @Autowired private ConnectionUtils connectionUtils; /** * 开启事务 */ public void beginTransaction() &#123; try &#123; System.out.println(\"开启事务\"); connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 提交事务 */ public void commit() &#123; try &#123; System.out.println(\"提交事务\"); connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 回滚事务 */ public void rollback() &#123; try &#123; System.out.println(\"回滚事务\"); connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 释放连接 */ public void release() &#123; try &#123; System.out.println(\"释放连接\"); connectionUtils.getThreadConnection().close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; connectionUtils.removeConnection(); &#125;&#125; 事务代理工具类：TransactionProxyUtils 此类的核心代码是getAccountService方法，该方法返回代理业务类示例 在代理对象的invoke方法内部，实现对原始被代理对象的增强 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package utils;@Componentpublic class TransactionProxyUtils &#123; //被代理的业务类接口 @Autowired private AccountService accountService; //提供事务管理的工具类 @Autowired private TransactionManager transactionManager; /** * 获取AccountService代理对象 * * @return */ public AccountService getAccountService() &#123; return (AccountService) Proxy.newProxyInstance( accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 添加事务的支持 * * @param proxy 被代理的对象实例本身 * @param method 被代理对象正在执行的方法对象 * @param args 正在访问的方法参数对象 * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // Object rtValue = null; try &#123; // 执行操作前开启事务 transactionManager.beginTransaction(); // 执行操作 rtValue = method.invoke(accountService, args); // 执行操作后提交事务 transactionManager.commit(); // 返回结果 return rtValue; &#125; catch (Exception e) &#123; // 捕捉到异常执行回滚操作 transactionManager.rollback(); throw new RuntimeException(e); &#125; finally &#123; // 最终释放连接 transactionManager.release(); &#125; &#125; &#125;); &#125;&#125; 核心配置文件：applicationContext.xml 添加事务管理bean 1&lt;context:component-scan base-package=\"transaction\"/&gt; 配置代理Service 12&lt;!--配置代理的service--&gt;&lt;bean id=\"transactionProxyAccountService\" factory-bean=\"transactionProxyUtils\" factory-method=\"getAccountService\"/&gt; Account模块测试类：AccountTest.java 将原本引入的AccountService实例改为AccountService的事务代理对象 1@Qualifier(\"transactionProxyAccountService\") 执行结果首先将数据库中两账户余额都改为1000 1update account set money = 1000; 控制台打印结果 可以看到：在转账前后由开启、提交事务，最后有释放连接 表示事务代理已经对在不改变源代码的基础上对其做了增强 修改前数据库中值 修改后数据库中值 可以看到：两个账号的数据已经发生了改变，证明转账的动作确实已经完成 再次在出账账户金额修改之后，入账账户金额修改之前添加异常代码，如下图所示 可以看到：在捕捉到异常后进行了事务的回滚 查看数据库中数据发现并没有改变 说明引入代理模式解决了事务问题，保证了数据的原子性和一致性 缺点分析 自定义代理模式代码编写过于臃肿 侵入性比较强，代码不够优雅 控制事务的实现过于繁琐 引入AOP(XML)相关概念使用Spring的AOP替代代理类。先回顾下AOP的概念 AOP是一种编程设计模式，是一种编程技术，使用AOP后通过修改配置即可实现增加或者去除某些附加功能 学习AOP中的常用术语： Join point（连接点） 所谓连接点是指那些可以被拦截到的点 在Spring中这些点指的是方法，可以看作正在访问的，或者等待访问的那些需要被增强功能的方法 Spring只支持方法类型的连接点 Pointcut（切入点） 切入点是一个规则，定义了我们要对哪些Joinpoint进行拦截 因为在一个程序中会存在很多的类，每个类又存在很多的方法，Pointcut来标记哪些方法会应用AOP对该方法做功能增强 Advice（通知） 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。也就是对方法做的增强功能。通知分为如下几类： 前置通知：在连接点之前运行的通知类型，它不会阻止流程进行到连接点，只是在到达连接点之前运行该通知内的行为 后置通知：在连接点正常完成后要运行的通知，正常的连接点逻辑执行完，会运行该通知 最终通知：无论连接点执行后的结果如何，正常还是异常，都会执行的通知 异常通知：如果连接点执行因抛出异常而退出，则执行此通知 环绕通知：环绕通知可以在方法调用之前和之后执行自定义行为 Target（目标） Target指的是代理的目标对象，更通俗的解释就是：AOP对连接点方法做增强，底层是代理模式生成连接点所在类的代理对象，那么连接点所在的类，就是被代理的类称呼为Target Aspect（切面） 切面本质是一个类，只不过是个功能类，作为整合AOP的切入点和通知。 一般来讲，需要在Spring的配置文件中配置，或者通过注解来配置 Weaving（织入） 织入是一种动作的描述，在程序运行时将增强的功能代码也就是通知，根据通知的类型（前缀后缀等…）放到对应的位置，生成代理对象 Proxy（代理） 一个类被AOP织入增强后，产生的结果就是代理类 代码实现在执行原始业务类前对方法增强也就是SpringAOP中所谓的前置通知，对原始业务类中的方法执行之后的增强行为就是后置通知 而一旦出现异常，那么所做的动作就是异常通知。本案例使用几种通知，来实现事务的控制。 删除事务代理工具类：TransactionProxyUtils.java 导入aspectjweaver包 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt;&lt;/dependency&gt; 配置文件中添加 AOP 的相关配置 123456789101112&lt;!-- aop相关的节点配置 --&gt;&lt;aop:config&gt; &lt;!-- 切入点 表示哪些类的哪些方法在执行的时候会应用Spring配置的通知进行增强 --&gt; &lt;aop:pointcut expression=\"execution ( * services.*.*(..))\" id=\"pc\"/&gt; &lt;!-- 配置切面类的节点 作用主要就是整合通知和切入点 --&gt; &lt;aop:aspect ref=\"transactionManager\"&gt; &lt;aop:before method=\"beginTransaction\" pointcut-ref=\"pc\"/&gt; &lt;aop:after-returning method=\"commit\" pointcut-ref=\"pc\"/&gt; &lt;aop:after method=\"release\" pointcut-ref=\"pc\"/&gt; &lt;aop:after-throwing method=\"rollback\" pointcut-ref=\"pc\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 修改测试类代码 执行结果 控制台打印结果 可以看到：在转账前后由开启、提交事务，最后有释放连接 表示SpringAOP已经在不改变源代码的基础上对其做了增强 修改前数据库中值 修改后数据库中值 可以看到：两个账号的数据已经发生了改变，证明转账的动作确实已经完成 再次在出账账户金额修改之后，入账账户金额修改之前添加异常代码，如下图所示 可以看到：在捕捉到异常后进行了事务的回滚 查看数据库中数据发现并没有改变 说明SpringAOP配置的事务管理同样也解决了事务问题，保证了数据的原子性和一致性 通过在xml文件中配置SpringAOP相关配置，就可以实现对我们业务类中的方法实现了增强，无需自定义对业务类做代理实现 XML改注解(AOP)使用注解介绍 @Aspect 此注解用于表明某个类为切面类，而切面类的作用我们之前也解释过，用于整合切入点和通知 @Pointcut 此注解用于声明一个切入点，表明哪些类的哪些方法需要被增强 @Before 前置通知 在连接点之前运行的通知类型，它不会阻止流程进行到连接点，只是在到达连接点之前运行该通知内的行为 @AfterReturning 后置通知 在连接点正常完成后要运行的通知，正常的连接点逻辑执行完，会运行该通知 @After 最终通知 无论连接点执行后的结果如何，正常还是异常，都会执行的通知 @AfterThrowing 异常通知 如果连接点执行因抛出异常而退出，则执行此通知 代码实现 删除XML中的AOPXML配置并注解代理模式 12&lt;!-- 注解 开启代理模式 --&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 注释事务管理器类：TransactionManager.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package transaction;@Component@Aspectpublic class TransactionManager &#123; // 数据库连接工具类 @Autowired private ConnectionUtils connectionUtils; @Pointcut(\"execution(* services.*.*(..))\") private void transactionPointcut() &#123; &#125; /** * 开启事务 */ @Before(\"transactionPointcut()\") public void beginTransaction() &#123; try &#123; System.out.println(\"开启事务\"); connectionUtils.getThreadConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 提交事务 */ @AfterReturning(\"transactionPointcut()\") public void commit() &#123; try &#123; System.out.println(\"提交事务\"); connectionUtils.getThreadConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 回滚事务 */ @AfterThrowing(\"transactionPointcut()\") public void rollback() &#123; try &#123; System.out.println(\"回滚事务\"); connectionUtils.getThreadConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 释放连接 */ @After(\"transactionPointcut()\") public void release() &#123; try &#123; System.out.println(\"释放连接\"); connectionUtils.getThreadConnection().close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; connectionUtils.removeConnection(); &#125;&#125; 执行结果 控制台打印结果 可以看到：在转账前后由开启、提交事务，最后有释放连接 表示SpringAOP已经在不改变源代码的基础上对其做了增强 修改前数据库中值 修改后数据库中值 可以看到：两个账号的数据已经发生了改变，证明转账的动作确实已经完成 再次在出账账户金额修改之后，入账账户金额修改之前添加异常代码，如下图所示 可以看到：在捕捉到异常后进行了事务的回滚 查看数据库中数据发现并没有改变 说明SpringAOP注释的事务管理类同样也解决了事务问题，保证了数据的原子性和一致性 通过注解完成SpringAOP相关配置，就可以实现对我们业务类中的方法实现了增强 总结SpringAOP的作用就是把程序中重复的代码抽取出来，在需要执行的时候，使用动态代理技术，在不修改源码的基础上，对已有方法进行增强 优势就是减少了重复代码，提高代码复用性，提高开发效率，使得代码的维护更加方便 在开发时通常将日志记录，数据库连接池的管理，系统统一的认证、权限管理等用面向切面的方式开发 本文源码GengRui01/spring-aop","tags":[]},{"title":"项目常用后端代码结构","date":"2021-03-03T16:00:00.000Z","path":"article/20210304.html","text":"常用后端代码结构项目常用后端代码结构也就是Controller+Service+Dao，如下图所示： 接下来主要讲这三层的功能划分 Controller层（流程控制层）主要负责具体的业务模块流程的控制 Service层（业务逻辑层）主要负责业务模块的逻辑应用设计 DAO层（数据操作层）主要负责与数据库进行联络的一些任务 总结这三者，通过例子来解释： Controller像是服务员，顾客点什么菜，菜上给几号桌，都是他的职责 Service是厨师，菜单上的菜全是他做的 Dao是厨房的小工，和原材料打交道的事情全是他管 为了方便后端与前端、后端与数据库的数据传输引入了一些定义类，如entity、vo、dto、po、jo等，常用的就是entity和vo vo为视图类，传递和接收前端的数据，与前端所需字段一一对应 entity为实体类，与数据库表一一对应 方法调用流程以查询操作为例数据流动方向如下图所示： Dao层去数据库查询基础数据，查到的基础数据用entity实体类存储 Service层调用Dao层方法拿取基础数据加工处理，加工好的数据用vo视图类存储 Controller层调用Service层方法拿取数据给前端","tags":[]},{"title":"Spring IOC & DI","date":"2021-03-02T16:00:00.000Z","path":"article/20210303.html","text":"什么是IOC &amp; DIIOC（Inversion of Control 控制反转）是面向对象编程中的一种设计模式 其最常见的方式叫做DI（Dependency Injection 依赖注入） 通过控制反转，将实例化对象的控制权，由手动的new变成了Spring框架通过反射机制实例化 需要使用的时候，依赖通过配置文件以及注解的方式注入到对象中 项目常用后端代码结构 如下图所示： 我们新建Maven项目名为“spring-ioc“，设置好Maven版本、配置文件以及Maven仓库 以查询User数据为例对比IOC的引入前后程序耦合性 引入IOC之前代码实现User模块实体类：User.java 12345678package entity;public class User &#123; private Integer id; private String name; private Integer gender; // 省略getter&amp;setter方法&#125; User模块视图类：UserVo.java 1234567891011121314151617package vo;public class UserVo &#123; private Integer id; private String name; private Integer gender; private String genderName; // 省略getter&amp;setter方法 public UserVo() &#123; &#125; public UserVo(User user) &#123; this.id = user.getId(); this.name = user.getName(); this.gender = user.getGender(); &#125; // 省略toString方法&#125; User模块Dao层：UserDao.java 12345package dao;public interface UserDao &#123; User getEntity(Integer id);&#125; User模块Dao层实现类：UserDaoImpl.java 123456789101112package dao.impl;public class UserDaoImpl implements UserDao &#123; public User getEntity(Integer id) &#123; // 此处应该从数据库查询值 方便起见直接返回一个固定对象 User user = new User(); user.setId(1); user.setName(\"Anne\"); user.setGender(0); return user; &#125;&#125; User模块Service层：UserService.java 12345package services;public interface UserService &#123; UserVo getVo(Integer id);&#125; User模块Service层实现类：UserServiceImpl.java 12345678910111213141516package services.impl;public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserVo getVo(Integer id) &#123; // 手动实例化Dao userDao = new UserDaoImpl(); // 执行Dao层方法 User user = userDao.getEntity(id); // 省略业务逻辑处理。。。 UserVo userVo = new UserVo(user); userVo.setGenderName(userVo.getGender() == 0 ? \"female\" : \"male\"); return userVo; &#125;&#125; TIPS: 对于userVo.getGender() == 0 ? &quot;female&quot; : &quot;male&quot;不理解的需要复习一下if判断和三目运算符 User模块Controller层：UserController.java 123456789101112package controller;public class UserController &#123; private UserService userService; public UserVo getVo(Integer id) &#123; // 手动实例化Service userService = new UserServiceImpl(); // 执行Service层方法并返回 return userService.getVo(id); &#125;&#125; User模块测试类：UserTest.java 123456789public class UserTest &#123; public static void main(String[] args) &#123; // 手动实例化Controller UserController userController = new UserController(); // 执行Controller层方法 UserVo userVo = userController.getVo(1); System.out.println(userVo); &#125;&#125; 测试结果测试结果如下图所示： 表示Dao层数据已经一层层传到Controller层并展示了出来 缺点分析1.代码耦合性太强 不利于程序的测试2. 代码也不利于扩展 解决方式：Spring的IOC完美的解决了这一点 对象的实例化由Spring框架加载实现，放到Spring容器中管理，避免了我们手动new对象 有需要用到对象实例依赖，直接向Spring容器要，让他注入即可 而一旦涉及到对象的实例修改，那么只需更改Spring加载实例化对象的地方，程序代码无需改动 从而降低耦合，提升扩展性 引入IOC(XML)代码实现要想使用SpringIOC首先需要导入Spring框架基础包并且添加Spring核心配置文件 将依赖交给Spring的beanFactory管理 123&lt;bean id=\"userDao\" class=\"dao.impl.UserDaoImpl\"/&gt;&lt;bean id=\"userService\" class=\"services.impl.UserServiceImpl\"/&gt;&lt;bean id=\"userController\" class=\"controller.UserController\"/&gt; User模块测试类：UserTest.java 读取配置文件刷新Spring容器 Controller由手动实例化改为从Spring容器拿取 把ApplicationContext传到Controller层继续使用 1234567891011public class UserTest &#123; public static void main(String[] args) &#123; // 读取配置文件刷新Spring容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\"); // 从Spring容器拿Controller UserController userController = (UserController) context.getBean(\"userController\"); // 执行Controller层方法，因为之后还需要用到context对象，故下传 UserVo userVo = userController.getVo(1, context); System.out.println(userVo); &#125;&#125; User模块Controller层：UserController.java Service由手动实例化改为从Spring容器拿取 把ApplicationContext传到Service层继续使用 123456789101112package controller;public class UserController &#123; private UserService userService; public UserVo getVo(Integer id, ApplicationContext context) &#123; // 从Spring容器拿Service userService = (UserService) context.getBean(\"userService\"); // 执行Service层方法，因为之后还需要用到context对象，故下传 return userService.getVo(id, context); &#125;&#125; User模块Service层实现类：UserServiceImpl.java Dao由手动实例化改为从Spring容器拿取 12345678910111213141516package services.impl;public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserVo getVo(Integer id, ApplicationContext context) &#123; // 从Spring容器拿Dao userDao = (UserDao) context.getBean(\"userDao\"); // 执行Dao层方法 User user = userDao.getEntity(id); // 省略业务逻辑处理。。。 UserVo userVo = new UserVo(user); userVo.setGenderName(userVo.getGender() == 0 ? \"female\" : \"male\"); return userVo; &#125;&#125; 测试结果测试结果如下图所示： 表示已经将所有的依赖由手动实例化改为从Spring容器拿取 缺点分析因为每一个类的实例化都需要一个bean标签，一个大型工程有很多类，配置文件的内容未免过于臃肿，维护成本高 解决方式使用注解形式实现SpringIOC XML改注解(IOC)核心配置文件修改context-component-scan标签Spring框架自定义的xml标签，通过base-package属性指明需要被自动扫描实例化的类所在位置 如下代码所示，我们在dao、services、controller下的类是需要扫描自动注入容器的 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd \"&gt; &lt;!-- bean definitions here --&gt; &lt;context:component-scan base-package=\"dao\"/&gt; &lt;context:component-scan base-package=\"services\"/&gt; &lt;context:component-scan base-package=\"controller\"/&gt;&lt;/beans&gt; 修改好后运行项目发现context.getBean()代码报错 说明不是在base-package下的所有类都会自动注入到容器，而是要搭配注解使用 常用注解介绍 @Component：一般用于通用组件类上使用的注解 @Service：一般用于业务逻辑层上使用的注解 @Controller：一般用于流程控制层上使用的注解 @Repository：一般用于数据持久层上使用的注解 依次添加注解，添加之后运行再次报错找不到bean 其实我们在添加注解后，Spring会默认给每个bean设置id，值为类名首字母改为小写 这次报错原因就是找不到名为”userService“的bean 解决办法就是在注解时设置bean的id，保证可以找到bean 测试结果测试结果如下图所示： 表示已经使用注解方式将对象放入Spring容器中 引入DI上面所有的内容都是将对象放入Spring容器中 那么放入之后的使用呢，目前都是使用ApplicationContext拿取容器中的对象 接下来讲解如何使用注解实现依赖注入 常用注解介绍@Autowired注解自动按照类型注入 会从容器中寻找符合依赖类型的实例，但是也有缺点： 因为时按照类型匹配，如果找不到匹配的实例也会抛出异常 如果容器中有多个匹配的类型也会抛出异常，需要指定引入的实例id @Qualifier注解作用是在按照类型注入的基础之上，再按照Bean的id注入。所以如果是使用了@Autowire注解自动注入，但是容器中却有多个匹配的实例，可以搭配此注解，指定需要注入的实例id @Resource注解作用是指定依赖按照id注入，还是按照类型注入。当只使用注解但是不指定注入方式的时候，默认按照id注入，找不到再按照类型注入。 代码实现User模块Controller层：UserController.java 12345678910111213package controller;@Controllerpublic class UserController &#123; // 改为自动注入 @Autowired private UserService userService; public UserVo getVo(Integer id, ApplicationContext context) &#123; // 执行Service层方法，因为之后还需要用到context对象，故下传 return userService.getVo(id, context); &#125;&#125; User模块Dao层实现类：UserDaoImpl.java 去除指定bean id，改为默认bean id（userDaoImpl） 1234567891011121314package dao.impl;// 改为默认bean id“userDaoImpl”@Repositorypublic class UserDaoImpl implements UserDao &#123; public User getEntity(Integer id) &#123; // 此处应该从数据库查询值 方便起见直接返回一个固定对象 User user = new User(); user.setId(1); user.setName(\"Anne\"); user.setGender(0); return user; &#125;&#125; User模块Service层实现类：UserServiceImpl.java 改为自动注入并指定需要注入的实例id 123456789101112131415161718package services.impl;@Service(\"userService\")public class UserServiceImpl implements UserService &#123; // 改为自动注入并指定需要注入的实例id @Autowired @Qualifier(\"userDaoImpl\") private UserDao userDao; public UserVo getVo(Integer id) &#123; // 执行Dao层方法 User user = userDao.getEntity(id); // 省略业务逻辑处理。。。 UserVo userVo = new UserVo(user); userVo.setGenderName(userVo.getGender() == 0 ? \"female\" : \"male\"); return userVo; &#125;&#125; 测试结果测试结果如下图所示： 表示 @Autowired注解已将UserService依赖自动注入UserController @Qualifier注解已指定UserDao依赖的bean id，并使用@Autowired注解自动注入UserServiceImpl 本文源码GengRui01/spring-ioc","tags":[]},{"title":"Spring工程搭建","date":"2021-03-01T16:00:00.000Z","path":"article/20210302.html","text":"创建项目 使用IDEA创建Maven工程 IDEA配置Maven 我们新建Maven项目名为“spring-demo“，设置好Maven版本、配置文件以及Maven仓库 搭建配置Spring引入依赖maven仓库查询网址：MavenRepository spring基础包： spring-core：Core模块主要包含Spring框架基本的核心工具类，Spring的其他组件要都要使用到这个包里的类，Core模块是其他组件的基本核心 spring-beans：包含访问配置文件、创建和管理bean以及进行IOC/DI操作相关的所有类 spring-context：Spring的上下文即IOC容器，通过上下文可以获得容器中的Bean spring-expression：EL表达式语言用于在运行时查询和操纵对象 1234567891011121314151617181920212223242526&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.2.13.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 刷新maven等待自动下载 libraries中有了所有导入的包表示依赖引入完成 核心配置文件框架是一个半成品，已经封装好了很多功能提供我们使用，而我们如何让他们工作呢？ 这里需要创建一个配置文件和Spirng框架通信，文件路径为\\src\\main\\resources文件名为applicationContext.xml 官方给出的配置文件内容如下： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd \"&gt; &lt;!-- bean definitions here --&gt;&lt;/beans&gt; 把他复制到我们的配置文件后左上角会提示“Application context not configured for this file”，点击“Configure application context”，点击OK 编写代码测试接口类新建接口类 编写接口类 12345package services;public interface UserService &#123; public void saveUser();&#125; 实现类新建实现类 实现接口并使用快捷键添加接口方法实现 编写实现方法 123456789package services.impl;import services.UserService;public class UserServiceImpl implements UserService &#123; public void saveUser() &#123; System.out.println(\"service的save方法执行了\"); &#125;&#125; 补充配置文件将我们自定义的实现类交给Spring的容器管理 12&lt;!-- 此标签的作用是利用反射机制将UserServiceImpl类的实例交给Spring容器 --&gt;&lt;bean id=\"userService\" class=\"services.impl.UserServiceImpl\"/&gt; 测试类新建测试类 编写测试类main方法 1234567public class DemoTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\"); UserService service = (UserService) context.getBean(\"userService\"); service.saveUser(); &#125;&#125; Alt+Enter键导包 测试结果 可以看到控制台打印输出 证明确实从容器中获取到了userService实例 执行过程分析BeanFactoryBeanFactory是基础类型的IOC容器，是管理bean容器的根接口，并提供了完整的IOC服务支持 简单来说BeanFactory就是一个管理Bean的工厂，它主要负责初始化各种Bean、调用生命周期等方法 ApplicationContextApplicationContext被称为应用上下文，是BeanFactory接口的子接口，在其基础上提供了其他的附加功能，扩展了BeanFactory接口 ClassPathXmlApplicationContextClassPathXmlApplicationContext是ApplicationContext的实现类，也在其基础上加了许多附加功能 该类从类路径ClassPath中寻找指定的XML配置文件，找到并完成对象实例化工作 其构造器源码如下： 1234567891011121314151617public ClassPathXmlApplicationContext(String configLocation) throws BeansException &#123; this(new String[] &#123;configLocation&#125;, true, null);&#125;public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException &#123; super(parent); // 加载项目中的Spring配置文件 setConfigLocations(configLocations); if (refresh) &#123; // 刷新容器 refresh(); &#125;&#125; 构造器的作用： 调用setConfigLocations方法加载项目中的Spring配置文件 调用refresh方法刷新容器（bean的实例化就在这个方法中） refresh方法源码如下： 1234567891011121314151617181920212223242526272829public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. // 准备容器刷新 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 准备bean工厂对象 prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. // 加载配置文件中的所有bean标签 postProcessBeanFactory(beanFactory); ...... ...... // Instantiate all remaining (non-lazy-init) singletons. // 完成此上下文的bean工厂初始化，初始化所有剩余的单例bean finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. // 完成容器刷新 finishRefresh(); &#125; catch (BeansException ex) &#123; ...... &#125; finally &#123; ...... &#125; &#125;&#125; refresh方法的作用： 准备容器刷新 准备bean工厂对象 加载配置文件中的所有bean标签 完成bean工厂实例化 完成容器刷新 context.getBean()context.getBean()方法是通过配置文件中声明的bean标签id属性获取容器内的实例 本文源码GengRui01/spring-demo","tags":[]},{"title":"IDEA配置Maven","date":"2021-02-28T16:00:00.000Z","path":"article/20210301.html","text":"File-Setting打开设置页 搜索maven 修改maven home directory为maven安装路径 勾选“Override”将setting文件位置及仓库位置改为自配置 修改setting文件位置为 maven安装路径\\conf\\setting.xml 修改仓库位置为 maven安装路径\\repository","tags":[]},{"title":"使用IDEA创建Maven工程","date":"2021-02-27T16:00:00.000Z","path":"article/20210228.html","text":"打开开发工具IDEA，点击创建新项目 核实项目所使用的JDK是否是已经安装好的JDK 选择Maven工程 点击下一步 输入项目名spring-demo可以看到存储位置有自动追加spring-demo 将存储位置改为任意盘下 groupID一般是公司域名，我们可以使用com.自己的姓名全拼作为练习 版本默认即可 点击完成","tags":[]},{"title":"MyBatis简介","date":"2021-02-26T16:00:00.000Z","path":"article/20210227.html","text":"概念MyBatis 是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射 与其它ORM框架不同，MyBatis没有将Java对象与数据表关联起来，而是作为Java方法和SQL语句的桥梁，我们一般称它为半ORM框架 功能 方便地定制化SQL，操作数据库对象 使用简单的XML或注解来配置和映射原生类、接口和Java的POJO为数据库中的记录 提供强大的动态SQL功能，可以更加灵活地使用SQL语句 提供插件增强机制，可以轻松集成其它插件 Hibernate与MyBatis对比 Hibernate 全自动化ORM框架，数据库移植性好，基础业务几乎不需要写SQL 易学难精，上手简单但熟练使用需要阅读大量文档，框架结构复杂 MyBatis 半自动化ORM框架，数据库移植性一般，基础业务仍需写SQL，但可以通过基础Mapper来简化 易学易用，上手简单，结构精简清晰，易深入学习 对比结果： Hibernate适合在需求明确、业务固定的项目中使用，如OA、ERP项目 MyBatis适合在需求多变，快速迭代的项目中使用，如互联网的电商项目","tags":[]},{"title":"ORM程序技术","date":"2021-02-25T16:00:00.000Z","path":"article/20210226.html","text":"JDBC操作数据库步骤JDBC连接及操作数据库 注册驱动 获取连接 获取statement对象 执行SQL语句返回结果集 遍历结果集 关闭连接释放资源 原生JDBC连接及操作数据库有几个缺点： 某条语句执行失败时的处理逻辑非常复杂 要对其中某些业务逻辑做修改，改动代码量较大 概念ORM是对象(Object)、关系(Relational)、映射(Mapping)的缩写，是一种用于实现面向对象编程语言里不同类型系统的数据之间转换的程序技术 作用Java是一门面向对象语言，几乎所有的程序中都存在对象和关系数据库 当对象信息发生变化的时候，我们需要去改数据库中的数据 ORM会把对SQL的操作转换为对象的操作，从而让程序员使用起来更加方便和易于接受 一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段 12345678class Person&#123; Integer id; String name; Integer gender; Date birthday; ...... ......&#125; id name gender birthday 1 Anne 0 1999-01-01 2 Bob 1 1998-08-21 由于类和表之间、属性和字段之间建立起了映射关系，所以SQL对表的操作就可以转换为对象的操作 程序员从此无需编写SQL语句，由框架根据对象的变化及映射关系自动生成SQL语句，这就是ORM的作用 优势 提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 ORM提供了对数据库的映射，不用SQL直接编码，能够像操作对象一样从数据库获取数据","tags":[]},{"title":"SpringMVC简介","date":"2021-02-24T16:00:00.000Z","path":"article/20210225.html","text":"概念SpringMVC是Spring生态圈中的WEB-MVC框架 SpringMVC和Spring的关系由于Spring的概念有狭义广义两种理解方式，SpringMVC和Spring的关系可以从如下两个角度理解： 水平角度：SpringMVC是Spring生态圈中的一个功能模块，两者是包含与被包含的关系； 垂直角度：SpringMVC是建立在Spring核心功能之上的一个WEB-MVC框架，是Spring核心功能的延伸和扩展。 Struts2与SpringMVC对比 Struts2很多功能也需要借助于Spring实现，SpringMVC和Spring有直属血缘的关系，两者吻合度更高 使用SpringMVC时所需要的其他逻辑组件都经由IOC创建Spring容器管理，可根据组件特性保证其线程安全性 SpringMVC利用DI功能，能轻松地装配好各组件之间的依赖，开发者只需要关注编写自己的业务逻辑便可","tags":[]},{"title":"MVC设计模式","date":"2021-02-23T16:00:00.000Z","path":"article/20210224.html","text":"WEB应用WEB应用程序的主流开发技术有 3 种： Servlet PHP .net Servlet是基于Java语言的动态WEB开发技术，Servlet指的是J2EE中所提出来的企业级服务器开发规范。 理论上讲，每一次不同的http请求需要一个Servlet组件来响应，当请求类型比较多时，Servlet就会相应增加，也意味着每一个Servlet都可以成为进入服务器的入口。 原生Servlet构建的MVC开发模式有几个缺点： Servlet本身采用单例设计模式，生命周期由服务器维护，存在线程安全隐患的问题； 随着Servlet数量的增加，对服务器的存储空间也会产生压力； 使用Servlet响应用户请求时，每一个响应逻辑都需要开发者不厌其烦地做些重复的事情，如，解析请求包中的数据、构建响应包、设置页面跳转等等。 概念MVC是模型(Model)、视图(View)、控制器(Controller)的缩写，是一种分离显示业务逻辑、数据和界面的设计模式 组件关系 模型（Model）表示应用程序核心，是应用程序中用于处理应用程序数据逻辑的部分，通常负责在数据库中存取数据。 视图（View）用来显示数据，是应用程序中处理数据显示的部分，通常View是依据Model的数据而创建的。 控制器（Controller）用来处理用户输入并调用模型和视图来满足用户的需求，是应用程序中处理用户交互的部分，通常Controller负责从View读取数据，控制用户输入，并向Model发送数据。 请求响应流程 优势 低耦合性：MVC的视图层和业务层是分离的，如果项目的业务流程或业务规则有所更改，只需要更改MVC的Model层，不需要重新更改编译View和Controller的代码内容。 高可重用性：MVC模式允许不同类型的View访问相同的服务器端代码，多个View可以共享一个Model，它包括任何WEB浏览器(HTTP)或无线浏览器(WAP)，因为这些表示所需要改变的只有View层的实现方式，Model层和Controller层不需要做任何改变。 低生命周期成本：MVC降低了用户界面开发和维护的技术需求，从而降低了生命周期成本 快速部署：使用MVC模式可以大大缩短开发时间，允许后端开发人员只关注业务逻辑，而前端开发人员只需要关注页面的表现形式。 高可维护性：前后端分离使得WEB应用程序更易于维护和修改。","tags":[]},{"title":"Spring简介","date":"2021-02-22T16:00:00.000Z","path":"article/20210223.html","text":"为什么使用Spring？Spring官网 Spring官网首页滚动显示如下内容： Spring makes Java simple. Spring makes Java modern. Spring makes Java productive. Spring makes Java reactive. Spring makes Java cloud-ready. Spring使Java简单易用、紧跟时代、复用性强、快速响应、云就绪。 体系结构介绍 结构图阐释： Data Access/Integration：持久层 是Spring对数据持久化、事务管理的支持。SpringDataJpa就是其中的一种 Web：表现层 是Spring对表现层数据的处理部分的支持。SpirngMVC就是其中的一种 Test：测试层 是Spring对项目提供的一个完整测试环境 中间的两部分 是Spring框架的核心功能 概念Spring刚出世时，仅提供了一些核心功能模块 其中IOC&amp;DI和AOP两大两大核心模块对企业项目开发过程产生了巨大的影响 后来，Spring在核心功能的的基础之上，延伸出更多的功能模块 由这些功能模块为企业项目开发提供了较完整的、全方位的解决方案 所以Spring概念在狭义及广义角度理解不同： 狭义角度：Spring指的是Spring框架核心功能模块 广义角度：Spring是一个提供了众多功能模块的生态圈 核心功能控制反转(IOC) &amp; 依赖注入(DI)控制反转(IOC)简单理解IOC是一种设计模式，将实例化对象的控制权由手动的new变成了Spring框架通过反射机制实例化，并将对象的实例存入在容器种进行管理 依赖注入(DI)IOC是将对象实例化的动作交由了Spring框架，它的作用是降低了程序的耦合，不需要我们手动的创建对象，但是程序的耦合性还是存在 对象中肯定会有一些其余对象的引用，那么这种引用就称为对象的依赖 如果一个类中的某个属性是另一个类，该属性无需手动赋值，通过Spring的配置文件或者注解，通过Spring框架可以实现直接注入属性 IOC &amp; DI 关系未引入Spring框架B类中需要使用A类时 12345class B&#123; A a = new A(); ...... ......&#125; 引入Spring框架后，IOC容器在运行期间Spring动态地将B对象某种依赖关系（A对象）注入到B对象之中 面向切面编程(AOP)首先理解切面，切面是数学中的一个概念，和球面只有一个交点的平面称作球的切面，而接触点称作切点 在Spring中，切面编程指的就是通过预编译和运行期动态代理的方式实现在程序运行某个方法的时候，不修改原始执行代码逻辑，由程序动态地执行某些额外的功能，对原有的方法做增强，这就叫做面向切面编程，那个被监测的执行方法，称呼为切入点。 优势Spring框架以控制反转(IOC)和面向切面编程(AOP)为内核，提供了展现层(SpringMVC)、持久层(SpringJDBC)、业务层事务管理等众多的企业级应用技术，还能整合其他第三方开源框架和类库。 对于对象的实例管理更加方便，代码编写更加优雅，降低代码的耦合性，提升代码的可扩展性。","tags":[]},{"title":"SSH和SSM的区别","date":"2021-02-21T16:00:00.000Z","path":"article/20210222.html","text":"SSH &amp; SSMSSH是Spring+Struts2+Hibernate的缩写，是一种较主流的Java企业级应用框架。 SSM是Spring+SpringMVC+MyBatis的缩写，是继SSH之后，目前比较主流的Java企业级应用框架。 本质上都是Spring框架+MVC模式框架+ORM技术框架 SpringSpring简介 Struts2简介Struts2是一个基于 MVC设计模式 的表现层框架，Struts2作为控制器来建立模型与视图的数据交互。 缺点 校验较繁琐，多字段时出错返回不同。 安全性太低。 获取传参时较麻烦 SpringMVCSpringMVC简介 Hibernate简介Hibernate是一个基于 ORM程序技术 的持久层框架，与各种数据库，SQL语句打交道，是数据持久化的一种解决方案。 缺点 持久层封装过于完整，导致开发人员无法对SQL进行优化，无法灵活应用原生SQL 批量数据处理能力较弱势 导致配置过于复杂，遇到大项目，维护和问题不断 MyBatisMyBatis简介","tags":[]},{"title":"安装破解Navicat并连接本地数据库(for MySQL)","date":"2021-02-20T16:00:00.000Z","path":"article/20210221.html","text":"本篇文章为安装破解教程 鼓励大家支持正版 正版安装包下载链接如下 Navicat中文网站-Navicat Mysql数据库管理工具下载 下载安装包百度网盘下载链接 提取码:x4s8 提取后有两个文件，其中一个是安装包，一个是破解文件 安装 双击安装包（navicat_trial.exe）点击下一步 同意协议，再次点击下一步 点击“浏览”修改安装路径，也可以直接使用默认安装路径，点击下一步 点击下一步 点击下一步 点击“安装”开始安装 等待安装完成 出现这个界面表示安装完成，点击“完成” 破解 双击破解文件（PatchNavicat.exe） 在安装目录下找到“navicat.exe”文件，选中后点击“打开” 出现如下界面表示破解完成，点击确定 连接本地数据库 新建MySQL连接 出现下图所示弹框 输入连接名和密码 点击连接测试 连接名随便输入即可 密码一定要和MySQL的root用户密码一致 如果出现下图所示提示框表示密码输入错误，可点击确定后重新输入密码 出现下图所示提示框表示连接成功，点击确定建立连接 双击自己设置的连接名，出现如下列表表示连接建立完成","tags":[]},{"title":"安装MySQL并配置环境变量(以MySQL8为例)","date":"2021-02-19T16:00:00.000Z","path":"article/20210220.html","text":"下载官方下载地址：MySQL :: MySQL Downloads 这是MySQL的官方下载页面，我们安装社区版的MySQL，页面下拉点击“MySQL Community (GPL) Downloads”按钮 接下来跳转到这个页面，点击下载社区版的服务器 确认我们的电脑系统，下载免安装版 此时需要注册用户并登录，我们可以点击下方的“No thanks, just start my download.”按钮跳过登录直接下载 等待压缩包下载完成即可 把下载完成的压缩包解压到指定目录下，要注意路径中不能有中文 配置初始化的my.ini文件在解压后的目录下自行创建my.ini配置文件，使用记事本打开后写入如下配置： 其中安装目录和数据库的数据的存放目录需要根据自己的安装目录进行调整，要和解压后的文件夹目录一致 12345678910111213141516171819202122232425[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=解压后的文件夹目录 例如：D:\\\\software\\mysql-8.0.23-winx64# 设置mysql数据库的数据的存放目录datadir=解压后的文件夹目录后加“\\Data” 例如：D:\\\\software\\mysql-8.0.23-winx64\\Data# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为utf8mb4character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8mb4 这里需要注意我们的数据存放目录为“安装目录\\Data”，Data文件夹不需要自己创建 安装服务并初始化虽然我我们下载的是免安装版，还是要用命令安装MySQL服务并且初始化MySQL 以管理员身份打开控制台，一定要是管理员身份，否则后续部分命令会出现权限错误，点此链接查看如何以管理员身份打开CMD控制台（详解-百度经验） 安装服务转到mysql安装目录的bin目录下 使用.\\mysqld --install命令安装MySQL服务 初始化MySQL使用.\\mysqld --initialize --console命令初始化MySQL 初始化会产生一个随机密码，需要复制下来，后面第一次登录会用到 启动服务使用net start mysql命令开启mysql的服务 使用MySQL登录命令mysql -u root -p随机密码，出现如下界面表示安装成功 修改密码使用如下SQL语句修改root用户密码 1alter user \"root\"@\"localhost\" identified by \"新的密码\"; 提示“Query OK”表示命令执行成功 退出登陆后使用新密码登录，验证密码是否修改成功 关闭控制台 环境变量配置环境变量复制MySQL安装目录下bin目录绝对路径 鼠标右键我的电脑-属性 会进入到可以查看计算机基本信息的系统页 点击左侧“高级系统设置” 会弹出“系统属性”对话框 之后点击“环境变量” 会弹出“环境变量”对话框 选中用户变量下的PATH变量，点击“编辑” 弹出“编辑环境变量”对话框，点击新建，粘贴刚才复制的MySQL安装目录下bin目录绝对路径，点击确定 依次点击“环境变量”对话框和“系统属性”对话框中的确定按钮，完成MySQL环境变量配置 检测环境变量是否配置成功WIN+R键打开运行框，输入cmd点击确定打开控制台 输入mysql -u root -p自设密码验证是否可直接登录，登录成功表示配置成功","tags":[]},{"title":"git的安装与配置","date":"2021-02-18T16:00:00.000Z","path":"article/20210219.html","text":"下载并安装官方下载地址：Git-Downloads 安装方法：无特殊需求直接下一步即可 配置git设置Git的用户名和邮件地址（邮箱就是注册Github时候的邮箱） 12$ git config --global user.name \"gengrui01\"$ git config --global user.email \"12******09@qq.com\" Git-GitHub建立联系（SSH）删除原有SSH配置检查电脑是否有ssh配置 1$ ls -al ~/.ssh 出现下面提示表示无ssh配置 1ls: cannot access '/c/Users/HUAWEI/.ssh': No such file or directory 如果未提示上述内容表示已经有ssh配置，需要删除用户文件夹下.ssh文件夹中的所有文件 生成SSH密钥键入命令，注意这里需要输入注册Github时候的邮箱地址，停顿的地方一路回车 1$ ssh-keygen -t rsa -C \"12******09@qq.com\" 之后键入命令 12$ ssh-agent -s$ ssh-add ~/.ssh/id_rsa 如果出现如下错误 1Could not open a connection to your authentication agent. 先执行命令 1$ ssh-agent bash 再重新执行 1$ ssh-add ~/.ssh/id_rsa 添加SSH密钥到GitHub账户执行如下命令复制密钥 1$ clip &lt; ~/.ssh/id_rsa.pub 之后打开GitHubhttps://github.com/GengRui01 ，其中“GengRui01”为用户名 按下图步骤打开设置页 单击左边标签栏中的 SSH and GPG keys 打开密钥管理页 单击 New SSH key 添加SSH密钥 title可以随意输入，key直接粘贴刚才复制好的密钥即可 最后点击添加按钮完成SSH密钥添加","tags":[]},{"title":"IDEA安装破解教程(转发)","date":"2021-02-17T16:00:00.000Z","path":"article/20210218.html","text":"此文章为转载文章 原文作者：诸葛借剑 原文平台：博客园 原文链接：IDEA安装破解教程 如下是正文内容： 一、 下载安装包1.1 方式1 百度网盘链接链接：单击此处百度网盘下载 提取码：68m8 1.2 方式2 官网下载单击此处官网下载 二、 安装IDEA 双击 ideaIU-2020.1.exe 跟着图片走 安装完毕 三、 破解IDEA 在IDEA的安装路径旁 新创建一个文件夹，不要有中文。将第一步骤下载的 其他三个文件 移动到 这个新创建的文件夹中 进入启动页，把jetbrains-agent-latest.jar拖入到启动页 点击【为IDEA安装】 跟着图片走 破解完成 此文章为转载文章 原文作者：诸葛借剑 原文平台：博客园 原文链接：IDEA安装破解教程","tags":[]},{"title":"安装JDK并配置环境变量(以Java8为例)","date":"2021-02-16T16:00:00.000Z","path":"article/20210217.html","text":"下载官方下载地址：JavaSE-Downloads 这是所有版本JDK的下载页面，我们安装Java8版本，往下拉找到JavaSE8，单击JDK Download 在Java SE Development Kit 8u281中找到自己的电脑版本，点击右侧下载按钮 勾选接受协议，点击下载 此时需要注册用户并登录 登录成功后会自动下载，等待安装包下载完成 安装双击打开下载好的安装包，点击下一步即可 点击“更改”可以修改安装路径，修改时要注意路径中不能有中文 也可以使用默认路径不做修改（要记住这个路径，之后配置环境变量会用到） 我们安装的JDK中已经包含了JRE，所以不需要安装“公共JRE” 点击“公共JRE”前面的下拉框，选择第三项“此功能将不可用” 选择好后如下图所示，“公共JRE”前面会变成红色的“X”，之后点击下一步 之后等待安装 安装完成会弹出如下页面，点击关闭 环境变量新建JAVA_HOME环境变量鼠标右键我的电脑-属性 会进入到可以查看计算机基本信息的系统页 点击左侧“高级系统设置” 会弹出“系统属性”对话框 之后点击“环境变量” 会弹出“环境变量”对话框 在用户变量下点击“新增” 新建一个用户变量，变量名为 JAVA_HOME ，变量值为刚才的安装路径，之后点击确定 编辑PATH变量选中PATH变量，点击“编辑” 弹出“编辑环境变量”对话框 新建两个PATH变量分别是%JAVA_HOME%\\bin和%JAVA_HOME%\\jre\\bin 两个PATH变量都新建好后点击确定 新建JAVA_HOME环境变量继续在“环境变量”对话框中的用户变量下点击“新增” 输入变量名CLASSPATH，变量值.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar;，点击确定 依次点击“环境变量”对话框和“系统属性”对话框中的确定按钮，完成JDK环境变量配置 检测环境变量是否配置成功WIN+R键打开运行框，输入cmd点击确定打开控制台 分别输入java -version和javac -version查看JDK版本，结果如图所示表示安装及配置成功","tags":[]},{"title":"博客改版","date":"2020-07-17T16:00:00.000Z","path":"article/20200718.html","text":"改版计划及目前进度博客改版开始啦，这次的改版主要将博客主题修改为简洁轻量的BlueLake主题 博客部署在每次完成文档修改后执行如下指令完成部署（先生成后上传） 12$ hexo generate$ hexo deploy 备份每次部署完成后执行如下指令完成备份 123$ git add .$ git commit -m \"...\"$ git push 更换开发环境备份的目的是满足异地工作的需求，更换开发环境时只需要安装git和node，执行如下操作即可 安装IDEA IDEA的安装及破解方法见往期文章IDEA的安装与破解 安装git 配置git git的安装及配置方法见往期文章git的安装与配置 idea拉取Hexo-admin备份文件 安装hexo 12345$ cd Hexo-admin$ npm install -g hexo-cli$ npm install hexo$ npm install$ npm install hexo-deployer-git --save","tags":[]},{"title":"JDBC连接及操作数据库","date":"2018-10-24T16:00:00.000Z","path":"article/20181025.html","text":"连接数据库步骤第一步：注册驱动 第二步：获取连接 第三步：获取statement对象 第四步：执行SQL语句返回结果集 第五步：遍历结果集 第六步：关闭连接释放资源 传统方式连接数据库123456789101112131415161718192021222324public class JDBCDemo &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2.获取连接 Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/ssm\", \"root\", \"root\"); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from tb_user\"); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(\"username\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125; 用这种方式连接数据库存在一个重要的问题： 注册驱动时，当前类和MySQL的驱动类有很强的依赖关系。 当我们没有驱动类的时候，连编译都不能通过。 这种调用者与被调用者之间的依赖关系，就叫做程序的耦合，耦合分为高耦合（紧密联系）和低耦合（松散联系） 我们在开发中，理想的状态应该是编译时不依赖，运行时才依赖。 要做到编译时不依赖，就需要使用反射来创建类对象。 即将注册驱动部分的代码稍作修改如下： 编译时不依赖的数据库连接12345678910111213141516171819202122232425public class JDBCDemo &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //1.注册驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取连接 Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/ssm\", \"root\", \"root\"); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from tb_user\"); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(\"username\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125; 这样做的好处是，我们的类中不再依赖具体的驱动类，此时就算删除mysql的驱动jar包依然可以通过编译，只不过因为没有驱动类所以不能运行罢了。 不过，此处还有一个问题，就是我们反射类对象的全限定类名称是在java类中写死的，数据库的端口号、用户名密码也是写死的，一旦要修改就等于是要修改源码。自己小打小闹写的代码改源码什么的还好说，但如果是上线项目，改源码势必要停服务器重新编运行。 这么看来这个问题造成的后果很严重，其实它的解决方法也很简单，使用配置文件配置数据库连接信息就可以啦。 使用配置文件连接数据库配置文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.username=rootjdbc.password=root 代码实现12345678910111213141516171819202122232425262728293031323334public class JDBCDemoPro &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; //读取配置文件db.properties Properties prop = new Properties(); prop.load(new FileInputStream(\"db.properties\")); //获取配置文件中的相关参数值 String driver = prop.getProperty(\"jdbc.driver\"); String url = prop.getProperty(\"jdbc.url\"); String user = prop.getProperty(\"jdbc.username\"); String password = prop.getProperty(\"jdbc.password\"); //1.注册驱动 Class.forName(driver); //2.获取连接 Connection connection = DriverManager.getConnection(url, user, password); //3.获取Statement对象 PreparedStatement preparedStatement = connection.prepareStatement(\"select * from tb_user\"); //4.执行SQL语句返回结果集 ResultSet resultSet = preparedStatement.executeQuery(); //5.遍历结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(\"username\")); &#125; //6.释放资源 resultSet.close(); preparedStatement.close(); connection.close(); &#125;&#125;","tags":[]},{"title":"类加载机制","date":"2018-07-17T16:00:00.000Z","path":"article/20180718.html","text":"类的生命周期 加载 找到类文件（通过类的全限定名来获取定义此类的二进制字节流） 放入方法区（将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构） 开个入口（生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口） 连接 校验（检查Class文件的字节流中包含的信息是否符合当前虚拟机的要求） 准备（为静态变量和静态常量分配内存，并给静态常量赋设定值，静态变量赋初始值） 解析（jvm将常量池的符号引用替换为直接引用） 初始化(为静态变量赋程序设定的初值，类只有在如下五种情况下会初始化) 使用new关键字创建类的实例，或读取或设置一个静态字段的值，或调用静态方法的时候 通过java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要首先进行初始化 当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化 当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类 使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REFgetStatic、REFputStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化 使用 卸载 类加载器 启动类加载器(BootStrapClassLoader) 负责加载Java的核心库 是用原生代码来实现的 并不继承自java.lang.ClassLoader 扩展类加载器(ExtClassLoader) 负责加载Java的扩展库 在虚拟机实现时提供的扩展库目录里面查找并加载Java类 应用程序类加载器(AppClassLoader) 负责加载classpath路径下的Java类 一般来说 Java应用的类都是由它来完成加载的 可以通过ClassLoader.getSystemClassLoader()来获取它 用户自定义类加载器 用户根据自定义需求，自由的定制加载的逻辑 一般都继承AppClassLoader，仅仅覆盖findClass()方法，继续遵守双亲委派模型 如上四种类加载器之间存在继承关系，除了引导类加载器外，其他的加载器都可以用getParent()方法获取父类加载器 类加载机制类的加载机制是双亲委派机制，工作过程如下： 当前加载器从自己的缓存中查询是否此类已经加载，有就返回加载好的类（每个类加载器都有自己的加载缓存，已经加载的类都会放入缓存中） 当前加载器的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到启动类加载器 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回 双亲委派的优点是： 保证 Java 程序安全稳定运行，Java 核心 API 定义类型不会被随意替换。比如自己写的String.class类就不会被加载 通过带有优先级的层级关可以避免类的重复加载","tags":[]}]